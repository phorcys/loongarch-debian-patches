diff -uNr a/debian/changelog b/debian/changelog
--- a/debian/changelog	2023-06-19 23:30:46.000000000 +0800
+++ b/debian/changelog	2023-06-29 16:16:11.172255230 +0800
@@ -1,3 +1,46 @@
+linux (6.4~rc7-1~exp6) experimental; urgency=medium
+
+  * bump gcc to gcc-13
+  * loong64 enable lbt
+  * loong64 enable AMD GPU DCN support
+  * loong64 enable ls7a  HDA
+  * loong64 add cpufreq hwmon driver
+  * loong64: enalbe ls7a HDA for config
+
+ -- root <root@debian-loongarch>  Sun, 25 Jun 2023 18:14:24 +0800
+
+linux (6.4~rc7-1~exp5) experimental; urgency=medium
+
+  * loong64 enable USB_HID USB_KBD USB_MOUSE
+  * loong64 enable XHCI EHCI OHCI UHCI 
+
+ -- root <root@debian-loongarch>  Sun, 25 Jun 2023 13:04:07 +0800
+
+linux (6.4~rc7-1~exp4) experimental; urgency=medium
+
+  * loong64: enable CONFIG_EFI_EARLYCON=y  
+  *	            CONFIG_SERIAL_EARLYCON=y
+
+ -- root <root@debian-loongarch>  Sat, 24 Jun 2023 17:42:13 +0800
+
+linux (6.4~rc7-1~exp3) experimental; urgency=medium
+
+  * loong64: make serial 8250 builtin
+
+ -- root <root@debian-loongarch>  Sat, 24 Jun 2023 13:12:16 +0800
+
+linux (6.4~rc7-1~exp2) experimental; urgency=medium
+
+  * Non-maintainer upload.
+  * support loong64
+
+ -- root <root@debian-loongarch>  Fri, 23 Jun 2023 15:34:36 +0800
+
 linux (6.4~rc7-1~exp1) experimental; urgency=medium
 
   * New upstream release candidate:
diff -uNr a/debian/config/defines b/debian/config/defines
--- a/debian/config/defines	2023-06-12 19:35:12.000000000 +0800
+++ b/debian/config/defines	2023-06-29 16:16:11.092257130 +0800
@@ -118,6 +118,7 @@
  hppa
  i386
  ia64
+ loong64
  m68k
  mips
  mips64
@@ -142,7 +143,7 @@
  sparc
  sparc64
  x32
-compiler: gcc-12
+compiler: gcc-13
 featuresets:
  none
  rt
@@ -166,7 +167,7 @@
 
 [relations]
 # compilers
-gcc-12: gcc-12 <!stage1 !cross !pkg.linux.nokernel>, gcc-12-@gnu-type-package@ <!stage1 cross !pkg.linux.nokernel>
+gcc-13: gcc-13 <!stage1 !cross !pkg.linux.nokernel>, gcc-13-@gnu-type-package@ <!stage1 cross !pkg.linux.nokernel>
 
 # initramfs-generators
 initramfs-fallback: linux-initramfs-tool
diff -uNr a/debian/config/loong64/config b/debian/config/loong64/config
--- a/debian/config/loong64/config	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/config/loong64/config	2023-06-29 16:16:11.092257130 +0800
@@ -0,0 +1,110 @@
+CONFIG_EFI=y
+CONFIG_EFI_STUB=y
+CONFIG_EFI_GENERIC_STUB=y
+CONFIG_EFI_ZBOOT=y
+
+CONFIG_EFI_EARLYCON=y
+CONFIG_SERIAL_EARLYCON=y
+
+CONFIG_LOONGARCH=y
+CONFIG_64BIT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_L1_CACHE_SHIFT=6
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_MACH_LOONGSON64=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PAGE_SIZE_16KB=y
+CONFIG_PGTABLE_3LEVEL=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_AS_HAS_EXPLICIT_RELOCS=y
+CONFIG_CC_HAS_LSX_EXTENSION=y
+CONFIG_CC_HAS_LASX_EXTENSION=y
+
+CONFIG_CC_HAS_LSX_EXTENSION=y
+CONFIG_CPU_HAS_LSX=y
+CONFIG_CC_HAS_LASX_EXTENSION=y
+CONFIG_CPU_HAS_LASX=y
+CONFIG_CPU_HAS_LBT=y
+CONFIG_CPU_HWMON=y
+
+
+
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_NONSTANDARD=y
+
+##
+## file: drivers/cpufreq/Kconfig
+##
+
+CONFIG_LOONGSON3_CPUFREQ=m
+
+##
+## file: drivers/gpu/drm/Kconfig
+##
+CONFIG_DRM=m
+
+##
+## file: drivers/gpu/drm/amd/amdgpu/Kconfig
+##
+CONFIG_DRM_AMDGPU=m
+
+##
+## file: drivers/gpu/drm/radeon/Kconfig
+##
+CONFIG_DRM_RADEON=m
+
+##
+## file: drivers/gpu/drm/sun4i/Kconfig
+##
+CONFIG_DRM_SUN4I=m
+
+CONFIG_DRM_ETNAVIV=m
+CONFIG_DRM_ETNAVIV_THERMAL=y
+
+
+#
+# file : driver/usb/Kconfig
+#
+
+CONFIG_USB_XHCI_HCD=m
+CONFIG_USB_XHCI_PCI=m
+CONFIG_USB_XHCI_PCI_RENESAS=m
+CONFIG_USB_XHCI_PLATFORM=m
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=m
+CONFIG_USB_EHCI_HCD_PLATFORM=m
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_OHCI_HCD_PCI=m
+CONFIG_USB_OHCI_HCD_PLATFORM=m
+CONFIG_USB_UHCI_HCD=m
+
+#
+# file : driver/hid/Kconfig
+#
+
+CONFIG_USB_HID=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_KBD=y
+CONFIG_USB_MOUSE=y
+CONFIG_USB_HIDINPUT=y
+
+#
+# file: driver/sound/hda/Kconfig
+#
+
+CONFIG_SND_HDA_LOONGSON=y
+
diff -uNr a/debian/config/loong64/defines b/debian/config/loong64/defines
--- a/debian/config/loong64/defines	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/config/loong64/defines	2023-06-29 16:16:11.092257130 +0800
@@ -0,0 +1,15 @@
+[base]
+kernel-arch: loongarch
+featuresets:
+ none
+
+[build]
+image-file: arch/loongarch/boot/vmlinuz.efi
+vdso: true
+
+[image]
+install-stem: vmlinuz
+
+[loong64_description]
+hardware: 64-bit LoongArch platforms
+hardware-long: 64-bit LoongArch platforms
diff -uNr a/debian/config/loong64/none/defines b/debian/config/loong64/none/defines
--- a/debian/config/loong64/none/defines	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/config/loong64/none/defines	2023-06-29 16:16:11.092257130 +0800
@@ -0,0 +1,4 @@
+[base]
+flavours:
+ loong64
+default-flavour: loong64
diff -uNr a/debian/control b/debian/control
--- a/debian/control	2023-06-19 23:30:46.000000000 +0800
+++ b/debian/control	2023-06-29 16:16:11.096257035 +0800
@@ -5,7 +5,7 @@
 Uploaders: Bastian Blank <waldi@debian.org>, maximilian attems <maks@debian.org>, Ben Hutchings <benh@debian.org>, Salvatore Bonaccorso <carnil@debian.org>
 Standards-Version: 4.2.0
 Build-Depends: debhelper-compat (= 12), dh-exec, python3:native, python3-jinja2:native, quilt, cpio <!stage1>, xz-utils <!stage1>, dh-python <!stage1>, bison <!stage1>, flex (>= 2.6.1-1.1~) <!stage1>
-Build-Depends-Arch: kernel-wedge (>= 2.102~) <!pkg.linux.nokernel !stage1>, kmod <!pkg.linux.nokernel !stage1>, bc <!pkg.linux.nokernel !stage1>, libssl-dev:native <!pkg.linux.nokernel !stage1>, libssl-dev <!pkg.linux.notools !stage1>, openssl (>= 1.1.0-1~) <!pkg.linux.nokernel !stage1>, libelf-dev:native <!pkg.linux.nokernel !stage1>, libelf-dev <!pkg.linux.notools !stage1>, rsync, lz4 [amd64 arm64] <!pkg.linux.nokernel !stage1>, pahole <!pkg.linux.nokernel !stage1> | dwarves:native (>= 1.16~) <!pkg.linux.nokernel !stage1>, gcc-12 [alpha amd64 arm64 armel armhf hppa i386 ia64 m68k mips mips64 mips64el mips64r6 mips64r6el mipsel mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390x sh4 sparc64] <!cross !pkg.linux.nokernel !stage1>, gcc-12-alpha-linux-gnu [alpha] <cross !pkg.linux.nokernel !stage1>, gcc-12-x86-64-linux-gnu [amd64] <cross !pkg.linux.nokernel !stage1>, gcc-12-aarch64-linux-gnu [arm64] <cross !pkg.linux.nokernel !stage1>, gcc-arm-linux-gnueabihf [arm64] <!pkg.linux.nokernel !stage1>, gcc-12-arm-linux-gnueabi [armel] <cross !pkg.linux.nokernel !stage1>, gcc-12-arm-linux-gnueabihf [armhf] <cross !pkg.linux.nokernel !stage1>, gcc-12-hppa-linux-gnu [hppa] <cross !pkg.linux.nokernel !stage1>, gcc-hppa-linux-gnu [hppa] <cross !pkg.linux.nokernel !stage1>, binutils-hppa64-linux-gnu:native [hppa] <!pkg.linux.nokernel !stage1>, gcc-12-hppa64-linux-gnu:native [hppa] <!pkg.linux.nokernel !stage1>, gcc-12-i686-linux-gnu [i386] <cross !pkg.linux.nokernel !stage1>, gcc-12-ia64-linux-gnu [ia64] <cross !pkg.linux.nokernel !stage1>, gcc-12-m68k-linux-gnu [m68k] <cross !pkg.linux.nokernel !stage1>, gcc-12-mips-linux-gnu [mips] <cross !pkg.linux.nokernel !stage1>, gcc-12-mips64-linux-gnuabi64 [mips64] <cross !pkg.linux.nokernel !stage1>, gcc-12-mips64el-linux-gnuabi64 [mips64el] <cross !pkg.linux.nokernel !stage1>, gcc-12-mipsisa64r6-linux-gnuabi64 [mips64r6] <cross !pkg.linux.nokernel !stage1>, gcc-12-mipsisa64r6el-linux-gnuabi64 [mips64r6el] <cross !pkg.linux.nokernel !stage1>, gcc-12-mipsel-linux-gnu [mipsel] <cross !pkg.linux.nokernel !stage1>, gcc-12-mipsisa32r6-linux-gnu [mipsr6] <cross !pkg.linux.nokernel !stage1>, gcc-12-mipsisa32r6el-linux-gnu [mipsr6el] <cross !pkg.linux.nokernel !stage1>, gcc-12-powerpc-linux-gnu [powerpc] <cross !pkg.linux.nokernel !stage1>, gcc-12-powerpc64-linux-gnu [ppc64] <cross !pkg.linux.nokernel !stage1>, gcc-12-powerpc64le-linux-gnu [ppc64el] <cross !pkg.linux.nokernel !stage1>, gcc-12-riscv64-linux-gnu [riscv64] <cross !pkg.linux.nokernel !stage1>, gcc-12-s390x-linux-gnu [s390x] <cross !pkg.linux.nokernel !stage1>, gcc-12-sh4-linux-gnu [sh4] <cross !pkg.linux.nokernel !stage1>, gcc-12-sparc64-linux-gnu [sparc64] <cross !pkg.linux.nokernel !stage1>, python3-docutils [linux-any] <!nodoc !pkg.linux.notools !stage1>, zlib1g-dev [linux-any] <!pkg.linux.notools !stage1>, libcap-dev [linux-any] <!pkg.linux.notools !stage1>, libpci-dev [linux-any] <!pkg.linux.notools !stage1>, asciidoctor [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nodoc !nopython !pkg.linux.notools !stage1>, gcc-multilib [amd64 mips64 mips64el mips64r6 mips64r6el ppc64 s390x sparc64] <!nopython !pkg.linux.notools !stage1>, libaudit-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libbabeltrace-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libdw-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libnewt-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libnuma-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libopencsd-dev (>= 1.1.1) [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libperl-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libpython3-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libtraceevent-dev (>= 1:1.5) [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libunwind-dev [amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mipsel powerpc ppc64 ppc64el sh4] <!nopython !pkg.linux.notools !stage1>, libzstd-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, python3-dev:any [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, python3-setuptools [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, autoconf [linux-any] <!pkg.linux.notools !stage1>, automake [linux-any] <!pkg.linux.notools !stage1>, libtool [linux-any] <!pkg.linux.notools !stage1>, libglib2.0-dev [linux-any] <!pkg.linux.notools !stage1>, libudev-dev [linux-any] <!pkg.linux.notools !stage1>, libwrap0-dev [linux-any] <!pkg.linux.notools !stage1>, libtracefs-dev (>= 1.3) [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>, libtraceevent-dev (>= 1:1.5) [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>, python3-docutils [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>
+Build-Depends-Arch: kernel-wedge (>= 2.102~) <!pkg.linux.nokernel !stage1>, kmod <!pkg.linux.nokernel !stage1>, bc <!pkg.linux.nokernel !stage1>, libssl-dev:native <!pkg.linux.nokernel !stage1>, libssl-dev <!pkg.linux.notools !stage1>, openssl (>= 1.1.0-1~) <!pkg.linux.nokernel !stage1>, libelf-dev:native <!pkg.linux.nokernel !stage1>, libelf-dev <!pkg.linux.notools !stage1>, rsync, lz4 [amd64 arm64] <!pkg.linux.nokernel !stage1>, pahole <!pkg.linux.nokernel !stage1> | dwarves:native (>= 1.16~) <!pkg.linux.nokernel !stage1>, gcc-13 [alpha amd64 arm64 armel armhf hppa i386 ia64 loong64 m68k mips mips64 mips64el mips64r6 mips64r6el mipsel mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390x sh4 sparc64] <!cross !pkg.linux.nokernel !stage1>, gcc-13-alpha-linux-gnu [alpha] <cross !pkg.linux.nokernel !stage1>, gcc-13-x86-64-linux-gnu [amd64] <cross !pkg.linux.nokernel !stage1>, gcc-13-aarch64-linux-gnu [arm64] <cross !pkg.linux.nokernel !stage1>, gcc-13-arm-linux-gnueabi [armel] <cross !pkg.linux.nokernel !stage1>, gcc-13-arm-linux-gnueabihf [armhf] <cross !pkg.linux.nokernel !stage1>, gcc-13-hppa-linux-gnu [hppa] <cross !pkg.linux.nokernel !stage1>, gcc-13-i686-linux-gnu [i386] <cross !pkg.linux.nokernel !stage1>, gcc-13-ia64-linux-gnu [ia64] <cross !pkg.linux.nokernel !stage1>, gcc-13-loongarch64-linux-gnu [loong64] <cross !pkg.linux.nokernel !stage1>, gcc-13-m68k-linux-gnu [m68k] <cross !pkg.linux.nokernel !stage1>, gcc-13-mips-linux-gnu [mips] <cross !pkg.linux.nokernel !stage1>, gcc-13-mips64-linux-gnuabi64 [mips64] <cross !pkg.linux.nokernel !stage1>, gcc-13-mips64el-linux-gnuabi64 [mips64el] <cross !pkg.linux.nokernel !stage1>, gcc-13-mipsisa64r6-linux-gnuabi64 [mips64r6] <cross !pkg.linux.nokernel !stage1>, gcc-13-mipsisa64r6el-linux-gnuabi64 [mips64r6el] <cross !pkg.linux.nokernel !stage1>, gcc-13-mipsel-linux-gnu [mipsel] <cross !pkg.linux.nokernel !stage1>, gcc-13-mipsisa32r6-linux-gnu [mipsr6] <cross !pkg.linux.nokernel !stage1>, gcc-13-mipsisa32r6el-linux-gnu [mipsr6el] <cross !pkg.linux.nokernel !stage1>, gcc-13-powerpc-linux-gnu [powerpc] <cross !pkg.linux.nokernel !stage1>, gcc-13-powerpc64-linux-gnu [ppc64] <cross !pkg.linux.nokernel !stage1>, gcc-13-powerpc64le-linux-gnu [ppc64el] <cross !pkg.linux.nokernel !stage1>, gcc-13-riscv64-linux-gnu [riscv64] <cross !pkg.linux.nokernel !stage1>, gcc-13-s390x-linux-gnu [s390x] <cross !pkg.linux.nokernel !stage1>, gcc-13-sh4-linux-gnu [sh4] <cross !pkg.linux.nokernel !stage1>, gcc-13-sparc64-linux-gnu [sparc64] <cross !pkg.linux.nokernel !stage1>, python3-docutils [linux-any] <!nodoc !pkg.linux.notools !stage1>, zlib1g-dev [linux-any] <!pkg.linux.notools !stage1>, libcap-dev [linux-any] <!pkg.linux.notools !stage1>, libpci-dev [linux-any] <!pkg.linux.notools !stage1>, asciidoctor [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nodoc !nopython !pkg.linux.notools !stage1>, gcc-multilib [amd64 mips64 mips64el mips64r6 mips64r6el ppc64 s390x sparc64] <!nopython !pkg.linux.notools !stage1>, libaudit-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libbabeltrace-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libdw-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libnewt-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libnuma-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libopencsd-dev (>= 1.1.1) [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libperl-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libpython3-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libtraceevent-dev (>= 1:1.5) [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, libunwind-dev [amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mipsel powerpc ppc64 ppc64el sh4] <!nopython !pkg.linux.notools !stage1>, libzstd-dev [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, python3-dev:any [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, python3-setuptools [alpha amd64 arm64 armel armhf hppa i386 mips mips64 mips64el mips64r6 mips64r6el mipsel mipsn32 mipsn32el mipsn32r6 mipsn32r6el mipsr6 mipsr6el powerpc ppc64 ppc64el riscv64 s390 s390x sh4 sparc sparc64] <!nopython !pkg.linux.notools !stage1>, autoconf [linux-any] <!pkg.linux.notools !stage1>, automake [linux-any] <!pkg.linux.notools !stage1>, libtool [linux-any] <!pkg.linux.notools !stage1>, libglib2.0-dev [linux-any] <!pkg.linux.notools !stage1>, libudev-dev [linux-any] <!pkg.linux.notools !stage1>, libwrap0-dev [linux-any] <!pkg.linux.notools !stage1>, libtracefs-dev (>= 1.3) [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>, libtraceevent-dev (>= 1:1.5) [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>, python3-docutils [amd64 arm64 armhf i386 x32] <!pkg.linux.notools !stage1>
 Build-Depends-Indep: graphviz <!nodoc !pkg.linux.quick !stage1>, python3-sphinx <!nodoc !pkg.linux.quick !stage1>, python3-sphinx-rtd-theme <!nodoc !pkg.linux.quick !stage1>, texlive-latex-base <!nodoc !pkg.linux.quick !stage1>, texlive-latex-extra <!nodoc !pkg.linux.quick !stage1>, dvipng <!nodoc !pkg.linux.quick !stage1>, patchutils <!pkg.linux.nosource !pkg.linux.quick !stage1>
 Rules-Requires-Root: no
 Homepage: https://www.kernel.org/
@@ -18,7 +18,7 @@
 Build-Profiles: <!stage1>
 Depends: ${python3:Depends}, python3-jinja2, ${misc:Depends}
 Multi-Arch: foreign
-Description: Support files for Linux 6.4-rc7
+Description: Support files for Linux 6.4
  This package provides support files for the Linux kernel build, e.g.
  scripts to handle ABI information and for generation of build system meta
  data.
@@ -752,7 +752,7 @@
 Package: linux-headers-6.4.0-0-alpha-generic
 Architecture: alpha
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-alpha-generic
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-alpha-generic, generally used for building
@@ -768,8 +768,8 @@
 Recommends: firmware-linux-free, apparmor [alpha]
 Suggests: linux-doc-6.4, debian-kernel-handbook, aboot [alpha], fdutils [alpha]
 Breaks: fwupdate (<< 12-7) [alpha], wireless-regdb (<< 2019.06.03-1~) [alpha], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Alpha
- The Linux kernel 6.4-rc7 and modules for use on DEC Alpha systems with
+Description: Linux 6.4 for Alpha
+ The Linux kernel 6.4 and modules for use on DEC Alpha systems with
  extended kernel start address (Wildfire, Titan, Marvel).
 
 Package: linux-image-alpha-generic
@@ -812,7 +812,7 @@
 Package: linux-headers-6.4.0-0-alpha-smp
 Architecture: alpha
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-alpha-smp
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-alpha-smp, generally used for building out-of-tree
@@ -828,8 +828,8 @@
 Recommends: firmware-linux-free, apparmor [alpha]
 Suggests: linux-doc-6.4, debian-kernel-handbook, aboot [alpha], fdutils [alpha]
 Breaks: fwupdate (<< 12-7) [alpha], wireless-regdb (<< 2019.06.03-1~) [alpha], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Alpha SMP
- The Linux kernel 6.4-rc7 and modules for use on DEC Alpha SMP systems with
+Description: Linux 6.4 for Alpha SMP
+ The Linux kernel 6.4 and modules for use on DEC Alpha SMP systems with
  extended kernel start address (Wildfire, Titan, Marvel).
 
 Package: linux-image-alpha-smp
@@ -1513,7 +1513,7 @@
 Package: linux-headers-6.4.0-0-amd64
 Architecture: amd64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-amd64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-amd64, generally used for building out-of-tree kernel
@@ -1531,9 +1531,9 @@
 Replaces: linux-image-6.4.0-0-amd64
 Breaks: fwupdate (<< 12-7) [amd64], wireless-regdb (<< 2019.06.03-1~) [amd64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-amd64
-Description: Linux 6.4-rc7 for 64-bit PCs
- The Linux kernel 6.4-rc7 and modules for use on PCs with AMD64, Intel 64
- or VIA Nano processors.
+Description: Linux 6.4 for 64-bit PCs
+ The Linux kernel 6.4 and modules for use on PCs with AMD64, Intel 64 or
+ VIA Nano processors.
 
 Package: linux-image-6.4.0-0-amd64-dbg
 Architecture: amd64
@@ -1557,7 +1557,7 @@
 Package: linux-headers-6.4.0-0-cloud-amd64
 Architecture: amd64
 Build-Profiles: <!pkg.linux.nokernel !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-cloud-amd64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-cloud-amd64, generally used for building out-of-tree
@@ -1575,8 +1575,8 @@
 Replaces: linux-image-6.4.0-0-cloud-amd64
 Breaks: fwupdate (<< 12-7) [amd64], wireless-regdb (<< 2019.06.03-1~) [amd64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-cloud-amd64
-Description: Linux 6.4-rc7 for x86-64 cloud
- The Linux kernel 6.4-rc7 and modules for use on cloud platforms including
+Description: Linux 6.4 for x86-64 cloud
+ The Linux kernel 6.4 and modules for use on cloud platforms including
  Amazon EC2, Microsoft Azure, and Google Compute Engine.
 
 Package: linux-image-6.4.0-0-cloud-amd64-dbg
@@ -1601,7 +1601,7 @@
 Package: linux-headers-6.4.0-0-rt-amd64
 Architecture: amd64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-rt-amd64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-rt-amd64, generally used for building out-of-tree
@@ -1619,9 +1619,9 @@
 Replaces: linux-image-6.4.0-0-rt-amd64
 Breaks: fwupdate (<< 12-7) [amd64], wireless-regdb (<< 2019.06.03-1~) [amd64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-rt-amd64
-Description: Linux 6.4-rc7 for 64-bit PCs, PREEMPT_RT
- The Linux kernel 6.4-rc7 and modules for use on PCs with AMD64, Intel 64
- or VIA Nano processors.
+Description: Linux 6.4 for 64-bit PCs, PREEMPT_RT
+ The Linux kernel 6.4 and modules for use on PCs with AMD64, Intel 64 or
+ VIA Nano processors.
  .
  This kernel includes the PREEMPT_RT realtime patch set.
 
@@ -2179,7 +2179,7 @@
 Package: linux-headers-6.4.0-0-arm64
 Architecture: arm64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-arm64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-arm64, generally used for building out-of-tree kernel
@@ -2197,8 +2197,8 @@
 Replaces: linux-image-6.4.0-0-arm64
 Breaks: fwupdate (<< 12-7) [arm64], wireless-regdb (<< 2019.06.03-1~) [arm64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-arm64
-Description: Linux 6.4-rc7 for 64-bit ARMv8 machines
- The Linux kernel 6.4-rc7 and modules for use on 64-bit ARMv8 machines.
+Description: Linux 6.4 for 64-bit ARMv8 machines
+ The Linux kernel 6.4 and modules for use on 64-bit ARMv8 machines.
 
 Package: linux-image-6.4.0-0-arm64-dbg
 Architecture: arm64
@@ -2222,7 +2222,7 @@
 Package: linux-headers-6.4.0-0-cloud-arm64
 Architecture: arm64
 Build-Profiles: <!pkg.linux.nokernel !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-cloud-arm64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-cloud-arm64, generally used for building out-of-tree
@@ -2240,8 +2240,8 @@
 Replaces: linux-image-6.4.0-0-cloud-arm64
 Breaks: fwupdate (<< 12-7) [arm64], wireless-regdb (<< 2019.06.03-1~) [arm64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-cloud-arm64
-Description: Linux 6.4-rc7 for arm64 cloud
- The Linux kernel 6.4-rc7 and modules for use on cloud platforms supporting
+Description: Linux 6.4 for arm64 cloud
+ The Linux kernel 6.4 and modules for use on cloud platforms supporting
  arm64 virtual machines.
 
 Package: linux-image-6.4.0-0-cloud-arm64-dbg
@@ -2266,7 +2266,7 @@
 Package: linux-headers-6.4.0-0-rt-arm64
 Architecture: arm64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-rt-arm64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-rt-arm64, generally used for building out-of-tree
@@ -2284,8 +2284,8 @@
 Replaces: linux-image-6.4.0-0-rt-arm64
 Breaks: fwupdate (<< 12-7) [arm64], wireless-regdb (<< 2019.06.03-1~) [arm64], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-rt-arm64
-Description: Linux 6.4-rc7 for 64-bit ARMv8 machines, PREEMPT_RT
- The Linux kernel 6.4-rc7 and modules for use on 64-bit ARMv8 machines.
+Description: Linux 6.4 for 64-bit ARMv8 machines, PREEMPT_RT
+ The Linux kernel 6.4 and modules for use on 64-bit ARMv8 machines.
  .
  This kernel includes the PREEMPT_RT realtime patch set.
 
@@ -2797,7 +2797,7 @@
 Package: linux-headers-6.4.0-0-marvell
 Architecture: armel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-arm
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-marvell
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-marvell, generally used for building out-of-tree
@@ -2813,8 +2813,8 @@
 Recommends: firmware-linux-free, u-boot-tools [armel], apparmor [armel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [armel], wireless-regdb (<< 2019.06.03-1~) [armel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Marvell Kirkwood/Orion
- The Linux kernel 6.4-rc7 and modules for use on Marvell Kirkwood and Orion
+Description: Linux 6.4 for Marvell Kirkwood/Orion
+ The Linux kernel 6.4 and modules for use on Marvell Kirkwood and Orion
  based systems (https://wiki.debian.org/ArmEabiPort#Supported_hardware).
 
 Package: linux-image-marvell
@@ -2857,7 +2857,7 @@
 Package: linux-headers-6.4.0-0-rpi
 Architecture: armel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-arm
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-rpi
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-rpi, generally used for building out-of-tree kernel
@@ -2872,9 +2872,9 @@
 Recommends: firmware-linux-free, apparmor [armel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [armel], wireless-regdb (<< 2019.06.03-1~) [armel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Raspberry Pi Zero, Zero W and 1
- The Linux kernel 6.4-rc7 and modules for use on Raspberry Pi Zero, Zero W
- and 1 based systems.
+Description: Linux 6.4 for Raspberry Pi Zero, Zero W and 1
+ The Linux kernel 6.4 and modules for use on Raspberry Pi Zero, Zero W and
+ 1 based systems.
 
 Package: linux-image-rpi
 Architecture: armel
@@ -3439,7 +3439,7 @@
 Package: linux-headers-6.4.0-0-armmp
 Architecture: armhf
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-arm
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-armmp
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-armmp, generally used for building out-of-tree kernel
@@ -3455,10 +3455,10 @@
 Recommends: firmware-linux-free, apparmor [armhf]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [armhf], wireless-regdb (<< 2019.06.03-1~) [armhf], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for ARMv7 multiplatform compatible SoCs
- The Linux kernel 6.4-rc7 and modules for use on ARMv7 multiplatform
- kernel.  See https://wiki.debian.org/DebianKernel/ARMMP for details of
- supported platforms.
+Description: Linux 6.4 for ARMv7 multiplatform compatible SoCs
+ The Linux kernel 6.4 and modules for use on ARMv7 multiplatform kernel.
+ See https://wiki.debian.org/DebianKernel/ARMMP for details of supported
+ platforms.
 
 Package: linux-image-armmp
 Architecture: armhf
@@ -3502,7 +3502,7 @@
 Package: linux-headers-6.4.0-0-armmp-lpae
 Architecture: armhf
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-arm
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-armmp-lpae
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-armmp-lpae, generally used for building out-of-tree
@@ -3518,8 +3518,8 @@
 Recommends: firmware-linux-free, apparmor [armhf]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [armhf], wireless-regdb (<< 2019.06.03-1~) [armhf], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for ARMv7 multiplatform compatible SoCs supporting LPAE
- The Linux kernel 6.4-rc7 and modules for use on ARMv7 multiplatform kernel
+Description: Linux 6.4 for ARMv7 multiplatform compatible SoCs supporting LPAE
+ The Linux kernel 6.4 and modules for use on ARMv7 multiplatform kernel
  supporting LPAE. See https://wiki.debian.org/DebianKernel/ARMMP for
  details of supported platforms..
 
@@ -3564,7 +3564,7 @@
 Package: linux-headers-6.4.0-0-rt-armmp
 Architecture: armhf
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-arm
+Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-rt-armmp
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-rt-armmp, generally used for building out-of-tree
@@ -3580,10 +3580,10 @@
 Recommends: firmware-linux-free, apparmor [armhf]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [armhf], wireless-regdb (<< 2019.06.03-1~) [armhf], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for ARMv7 multiplatform compatible SoCs, PREEMPT_RT
- The Linux kernel 6.4-rc7 and modules for use on ARMv7 multiplatform
- kernel.  See https://wiki.debian.org/DebianKernel/ARMMP for details of
- supported platforms.
+Description: Linux 6.4 for ARMv7 multiplatform compatible SoCs, PREEMPT_RT
+ The Linux kernel 6.4 and modules for use on ARMv7 multiplatform kernel.
+ See https://wiki.debian.org/DebianKernel/ARMMP for details of supported
+ platforms.
  .
  This kernel includes the PREEMPT_RT realtime patch set.
 
@@ -4480,7 +4480,7 @@
 Package: linux-headers-6.4.0-0-parisc
 Architecture: hppa
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-parisc
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-parisc, generally used for building out-of-tree
@@ -4496,9 +4496,9 @@
 Recommends: firmware-linux-free, apparmor [hppa]
 Suggests: linux-doc-6.4, debian-kernel-handbook, palo [hppa]
 Breaks: fwupdate (<< 12-7) [hppa], wireless-regdb (<< 2019.06.03-1~) [hppa], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for 32-bit PA-RISC
- The Linux kernel 6.4-rc7 and modules for use on HP PA-RISC 32-bit systems
- with max 4 GB RAM.
+Description: Linux 6.4 for 32-bit PA-RISC
+ The Linux kernel 6.4 and modules for use on HP PA-RISC 32-bit systems with
+ max 4 GB RAM.
 
 Package: linux-image-parisc
 Architecture: hppa
@@ -4540,7 +4540,7 @@
 Package: linux-headers-6.4.0-0-parisc64
 Architecture: hppa
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12-hppa64-linux-gnu
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-parisc64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-parisc64, generally used for building out-of-tree
@@ -4556,9 +4556,9 @@
 Recommends: firmware-linux-free, apparmor [hppa]
 Suggests: linux-doc-6.4, debian-kernel-handbook, palo [hppa]
 Breaks: fwupdate (<< 12-7) [hppa], wireless-regdb (<< 2019.06.03-1~) [hppa], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for 64-bit PA-RISC
- The Linux kernel 6.4-rc7 and modules for use on HP PA-RISC 64-bit systems
- with support for more than 4 GB RAM.
+Description: Linux 6.4 for 64-bit PA-RISC
+ The Linux kernel 6.4 and modules for use on HP PA-RISC 64-bit systems with
+ support for more than 4 GB RAM.
 
 Package: linux-image-parisc64
 Architecture: hppa
@@ -5871,7 +5871,7 @@
 Package: linux-headers-6.4.0-0-686
 Architecture: i386
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-686
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-686, generally used for building out-of-tree kernel
@@ -5888,8 +5888,8 @@
 Replaces: linux-image-6.4.0-0-686
 Breaks: fwupdate (<< 12-7) [i386], wireless-regdb (<< 2019.06.03-1~) [i386], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-686
-Description: Linux 6.4-rc7 for older PCs
- The Linux kernel 6.4-rc7 and modules for use on PCs with one or more
+Description: Linux 6.4 for older PCs
+ The Linux kernel 6.4 and modules for use on PCs with one or more
  processors not supporting PAE.
 
 Package: linux-image-6.4.0-0-686-dbg
@@ -5914,7 +5914,7 @@
 Package: linux-headers-6.4.0-0-686-pae
 Architecture: i386
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-686-pae
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-686-pae, generally used for building out-of-tree
@@ -5932,8 +5932,8 @@
 Replaces: linux-image-6.4.0-0-686-pae
 Breaks: fwupdate (<< 12-7) [i386], wireless-regdb (<< 2019.06.03-1~) [i386], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-686-pae
-Description: Linux 6.4-rc7 for modern PCs
- The Linux kernel 6.4-rc7 and modules for use on PCs with one or more
+Description: Linux 6.4 for modern PCs
+ The Linux kernel 6.4 and modules for use on PCs with one or more
  processors supporting PAE.
  .
  This kernel requires PAE (Physical Address Extension). This feature is
@@ -5963,7 +5963,7 @@
 Package: linux-headers-6.4.0-0-rt-686-pae
 Architecture: i386
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-x86
+Depends: linux-headers-6.4.0-0-common-rt (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-rt-686-pae
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-rt-686-pae, generally used for building out-of-tree
@@ -5981,8 +5981,8 @@
 Replaces: linux-image-6.4.0-0-rt-686-pae
 Breaks: fwupdate (<< 12-7) [i386], wireless-regdb (<< 2019.06.03-1~) [i386], initramfs-tools (<< 0.120+deb8u2)
 Conflicts: linux-image-6.4.0-0-rt-686-pae
-Description: Linux 6.4-rc7 for modern PCs, PREEMPT_RT
- The Linux kernel 6.4-rc7 and modules for use on PCs with one or more
+Description: Linux 6.4 for modern PCs, PREEMPT_RT
+ The Linux kernel 6.4 and modules for use on PCs with one or more
  processors supporting PAE.
  .
  This kernel requires PAE (Physical Address Extension). This feature is
@@ -6524,7 +6524,7 @@
 Package: linux-headers-6.4.0-0-itanium
 Architecture: ia64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-itanium
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-itanium, generally used for building out-of-tree
@@ -6540,9 +6540,9 @@
 Recommends: firmware-linux-free, apparmor [ia64]
 Suggests: linux-doc-6.4, debian-kernel-handbook, grub-efi-ia64 [ia64]
 Breaks: fwupdate (<< 12-7) [ia64], wireless-regdb (<< 2019.06.03-1~) [ia64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Itanium (Merced)
- The Linux kernel 6.4-rc7 and modules for use on systems with original
- Itanium (Merced) processors.
+Description: Linux 6.4 for Itanium (Merced)
+ The Linux kernel 6.4 and modules for use on systems with original Itanium
+ (Merced) processors.
 
 Package: linux-image-itanium
 Architecture: ia64
@@ -6584,7 +6584,7 @@
 Package: linux-headers-6.4.0-0-mckinley
 Architecture: ia64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mckinley
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mckinley, generally used for building out-of-tree
@@ -6600,8 +6600,8 @@
 Recommends: firmware-linux-free, apparmor [ia64]
 Suggests: linux-doc-6.4, debian-kernel-handbook, grub-efi-ia64 [ia64]
 Breaks: fwupdate (<< 12-7) [ia64], wireless-regdb (<< 2019.06.03-1~) [ia64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Itanium 2+
- The Linux kernel 6.4-rc7 and modules for use on systems with Itanium 2 or
+Description: Linux 6.4 for Itanium 2+
+ The Linux kernel 6.4 and modules for use on systems with Itanium 2 or
  9300/9500/9700-series processors.
 
 Package: linux-image-mckinley
@@ -6640,6 +6640,540 @@
  This package depends on the detached debugging symbols for the latest
  Linux kernel mckinley configuration.
 
+Package: kernel-image-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: kernel-image, i2c-modules, rtc-modules
+Kernel-Version: 6.4.0-0-loong64
+Description: Linux kernel image and core modules for the Debian installer
+ This package contains the kernel image and core modules for the Debian
+ installer boot images.  It does _not_ provide a usable kernel for your
+ full Debian system.
+
+Package: nic-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: nic-modules, nic-extra-modules
+Depends: kernel-image-6.4.0-0-loong64-di, nic-shared-modules-6.4.0-0-loong64-di, i2c-modules-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: NIC drivers
+ This package contains Ethernet and some paravirtualised network drivers
+ for the kernel.
+
+Package: nic-wireless-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: nic-wireless-modules
+Depends: kernel-image-6.4.0-0-loong64-di, nic-shared-modules-6.4.0-0-loong64-di, usb-modules-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di, rfkill-modules-6.4.0-0-loong64-di, crypto-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Wireless NIC drivers
+ This package contains wireless NIC drivers for the kernel.  Includes
+ crypto modules only needed for wireless (WEP, WPA).
+
+Package: nic-shared-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: nic-shared-modules
+Depends: i2c-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Shared NIC drivers
+ This package contains NIC drivers needed by combinations of nic-modules,
+ nic-pcmcia-modules, nic-usb-modules and nic-wireless-modules.
+
+Package: usb-serial-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: usb-serial-modules
+Depends: kernel-image-6.4.0-0-loong64-di, usb-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: USB serial drivers
+ This package contains USB serial drivers for the kernel.
+
+Package: ppp-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: ppp-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: PPP drivers
+ This package contains PPP drivers for the kernel.
+
+Package: pata-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: pata-modules
+Depends: kernel-image-6.4.0-0-loong64-di, ata-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: PATA drivers
+ This package contains PATA drivers for the kernel.
+
+Package: cdrom-core-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: cdrom-core-modules
+Depends: kernel-image-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: CDROM support
+ This package contains core CDROM support for the kernel.
+
+Package: scsi-core-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: scsi-core-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Core SCSI subsystem
+ This package contains the core SCSI subsystem for the kernel.
+
+Package: scsi-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: scsi-modules
+Depends: kernel-image-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di, cdrom-core-modules-6.4.0-0-loong64-di, ata-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: SCSI drivers
+ This package contains SCSI drivers for the kernel.
+
+Package: scsi-nic-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: scsi-nic-modules
+Depends: scsi-modules-6.4.0-0-loong64-di, nic-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: SCSI drivers for converged NICs
+ This package contains SCSI drivers that depend on net drivers.
+
+Package: loop-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: loop-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Loopback filesystem support
+ This package contains loopback filesystem support for the kernel.
+
+Package: btrfs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: btrfs-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di, md-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: BTRFS filesystem support
+ This package contains the BTRFS filesystem module for the kernel.
+
+Package: ext4-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: ext4-modules, ext2-modules, ext3-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: ext2/ext3/ext4 filesystem support
+ This package contains the ext4 filesystem module for the kernel, which
+ also supports ext2 and ext3.
+
+Package: isofs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: isofs-modules
+Depends: kernel-image-6.4.0-0-loong64-di, cdrom-core-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: ISOFS filesystem support
+ This package contains the ISOFS filesystem module for the kernel.
+
+Package: jfs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: jfs-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: JFS filesystem support
+ This package contains the JFS filesystem module for the kernel.
+
+Package: xfs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: xfs-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: XFS filesystem support
+ This package contains the XFS filesystem module for the kernel.
+
+Package: fat-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: fat-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: FAT filesystem support
+ This package contains the FAT and VFAT filesystem modules for the kernel.
+
+Package: squashfs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: squashfs-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: squashfs modules
+ This package contains squashfs modules.
+
+Package: udf-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: udf-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di, cdrom-core-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: UDF modules
+ This package contains the UDF filesystem module.
+
+Package: fuse-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: fuse-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: FUSE modules
+ This package contains the Filesystem in Userspace (FUSE) module.
+
+Package: f2fs-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: f2fs-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: f2fs filesystem support
+ This package contains the f2fs (Flash-Friendly Filesystem) module.
+
+Package: md-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: md-modules
+Depends: kernel-image-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: RAID and LVM support
+ This package contains RAID and LVM modules for the kernel.
+
+Package: multipath-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: multipath-modules
+Depends: kernel-image-6.4.0-0-loong64-di, md-modules-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Multipath support
+ This package contains DM-Multipath modules for the kernel.
+
+Package: usb-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: usb-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: USB support
+ This package contains core USB drivers for the kernel.
+
+Package: usb-storage-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: usb-storage-modules
+Depends: kernel-image-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di, usb-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: USB storage support
+ This package contains the USB storage driver for the kernel.
+
+Package: fb-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: fb-modules
+Depends: kernel-image-6.4.0-0-loong64-di, i2c-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Frame buffer support
+ This package contains Frame buffer drivers for the kernel.
+
+Package: input-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: input-modules
+Depends: kernel-image-6.4.0-0-loong64-di, usb-modules-6.4.0-0-loong64-di, i2c-modules-6.4.0-0-loong64-di, rfkill-modules-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Input devices support
+ This package contains input device drivers for the kernel.
+
+Package: event-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: event-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Event support
+ This package contains event drivers for the kernel.
+
+Package: nic-usb-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: nic-usb-modules
+Depends: kernel-image-6.4.0-0-loong64-di, nic-shared-modules-6.4.0-0-loong64-di, nic-wireless-modules-6.4.0-0-loong64-di, usb-modules-6.4.0-0-loong64-di, crc-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: USB NIC drivers
+ This package contains USB network adapter drivers for the kernel.
+
+Package: sata-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: standard
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: sata-modules
+Depends: kernel-image-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di, ata-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: SATA drivers
+ This package contains SATA drivers for the kernel.
+
+Package: i2c-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: i2c-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: i2c support modules
+ This package contains basic i2c support modules.
+
+Package: crc-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: crc-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: CRC modules
+ This package contains CRC support modules.
+
+Package: crypto-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: crypto-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: crypto modules
+ This package contains crypto modules.
+
+Package: crypto-dm-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: crypto-dm-modules
+Depends: kernel-image-6.4.0-0-loong64-di, md-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: devicemapper crypto module
+ This package contains the devicemapper crypto (dm-crypt) module.
+
+Package: efi-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: efi-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: EFI modules
+ This package contains EFI modules.
+
+Package: ata-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: ata-modules
+Depends: kernel-image-6.4.0-0-loong64-di, scsi-core-modules-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: ATA disk modules
+ This package contains core ATA disk modules used by both PATA and SATA
+ disk drivers.
+
+Package: nbd-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: nbd-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: Network Block Device modules
+ This package contains the modules required for support of the Network
+ Block Device
+
+Package: rfkill-modules-6.4.0-0-loong64-di
+Package-Type: udeb
+Architecture: loong64
+Section: debian-installer
+Priority: optional
+Build-Profiles: <!noudeb !pkg.linux.nokernel !pkg.linux.quick !stage1>
+Provides: rfkill-modules
+Depends: kernel-image-6.4.0-0-loong64-di
+Kernel-Version: 6.4.0-0-loong64
+Description: rfkill modules
+ This package contains the rfkill module.
+
+Package: linux-headers-6.4.0-0-loong64
+Architecture: loong64
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
+Description: Header files for Linux 6.4.0-0-loong64
+ This package provides the architecture-specific kernel header files for
+ Linux kernel 6.4.0-0-loong64, generally used for building out-of-tree
+ kernel modules.  These files are going to be installed into
+ /usr/src/linux-headers-6.4.0-0-loong64, and can be used for building
+ modules that load into the kernel provided by the
+ linux-image-6.4.0-0-loong64 package.
+
+Package: linux-image-6.4.0-0-loong64
+Architecture: loong64
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
+Depends: kmod, linux-base (>= 4.3~), linux-bootwrapper-6.4.0-0 [powerpc ppc64], ${misc:Depends}, initramfs-tools (>= 0.120+deb8u2) [loong64] | linux-initramfs-tool [loong64]
+Recommends: firmware-linux-free, apparmor [loong64]
+Suggests: linux-doc-6.4, debian-kernel-handbook
+Breaks: fwupdate (<< 12-7) [loong64], wireless-regdb (<< 2019.06.03-1~) [loong64], initramfs-tools (<< 0.120+deb8u2)
+Description: Linux 6.4 for 64-bit LoongArch platforms
+ The Linux kernel 6.4 and modules for use on 64-bit LoongArch platforms.
+
+Package: linux-image-loong64
+Architecture: loong64
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.nometa !pkg.linux.quick !stage1>
+Provides: linux-latest-modules-6.4.0-0-loong64, wireguard-modules (= 1.0.0), virtualbox-guest-modules [amd64 i386], linux-image-generic
+Depends: linux-image-6.4.0-0-loong64 (= ${binary:Version}), ${misc:Depends}
+Description: Linux for 64-bit LoongArch platforms (meta-package)
+ This package depends on the latest Linux kernel and modules for use on
+ 64-bit LoongArch platforms.
+
+Package: linux-headers-loong64
+Architecture: loong64
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.nometa !pkg.linux.quick !stage1>
+Provides: linux-headers-generic
+Depends: linux-headers-6.4.0-0-loong64 (= ${binary:Version}), ${misc:Depends}
+Description: Header files for Linux loong64 configuration (meta-package)
+ This package depends on the architecture-specific header files for the
+ latest Linux kernel loong64 configuration.
+
+Package: linux-image-6.4.0-0-loong64-dbg
+Architecture: loong64
+Section: debug
+Priority: optional
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.nokerneldbg !pkg.linux.quick !stage1>
+Depends: ${misc:Depends}
+Description: Debug symbols for linux-image-6.4.0-0-loong64
+ This package provides the detached debug symbols for the Linux kernel and
+ modules in linux-image-6.4.0-0-loong64.
+
+Package: linux-image-loong64-dbg
+Architecture: loong64
+Build-Profiles: <!pkg.linux.nokernel !pkg.linux.nokerneldbg !pkg.linux.nometa !pkg.linux.quick !stage1>
+Provides: linux-latest-image-dbg
+Depends: linux-image-6.4.0-0-loong64-dbg (= ${binary:Version}), ${misc:Depends}
+Description: Debugging symbols for Linux loong64 configuration (meta-package)
+ This package depends on the detached debugging symbols for the latest
+ Linux kernel loong64 configuration.
+
 Package: kernel-image-6.4.0-0-m68k-di
 Package-Type: udeb
 Architecture: m68k
@@ -6925,7 +7459,7 @@
 Package: linux-headers-6.4.0-0-m68k
 Architecture: m68k
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-m68k
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-m68k, generally used for building out-of-tree kernel
@@ -6941,8 +7475,8 @@
 Recommends: firmware-linux-free, apparmor [m68k]
 Suggests: linux-doc-6.4, debian-kernel-handbook, vmelilo [m68k], fdutils [m68k]
 Breaks: fwupdate (<< 12-7) [m68k], wireless-regdb (<< 2019.06.03-1~) [m68k], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Motorola MC68020+ family
- The Linux kernel 6.4-rc7 and modules for use on Motorola MC68020+ family.
+Description: Linux 6.4 for Motorola MC68020+ family
+ The Linux kernel 6.4 and modules for use on Motorola MC68020+ family.
 
 Package: linux-image-m68k
 Architecture: m68k
@@ -8628,7 +9162,7 @@
 Package: linux-headers-6.4.0-0-4kc-malta
 Architecture: mips mipsel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-4kc-malta
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-4kc-malta, generally used for building out-of-tree
@@ -8644,8 +9178,8 @@
 Recommends: firmware-linux-free, apparmor [mips mipsel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips mipsel], wireless-regdb (<< 2019.06.03-1~) [mips mipsel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Malta
- The Linux kernel 6.4-rc7 and modules for use on MIPS Malta boards.
+Description: Linux 6.4 for MIPS Malta
+ The Linux kernel 6.4 and modules for use on MIPS Malta boards.
 
 Package: linux-image-4kc-malta
 Architecture: mips mipsel
@@ -8686,7 +9220,7 @@
 Package: linux-headers-6.4.0-0-mips32r2eb
 Architecture: mips
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips32r2eb
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips32r2eb, generally used for building out-of-tree
@@ -8702,8 +9236,8 @@
 Recommends: firmware-linux-free, apparmor [mips]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips], wireless-regdb (<< 2019.06.03-1~) [mips], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips32r2eb)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips32r2eb)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips32r2eb).
 
 Package: linux-image-mips32r2eb
@@ -8745,7 +9279,7 @@
 Package: linux-headers-6.4.0-0-octeon
 Architecture: mips mips64 mips64el mipsel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-octeon
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-octeon, generally used for building out-of-tree
@@ -8761,8 +9295,8 @@
 Recommends: firmware-linux-free, apparmor [mips mips64 mips64el mipsel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips mips64 mips64el mipsel], wireless-regdb (<< 2019.06.03-1~) [mips mips64 mips64el mipsel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Octeon
- The Linux kernel 6.4-rc7 and modules for use on Cavium Networks Octeon.
+Description: Linux 6.4 for Octeon
+ The Linux kernel 6.4 and modules for use on Cavium Networks Octeon.
 
 Package: linux-image-octeon
 Architecture: mips mips64 mips64el mipsel
@@ -9899,7 +10433,7 @@
 Package: linux-headers-6.4.0-0-5kc-malta
 Architecture: mips64 mips64el
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-5kc-malta
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-5kc-malta, generally used for building out-of-tree
@@ -9915,8 +10449,8 @@
 Recommends: firmware-linux-free, apparmor [mips64 mips64el]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64 mips64el], wireless-regdb (<< 2019.06.03-1~) [mips64 mips64el], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Malta
- The Linux kernel 6.4-rc7 and modules for use on MIPS Malta boards.
+Description: Linux 6.4 for MIPS Malta
+ The Linux kernel 6.4 and modules for use on MIPS Malta boards.
 
 Package: linux-image-5kc-malta
 Architecture: mips64 mips64el
@@ -9957,7 +10491,7 @@
 Package: linux-headers-6.4.0-0-mips64r2eb
 Architecture: mips64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips64r2eb
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips64r2eb, generally used for building out-of-tree
@@ -9973,8 +10507,8 @@
 Recommends: firmware-linux-free, apparmor [mips64]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64], wireless-regdb (<< 2019.06.03-1~) [mips64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips64r2eb)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips64r2eb)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips64r2eb).
 
 Package: linux-image-mips64r2eb
@@ -11112,7 +11646,7 @@
 Package: linux-headers-6.4.0-0-mips64r2el
 Architecture: mips64el
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips64r2el
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips64r2el, generally used for building out-of-tree
@@ -11128,8 +11662,8 @@
 Recommends: firmware-linux-free, apparmor [mips64el]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64el], wireless-regdb (<< 2019.06.03-1~) [mips64el], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips64r2el)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips64r2el)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips64r2el).
 
 Package: linux-image-mips64r2el
@@ -11171,7 +11705,7 @@
 Package: linux-headers-6.4.0-0-loongson-3
 Architecture: mips64el mipsel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-loongson-3
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-loongson-3, generally used for building out-of-tree
@@ -11187,8 +11721,8 @@
 Recommends: firmware-linux-free, pmon-update [mips64el mipsel], apparmor [mips64el mipsel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64el mipsel], wireless-regdb (<< 2019.06.03-1~) [mips64el mipsel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Loongson 3A/3B
- The Linux kernel 6.4-rc7 and modules for use on Loongson 3A or 3B based
+Description: Linux 6.4 for Loongson 3A/3B
+ The Linux kernel 6.4 and modules for use on Loongson 3A or 3B based
  systems (e.g.  from Loongson or Lemote).
 
 Package: linux-image-loongson-3
@@ -11778,7 +12312,7 @@
 Package: linux-headers-6.4.0-0-mips64r6eb
 Architecture: mips64r6
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips64r6eb
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips64r6eb, generally used for building out-of-tree
@@ -11794,8 +12328,8 @@
 Recommends: firmware-linux-free, apparmor [mips64r6]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64r6], wireless-regdb (<< 2019.06.03-1~) [mips64r6], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips64r6eb)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips64r6eb)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips64r6eb).
 
 Package: linux-image-mips64r6eb
@@ -12385,7 +12919,7 @@
 Package: linux-headers-6.4.0-0-mips64r6el
 Architecture: mips64r6el
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips64r6el
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips64r6el, generally used for building out-of-tree
@@ -12401,8 +12935,8 @@
 Recommends: firmware-linux-free, apparmor [mips64r6el]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mips64r6el], wireless-regdb (<< 2019.06.03-1~) [mips64r6el], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips64r6el)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips64r6el)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips64r6el).
 
 Package: linux-image-mips64r6el
@@ -12992,7 +13526,7 @@
 Package: linux-headers-6.4.0-0-mips32r2el
 Architecture: mipsel
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips32r2el
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips32r2el, generally used for building out-of-tree
@@ -13008,8 +13542,8 @@
 Recommends: firmware-linux-free, apparmor [mipsel]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mipsel], wireless-regdb (<< 2019.06.03-1~) [mipsel], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips32r2el)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips32r2el)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips32r2el).
 
 Package: linux-image-mips32r2el
@@ -13599,7 +14133,7 @@
 Package: linux-headers-6.4.0-0-mips32r6eb
 Architecture: mipsr6
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips32r6eb
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips32r6eb, generally used for building out-of-tree
@@ -13615,8 +14149,8 @@
 Recommends: firmware-linux-free, apparmor [mipsr6]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mipsr6], wireless-regdb (<< 2019.06.03-1~) [mipsr6], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips32r6eb)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips32r6eb)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips32r6eb).
 
 Package: linux-image-mips32r6eb
@@ -14206,7 +14740,7 @@
 Package: linux-headers-6.4.0-0-mips32r6el
 Architecture: mipsr6el
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-mips32r6el
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-mips32r6el, generally used for building out-of-tree
@@ -14222,8 +14756,8 @@
 Recommends: firmware-linux-free, apparmor [mipsr6el]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [mipsr6el], wireless-regdb (<< 2019.06.03-1~) [mipsr6el], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for MIPS Generic (mips32r6el)
- The Linux kernel 6.4-rc7 and modules for use on MIPS Generic platform
+Description: Linux 6.4 for MIPS Generic (mips32r6el)
+ The Linux kernel 6.4 and modules for use on MIPS Generic platform
  (mips32r6el).
 
 Package: linux-image-mips32r6el
@@ -15434,7 +15968,7 @@
 Package: linux-headers-6.4.0-0-powerpc
 Architecture: powerpc
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-powerpc
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-powerpc, generally used for building out-of-tree
@@ -15450,9 +15984,8 @@
 Recommends: firmware-linux-free, apparmor [powerpc]
 Suggests: linux-doc-6.4, debian-kernel-handbook, mkvmlinuz [powerpc], grub-ieee1275 [powerpc]
 Breaks: fwupdate (<< 12-7) [powerpc], wireless-regdb (<< 2019.06.03-1~) [powerpc], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for uniprocessor 32-bit PowerPC
- The Linux kernel 6.4-rc7 and modules for use on uniprocessor 32-bit
- PowerPC.
+Description: Linux 6.4 for uniprocessor 32-bit PowerPC
+ The Linux kernel 6.4 and modules for use on uniprocessor 32-bit PowerPC.
 
 Package: linux-image-powerpc
 Architecture: powerpc
@@ -15493,7 +16026,7 @@
 Package: linux-headers-6.4.0-0-powerpc-smp
 Architecture: powerpc
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-powerpc-smp
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-powerpc-smp, generally used for building out-of-tree
@@ -15509,9 +16042,8 @@
 Recommends: firmware-linux-free, apparmor [powerpc]
 Suggests: linux-doc-6.4, debian-kernel-handbook, mkvmlinuz [powerpc], grub-ieee1275 [powerpc]
 Breaks: fwupdate (<< 12-7) [powerpc], wireless-regdb (<< 2019.06.03-1~) [powerpc], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for multiprocessor 32-bit PowerPC
- The Linux kernel 6.4-rc7 and modules for use on multiprocessor 32-bit
- PowerPC.
+Description: Linux 6.4 for multiprocessor 32-bit PowerPC
+ The Linux kernel 6.4 and modules for use on multiprocessor 32-bit PowerPC.
 
 Package: linux-image-powerpc-smp
 Architecture: powerpc
@@ -15552,7 +16084,7 @@
 Package: linux-headers-6.4.0-0-powerpc64
 Architecture: powerpc ppc64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-powerpc64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-powerpc64, generally used for building out-of-tree
@@ -15568,8 +16100,8 @@
 Recommends: firmware-linux-free, apparmor [powerpc ppc64]
 Suggests: linux-doc-6.4, debian-kernel-handbook, mkvmlinuz [powerpc ppc64], grub-ieee1275 [powerpc ppc64]
 Breaks: fwupdate (<< 12-7) [powerpc ppc64], wireless-regdb (<< 2019.06.03-1~) [powerpc ppc64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for 64-bit PowerPC
- The Linux kernel 6.4-rc7 and modules for use on 64-bit PowerPC.
+Description: Linux 6.4 for 64-bit PowerPC
+ The Linux kernel 6.4 and modules for use on 64-bit PowerPC.
 
 Package: linux-image-powerpc64
 Architecture: powerpc ppc64
@@ -16137,7 +16669,7 @@
 Package: linux-headers-6.4.0-0-powerpc64le
 Architecture: ppc64el
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-powerpc64le
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-powerpc64le, generally used for building out-of-tree
@@ -16153,9 +16685,8 @@
 Recommends: firmware-linux-free, apparmor [ppc64el]
 Suggests: linux-doc-6.4, debian-kernel-handbook, mkvmlinuz [ppc64el], grub-ieee1275 [ppc64el]
 Breaks: fwupdate (<< 12-7) [ppc64el], wireless-regdb (<< 2019.06.03-1~) [ppc64el], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for Little-endian 64-bit PowerPC
- The Linux kernel 6.4-rc7 and modules for use on Little-endian 64-bit
- PowerPC.
+Description: Linux 6.4 for Little-endian 64-bit PowerPC
+ The Linux kernel 6.4 and modules for use on Little-endian 64-bit PowerPC.
 
 Package: linux-image-powerpc64le
 Architecture: ppc64el
@@ -16685,7 +17216,7 @@
 Package: linux-headers-6.4.0-0-riscv64
 Architecture: riscv64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-riscv64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-riscv64, generally used for building out-of-tree
@@ -16701,8 +17232,8 @@
 Recommends: firmware-linux-free, apparmor [riscv64]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [riscv64], wireless-regdb (<< 2019.06.03-1~) [riscv64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for 64-bit RISC-V platforms
- The Linux kernel 6.4-rc7 and modules for use on 64-bit RISC-V platforms.
+Description: Linux 6.4 for 64-bit RISC-V platforms
+ The Linux kernel 6.4 and modules for use on 64-bit RISC-V platforms.
 
 Package: linux-image-riscv64
 Architecture: riscv64
@@ -17026,7 +17557,7 @@
 Package: linux-headers-6.4.0-0-s390x
 Architecture: s390x
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, linux-compiler-gcc-12-s390
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-s390x
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-s390x, generally used for building out-of-tree kernel
@@ -17042,8 +17573,8 @@
 Recommends: firmware-linux-free, apparmor [s390x]
 Suggests: linux-doc-6.4, debian-kernel-handbook, s390-tools [s390x]
 Breaks: fwupdate (<< 12-7) [s390x], wireless-regdb (<< 2019.06.03-1~) [s390x], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for IBM zSeries
- The Linux kernel 6.4-rc7 and modules for use on IBM zSeries.
+Description: Linux 6.4 for IBM zSeries
+ The Linux kernel 6.4 and modules for use on IBM zSeries.
 
 Package: linux-image-s390x
 Architecture: s390x
@@ -17876,7 +18407,7 @@
 Package: linux-headers-6.4.0-0-sh7751r
 Architecture: sh4
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-sh7751r
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-sh7751r, generally used for building out-of-tree
@@ -17892,8 +18423,8 @@
 Recommends: firmware-linux-free, apparmor [sh4]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [sh4], wireless-regdb (<< 2019.06.03-1~) [sh4], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for sh7751r
- The Linux kernel 6.4-rc7 and modules for use on Renesas SH7751R R2D plus
+Description: Linux 6.4 for sh7751r
+ The Linux kernel 6.4 and modules for use on Renesas SH7751R R2D plus
  board.
 
 Package: linux-image-sh7751r
@@ -17935,7 +18466,7 @@
 Package: linux-headers-6.4.0-0-sh7785lcr
 Architecture: sh4
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-sh7785lcr
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-sh7785lcr, generally used for building out-of-tree
@@ -17951,8 +18482,8 @@
 Recommends: firmware-linux-free, u-boot-tools [sh4], apparmor [sh4]
 Suggests: linux-doc-6.4, debian-kernel-handbook
 Breaks: fwupdate (<< 12-7) [sh4], wireless-regdb (<< 2019.06.03-1~) [sh4], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for sh7785lcr
- The Linux kernel 6.4-rc7 and modules for use on Renesas SH7785 reference
+Description: Linux 6.4 for sh7785lcr
+ The Linux kernel 6.4 and modules for use on Renesas SH7785 reference
  board.
 
 Package: linux-image-sh7785lcr
@@ -18408,7 +18939,7 @@
 Package: linux-headers-6.4.0-0-sparc64
 Architecture: sparc64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-sparc64
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-sparc64, generally used for building out-of-tree
@@ -18424,8 +18955,8 @@
 Recommends: firmware-linux-free, apparmor [sparc64]
 Suggests: linux-doc-6.4, debian-kernel-handbook, fdutils [sparc64], grub-ieee1275 [sparc64]
 Breaks: fwupdate (<< 12-7) [sparc64], wireless-regdb (<< 2019.06.03-1~) [sparc64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for uniprocessor 64-bit UltraSPARC
- The Linux kernel 6.4-rc7 and modules for use on uniprocessor 64-bit
+Description: Linux 6.4 for uniprocessor 64-bit UltraSPARC
+ The Linux kernel 6.4 and modules for use on uniprocessor 64-bit
  UltraSPARC.
 
 Package: linux-image-sparc64
@@ -18467,7 +18998,7 @@
 Package: linux-headers-6.4.0-0-sparc64-smp
 Architecture: sparc64
 Build-Profiles: <!pkg.linux.nokernel !pkg.linux.quick !stage1>
-Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-12
+Depends: linux-headers-6.4.0-0-common (= ${source:Version}), linux-kbuild-6.4 (>= ${source:Version}), ${misc:Depends}, gcc-13
 Description: Header files for Linux 6.4.0-0-sparc64-smp
  This package provides the architecture-specific kernel header files for
  Linux kernel 6.4.0-0-sparc64-smp, generally used for building out-of-tree
@@ -18483,8 +19014,8 @@
 Recommends: firmware-linux-free, apparmor [sparc64]
 Suggests: linux-doc-6.4, debian-kernel-handbook, fdutils [sparc64], grub-ieee1275 [sparc64]
 Breaks: fwupdate (<< 12-7) [sparc64], wireless-regdb (<< 2019.06.03-1~) [sparc64], initramfs-tools (<< 0.120+deb8u2)
-Description: Linux 6.4-rc7 for multiprocessor 64-bit UltraSPARC
- The Linux kernel 6.4-rc7 and modules for use on multiprocessor 64-bit
+Description: Linux 6.4 for multiprocessor 64-bit UltraSPARC
+ The Linux kernel 6.4 and modules for use on multiprocessor 64-bit
  UltraSPARC.
 
 Package: linux-image-sparc64-smp
diff -uNr a/debian/control.md5sum b/debian/control.md5sum
--- a/debian/control.md5sum	2023-06-19 23:30:46.000000000 +0800
+++ b/debian/control.md5sum	2023-06-29 16:16:11.096257035 +0800
@@ -1,5 +1,5 @@
 1a70da4e4940ebb987ca7797a55d5155  debian/bin/gencontrol.py
-6ad5dd3f4a33d3d0647eefb3eb78d4f8  debian/build/version-info
+da0abe7b13daa6a0a0fd82eac9f21f77  debian/build/version-info
 0a54c676b0235b7d0de9e944be0ccfe8  debian/templates/config.control.in
 08657c44620ad346d701df4f328b53d6  debian/templates/docs.control.in
 8047c973c6b13df1888490e43d88ec90  debian/templates/docs.meta.control.in
@@ -11,16 +11,11 @@
 39dddaa9ca4735ad2ddaf682ecf0b566  debian/templates/headers.meta.maintscript.in
 0d7f6ea42f52d0a6013535a80111ee3e  debian/templates/headers.postinst.in
 33604124ac9c80d9abd4e00bb7b971a7  debian/templates/headers.tests-control.in
+f182a874e272d9091e8e6cbac19c5f05  debian/templates/image.control.in
 06f30e511908d191c14d753d2b81770a  debian/templates/image-dbg.control.in
 17605e6f4c001376ac81b82fa103c543  debian/templates/image-dbg.meta.control.in
 eebbd0d671c21eba0a79f6d1226c0bc7  debian/templates/image-dbg.meta.lintian-overrides.in
 ecec9b1808743ce6dd807a7bbdb293d1  debian/templates/image-dbg.meta.maintscript.in
-7234d518ae52d055cf8dd16fc704f9ee  debian/templates/image-unsigned.control.in
-0327750d6696dee915a532aec73a0fd6  debian/templates/image-unsigned.postinst.in
-a4a60fc48b3240e46bbac6a1ddcaad30  debian/templates/image-unsigned.postrm.in
-38004750aa03cea41d5d3aeafff16fcc  debian/templates/image-unsigned.preinst.in
-afb508873a44a1f196c2a525fec4b415  debian/templates/image-unsigned.prerm.in
-f182a874e272d9091e8e6cbac19c5f05  debian/templates/image.control.in
 769a43efb579711359e12554e34d0baa  debian/templates/image.meta.bug-presubj.in
 fffbde08db5e8f7be139d6d8ff082cf0  debian/templates/image.meta.control.in
 15e98dd33b3bb098bf9f25114c8371c2  debian/templates/image.meta.maintscript.in
@@ -29,17 +24,22 @@
 38004750aa03cea41d5d3aeafff16fcc  debian/templates/image.preinst.in
 afb508873a44a1f196c2a525fec4b415  debian/templates/image.prerm.in
 814dda166c7e3ef02e6e259e805ac66a  debian/templates/image.tests-control.in
+7234d518ae52d055cf8dd16fc704f9ee  debian/templates/image-unsigned.control.in
+0327750d6696dee915a532aec73a0fd6  debian/templates/image-unsigned.postinst.in
+a4a60fc48b3240e46bbac6a1ddcaad30  debian/templates/image-unsigned.postrm.in
+38004750aa03cea41d5d3aeafff16fcc  debian/templates/image-unsigned.preinst.in
+afb508873a44a1f196c2a525fec4b415  debian/templates/image-unsigned.prerm.in
 90a739549328b13c7066a24196f00f79  debian/templates/libc-dev.control.in
 3375b25cc7497bbb5f220897c486f2b8  debian/templates/main.control.in
 4eea8205f796914aae590b032acd2f38  debian/templates/main.tests-control.in
 f46c86652b15715bad54f0f25a921c1f  debian/templates/signed-template.control.in
-7d8c4a744e59811e8345277f2821a63b  debian/templates/source.control.in
 50faed0c8886ba53092eb060aa9e614a  debian/templates/sourcebin.control.in
 bdb7e8060e7b1168d7ea5d1d745a5aa9  debian/templates/sourcebin.meta.control.in
 a20d83421667bad21739041d4e743ed1  debian/templates/sourcebin.meta.maintscript.in
+7d8c4a744e59811e8345277f2821a63b  debian/templates/source.control.in
 8210dfdc6f743735d62e0dd059a07e99  debian/templates/tools-unversioned.control.in
 568f629072d584e9a0eb1dc9d3a94749  debian/templates/tools-versioned.control.in
-aff4d4e5b07cbd8df87473c2b28455a4  debian/config/defines
+74359b055d67a3d9a3ece36d8ddb019f  debian/config/defines
 59a811890d2e7129bec940075850f11f  debian/config/alpha/defines
 60569b1b4c618e2fe7b135f687d0f0d2  debian/config/amd64/defines
 ae8ff5f78a080acf23ac69f484de8614  debian/config/arm64/defines
@@ -50,12 +50,13 @@
 2385a5440b2c637fa785111aa9b06f92  debian/config/hppa/defines
 ea2f1ad5b530823d8d8735077665a3e3  debian/config/i386/defines
 97647ba6bbcc9331b17fef5c192e5a35  debian/config/ia64/defines
+d71ff0f9acf232fc48a31656f7c4dd17  debian/config/loong64/defines
 f6eb4abf894006ec7f947d09d32f57b2  debian/config/m68k/defines
-59e251ad57f6996e725ca053d9ab41ae  debian/config/mips/defines
 4c67f34497995d10972a7a6b02bfce96  debian/config/mips64/defines
 6f477bac29bdfe373ee2561a37ad6bcd  debian/config/mips64el/defines
 e887306f112b3efd933c0be828f260f0  debian/config/mips64r6/defines
 efcd8555042e96fb881fad9a2def7c29  debian/config/mips64r6el/defines
+59e251ad57f6996e725ca053d9ab41ae  debian/config/mips/defines
 c0524173331dd200c03c8700f866d520  debian/config/mipsel/defines
 e411d2dfe0018a7c40b6bf7efd45cd29  debian/config/mipsn32/defines
 174058e52aced932bf02606d6cb5649c  debian/config/mipsn32el/defines
@@ -71,8 +72,8 @@
 fdd0b1654b5487e9a6dbcce9b3767727  debian/config/s390x/defines
 8f2e4969633ff660d026f2b7e02e6336  debian/config/sh3/defines
 e0810ddd6e4add2a26c5668773b69d25  debian/config/sh4/defines
-8d317c1872f3bd8da4feae25a7c61df3  debian/config/sparc/defines
 e741332318227dd4646f0d98735271e5  debian/config/sparc64/defines
+8d317c1872f3bd8da4feae25a7c61df3  debian/config/sparc/defines
 f4b2921156e7b1a038862f848fdfe48f  debian/config/x32/defines
 048118811dd90dd1d597be204f819c1f  debian/config/amd64/none/defines
 7dc981827930ed6844a731ed954b9b9d  debian/config/amd64/rt/defines
@@ -82,6 +83,7 @@
 1cab87ca080defc647d4ae9adcf9a63a  debian/config/armhf/rt/defines
 61cbd68a5172174b0c8261b27ba5cf12  debian/config/i386/none/defines
 7146ff53fc4f9fbb49948225d8589b69  debian/config/i386/rt/defines
+b568ded74cee77a30885759495954546  debian/config/loong64/none/defines
 1f2f888a9e94dfb519bb1eab12408d34  debian/config/riscv64/none/defines
-9ee7d439378fec0a34c2930f3e6478c5  debian/installer/kernel-versions
-6acfd12bf0bbb112a7138da93736e655  debian/installer/package-list
+28b7690551c8d85ad8e1de3a44dc7929  debian/installer/kernel-versions
+5df28d9f5fbe9104ab22e21a78537b81  debian/installer/package-list
diff -uNr a/debian/installer/kernel-versions b/debian/installer/kernel-versions
--- a/debian/installer/kernel-versions	2023-05-13 01:01:18.000000000 +0800
+++ b/debian/installer/kernel-versions	2023-06-29 16:16:11.268252950 +0800
@@ -9,6 +9,7 @@
 i386       -       686           -             -      -
 i386       -       686-pae       -             -      -
 ia64       -       itanium       -             -      -
+loong64    -       loong64       -             -      -
 m68k       -       m68k          -             y      -
 mips       -       4kc-malta     -             y      -
 mips       -       mips32r2eb    -             y      -
diff -uNr a/debian/installer/modules/loong64/ata-modules b/debian/installer/modules/loong64/ata-modules
--- a/debian/installer/modules/loong64/ata-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/ata-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1,2 @@
+#include <ata-modules>
+
diff -uNr a/debian/installer/modules/loong64/btrfs-modules b/debian/installer/modules/loong64/btrfs-modules
--- a/debian/installer/modules/loong64/btrfs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/btrfs-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <btrfs-modules>
diff -uNr a/debian/installer/modules/loong64/cdrom-core-modules b/debian/installer/modules/loong64/cdrom-core-modules
--- a/debian/installer/modules/loong64/cdrom-core-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/cdrom-core-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <cdrom-core-modules>
diff -uNr a/debian/installer/modules/loong64/crc-modules b/debian/installer/modules/loong64/crc-modules
--- a/debian/installer/modules/loong64/crc-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/crc-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <crc-modules>
diff -uNr a/debian/installer/modules/loong64/crypto-dm-modules b/debian/installer/modules/loong64/crypto-dm-modules
--- a/debian/installer/modules/loong64/crypto-dm-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/crypto-dm-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <crypto-dm-modules>
diff -uNr a/debian/installer/modules/loong64/crypto-modules b/debian/installer/modules/loong64/crypto-modules
--- a/debian/installer/modules/loong64/crypto-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/crypto-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <crypto-modules>
diff -uNr a/debian/installer/modules/loong64/efi-modules b/debian/installer/modules/loong64/efi-modules
--- a/debian/installer/modules/loong64/efi-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/efi-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <efi-modules>
diff -uNr a/debian/installer/modules/loong64/event-modules b/debian/installer/modules/loong64/event-modules
--- a/debian/installer/modules/loong64/event-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/event-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <event-modules>
diff -uNr a/debian/installer/modules/loong64/ext4-modules b/debian/installer/modules/loong64/ext4-modules
--- a/debian/installer/modules/loong64/ext4-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/ext4-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <ext4-modules>
diff -uNr a/debian/installer/modules/loong64/f2fs-modules b/debian/installer/modules/loong64/f2fs-modules
--- a/debian/installer/modules/loong64/f2fs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/f2fs-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <f2fs-modules>
diff -uNr a/debian/installer/modules/loong64/fat-modules b/debian/installer/modules/loong64/fat-modules
--- a/debian/installer/modules/loong64/fat-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/fat-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <fat-modules>
diff -uNr a/debian/installer/modules/loong64/fb-modules b/debian/installer/modules/loong64/fb-modules
--- a/debian/installer/modules/loong64/fb-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/fb-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <fb-modules>
diff -uNr a/debian/installer/modules/loong64/fuse-modules b/debian/installer/modules/loong64/fuse-modules
--- a/debian/installer/modules/loong64/fuse-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/fuse-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <fuse-modules>
diff -uNr a/debian/installer/modules/loong64/i2c-modules b/debian/installer/modules/loong64/i2c-modules
--- a/debian/installer/modules/loong64/i2c-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/i2c-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <i2c-modules>
diff -uNr a/debian/installer/modules/loong64/input-modules b/debian/installer/modules/loong64/input-modules
--- a/debian/installer/modules/loong64/input-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/input-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <input-modules>
diff -uNr a/debian/installer/modules/loong64/isofs-modules b/debian/installer/modules/loong64/isofs-modules
--- a/debian/installer/modules/loong64/isofs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/isofs-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <isofs-modules>
diff -uNr a/debian/installer/modules/loong64/jfs-modules b/debian/installer/modules/loong64/jfs-modules
--- a/debian/installer/modules/loong64/jfs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/jfs-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <jfs-modules>
diff -uNr a/debian/installer/modules/loong64/kernel-image b/debian/installer/modules/loong64/kernel-image
--- a/debian/installer/modules/loong64/kernel-image	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/kernel-image	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <kernel-image>
diff -uNr a/debian/installer/modules/loong64/loop-modules b/debian/installer/modules/loong64/loop-modules
--- a/debian/installer/modules/loong64/loop-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/loop-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <loop-modules>
diff -uNr a/debian/installer/modules/loong64/md-modules b/debian/installer/modules/loong64/md-modules
--- a/debian/installer/modules/loong64/md-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/md-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <md-modules>
diff -uNr a/debian/installer/modules/loong64/multipath-modules b/debian/installer/modules/loong64/multipath-modules
--- a/debian/installer/modules/loong64/multipath-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/multipath-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <multipath-modules>
diff -uNr a/debian/installer/modules/loong64/nbd-modules b/debian/installer/modules/loong64/nbd-modules
--- a/debian/installer/modules/loong64/nbd-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/nbd-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <nbd-modules>
diff -uNr a/debian/installer/modules/loong64/nic-modules b/debian/installer/modules/loong64/nic-modules
--- a/debian/installer/modules/loong64/nic-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/nic-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <nic-modules>
diff -uNr a/debian/installer/modules/loong64/nic-shared-modules b/debian/installer/modules/loong64/nic-shared-modules
--- a/debian/installer/modules/loong64/nic-shared-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/nic-shared-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <nic-shared-modules>
diff -uNr a/debian/installer/modules/loong64/nic-usb-modules b/debian/installer/modules/loong64/nic-usb-modules
--- a/debian/installer/modules/loong64/nic-usb-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/nic-usb-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <nic-usb-modules>
diff -uNr a/debian/installer/modules/loong64/nic-wireless-modules b/debian/installer/modules/loong64/nic-wireless-modules
--- a/debian/installer/modules/loong64/nic-wireless-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/nic-wireless-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <nic-wireless-modules>
diff -uNr a/debian/installer/modules/loong64/pata-modules b/debian/installer/modules/loong64/pata-modules
--- a/debian/installer/modules/loong64/pata-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/pata-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <pata-modules>
diff -uNr a/debian/installer/modules/loong64/ppp-modules b/debian/installer/modules/loong64/ppp-modules
--- a/debian/installer/modules/loong64/ppp-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/ppp-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <ppp-modules>
diff -uNr a/debian/installer/modules/loong64/rfkill-modules b/debian/installer/modules/loong64/rfkill-modules
--- a/debian/installer/modules/loong64/rfkill-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/rfkill-modules	2023-06-29 16:16:11.264253045 +0800
@@ -0,0 +1 @@
+#include <rfkill-modules>
diff -uNr a/debian/installer/modules/loong64/sata-modules b/debian/installer/modules/loong64/sata-modules
--- a/debian/installer/modules/loong64/sata-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/sata-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <sata-modules>
diff -uNr a/debian/installer/modules/loong64/scsi-core-modules b/debian/installer/modules/loong64/scsi-core-modules
--- a/debian/installer/modules/loong64/scsi-core-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/scsi-core-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <scsi-core-modules>
diff -uNr a/debian/installer/modules/loong64/scsi-modules b/debian/installer/modules/loong64/scsi-modules
--- a/debian/installer/modules/loong64/scsi-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/scsi-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1,2 @@
+#include <scsi-modules>
+
diff -uNr a/debian/installer/modules/loong64/scsi-nic-modules b/debian/installer/modules/loong64/scsi-nic-modules
--- a/debian/installer/modules/loong64/scsi-nic-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/scsi-nic-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <scsi-nic-modules>
diff -uNr a/debian/installer/modules/loong64/squashfs-modules b/debian/installer/modules/loong64/squashfs-modules
--- a/debian/installer/modules/loong64/squashfs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/squashfs-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <squashfs-modules>
diff -uNr a/debian/installer/modules/loong64/udf-modules b/debian/installer/modules/loong64/udf-modules
--- a/debian/installer/modules/loong64/udf-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/udf-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <udf-modules>
diff -uNr a/debian/installer/modules/loong64/usb-modules b/debian/installer/modules/loong64/usb-modules
--- a/debian/installer/modules/loong64/usb-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/usb-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <usb-modules>
diff -uNr a/debian/installer/modules/loong64/usb-serial-modules b/debian/installer/modules/loong64/usb-serial-modules
--- a/debian/installer/modules/loong64/usb-serial-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/usb-serial-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <usb-serial-modules>
diff -uNr a/debian/installer/modules/loong64/usb-storage-modules b/debian/installer/modules/loong64/usb-storage-modules
--- a/debian/installer/modules/loong64/usb-storage-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/usb-storage-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1 @@
+#include <usb-storage-modules>
diff -uNr a/debian/installer/modules/loong64/xfs-modules b/debian/installer/modules/loong64/xfs-modules
--- a/debian/installer/modules/loong64/xfs-modules	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/installer/modules/loong64/xfs-modules	2023-06-29 16:16:11.268252950 +0800
@@ -0,0 +1,2 @@
+#include <xfs-modules>
+
diff -uNr a/debian/installer/package-list b/debian/installer/package-list
--- a/debian/installer/package-list	2023-05-08 05:14:03.000000000 +0800
+++ b/debian/installer/package-list	2023-06-29 16:16:11.268252950 +0800
@@ -8,6 +8,7 @@
 Provides_armmp: mmc-core-modules, mtd-core-modules
 Provides_i386: rtc-modules
 Provides_ia64: efi-modules
+Provides_loong64: i2c-modules, rtc-modules
 Provides_mips: i2c-modules, rtc-modules, mtd-core-modules, mtd-modules
 Provides_mips64: i2c-modules, rtc-modules, mtd-core-modules, mtd-modules
 Provides_mips64el: i2c-modules, rtc-modules, mtd-core-modules, mtd-modules
@@ -46,6 +47,7 @@
 Depends_alpha: i2c-modules
 Depends_hppa: i2c-modules
 Depends_ia64: i2c-modules
+Depends_loong64: i2c-modules
 Depends_sh4: i2c-modules
 Depends_sparc64: i2c-modules
 Priority: standard
diff -uNr a/debian/linux-headers-6.4.0-0-loong64.postinst b/debian/linux-headers-6.4.0-0-loong64.postinst
--- a/debian/linux-headers-6.4.0-0-loong64.postinst	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-headers-6.4.0-0-loong64.postinst	2023-06-29 16:16:11.104256845 +0800
@@ -0,0 +1,18 @@
+#!/usr/bin/perl
+# Author: Michael Gilbert <michael.s.gilbert@gmail.com>
+# Origin: Stripped down version of the linux-headers postinst from Ubuntu's
+#         2.6.32-14-generic kernel, which was itself derived from a
+#         Debian linux-image postinst script.
+
+$|=1;
+my $version  = "6.4.0-0-loong64";
+
+if (-d "/etc/kernel/header_postinst.d") {
+  system ("run-parts --report --exit-on-error --arg=$version " .
+          "/etc/kernel/header_postinst.d") &&
+            die "Failed to process /etc/kernel/header_postinst.d";
+}
+
+exit 0;
+
+__END__
diff -uNr a/debian/linux-headers-loong64.maintscript b/debian/linux-headers-loong64.maintscript
--- a/debian/linux-headers-loong64.maintscript	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-headers-loong64.maintscript	2023-06-29 16:16:11.108256750 +0800
@@ -0,0 +1 @@
+dir_to_symlink /usr/share/doc/linux-headers-loong64 linux-headers-6.4.0-0-loong64 5.7~rc5-1~exp1 linux-headers-loong64
diff -uNr a/debian/linux-image-6.4.0-0-loong64-dbg.lintian-overrides b/debian/linux-image-6.4.0-0-loong64-dbg.lintian-overrides
--- a/debian/linux-image-6.4.0-0-loong64-dbg.lintian-overrides	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64-dbg.lintian-overrides	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,11 @@
+# Kernel dbg packages contain a full image with debug data
+linux-image-6.4.0-0-loong64-dbg: dbg-package-missing-depends
+
+# glibc doesn't seem to check for a PT_GNU_STACK section in vDSOs, so
+# it's OK that they don't have it
+
+# It is intended that 64-bit kernels provide vDSOs for 32-bit executables.
+# lintian currently allows i386 executables on amd64.
+
+# Some 32-bit architectures need 64-bit kernels and we still build
+# these as the "wrong" architecture rather than mandating multiarch.
diff -uNr a/debian/linux-image-6.4.0-0-loong64.lintian-overrides b/debian/linux-image-6.4.0-0-loong64.lintian-overrides
--- a/debian/linux-image-6.4.0-0-loong64.lintian-overrides	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.lintian-overrides	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,4 @@
+# Some 32-bit architectures need 64-bit kernels and we still build
+# these as the "wrong" architecture rather than mandating multiarch.
+
+# vmlinux needs extra sections that would normally be stripped.
diff -uNr a/debian/linux-image-6.4.0-0-loong64.NEWS b/debian/linux-image-6.4.0-0-loong64.NEWS
--- a/debian/linux-image-6.4.0-0-loong64.NEWS	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.NEWS	2023-06-29 16:16:11.164255420 +0800
@@ -0,0 +1,83 @@
+linux (5.10.46-4) unstable; urgency=medium
+
+  * From Linux 5.10.46-4, unprivileged calls to bpf() are disabled by
+    default, mitigating several security issues. However, an admin can
+    still change this setting later on, if needed, by writing 0 or 1 to
+    the kernel.unprivileged_bpf_disabled sysctl.
+
+    If you prefer to keep unprivileged calls to bpf() enabled, set the
+    sysctl:
+
+    kernel.unprivileged_bpf_disabled = 0
+
+    which is the upstream default.
+
+ -- Salvatore Bonaccorso <carnil@debian.org>  Mon, 02 Aug 2021 22:59:24 +0200
+
+linux (5.10~rc7-1~exp2) unstable; urgency=medium
+
+  * From Linux 5.10, all users are allowed to create user namespaces by
+    default.  This will allow programs such as web browsers and container
+    managers to create more restricted sandboxes for untrusted or
+    less-trusted code, without the need to run as root or to use a
+    setuid-root helper.
+
+    The previous Debian default was to restrict this feature to processes
+    running as root, because it exposed more security issues in the
+    kernel.  However, the security benefits of more widespread sandboxing
+    probably now outweigh this risk.
+
+    If you prefer to keep this feature restricted, set the sysctl:
+
+        kernel.unprivileged_userns_clone = 0
+
+ -- Ben Hutchings <benh@debian.org>  Sun, 13 Dec 2020 17:11:36 +0100
+
+linux-latest (86) unstable; urgency=medium
+
+  * From Linux 4.13.10-1, AppArmor is enabled by default.  This allows
+    defining a "profile" for each installed program that can mitigate
+    security vulnerabilities in it.  However, an incorrect profile might
+    disable some functionality of the program.
+
+    In case you suspect that an AppArmor profile is incorrect, see
+    <https://lists.debian.org/debian-devel/2017/11/msg00178.html> and
+    consider reporting a bug in the package providing the profile.  The
+    profile may be part of the program's package or apparmor-profiles.
+
+ -- Ben Hutchings <ben@decadent.org.uk>  Thu, 30 Nov 2017 20:08:25 +0000
+
+linux-latest (81) unstable; urgency=medium
+
+  * From Linux 4.10, the old 'virtual syscall' interface on 64-bit PCs
+    (amd64) is disabled.  This breaks chroot environments and containers
+    that use (e)glibc 2.13 and earlier, including those based on Debian 7
+    or RHEL/CentOS 6.  To re-enable it, set the kernel parameter:
+    vsyscall=emulate
+
+ -- Ben Hutchings <ben@decadent.org.uk>  Fri, 30 Jun 2017 23:50:03 +0100
+
+linux-latest (76) unstable; urgency=medium
+
+  * From Linux 4.8, several changes have been made in the kernel
+    configuration to 'harden' the system, i.e. to mitigate security bugs.
+    Some changes may cause legitimate applications to fail, and can be
+    reverted by run-time configuration:
+    - On most architectures, the /dev/mem device can no longer be used to
+      access devices that also have a kernel driver.  This breaks dosemu
+      and some old user-space graphics drivers.  To allow this, set the
+      kernel parameter: iomem=relaxed
+    - The kernel log is no longer readable by unprivileged users.  To
+      allow this, set the sysctl: kernel.dmesg_restrict=0
+
+ -- Ben Hutchings <ben@decadent.org.uk>  Sat, 29 Oct 2016 02:05:32 +0100
+
+linux-latest (75) unstable; urgency=medium
+
+  * From Linux 4.7, the iptables connection tracking system will no longer
+    automatically load helper modules.  If your firewall configuration
+    depends on connection tracking helpers, you should explicitly load the
+    required modules.  For more information, see
+    <https://home.regit.org/netfilter-en/secure-use-of-helpers/>.
+
+ -- Ben Hutchings <ben@decadent.org.uk>  Sat, 29 Oct 2016 01:53:18 +0100
diff -uNr a/debian/linux-image-6.4.0-0-loong64.postinst b/debian/linux-image-6.4.0-0-loong64.postinst
--- a/debian/linux-image-6.4.0-0-loong64.postinst	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.postinst	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,25 @@
+#!/bin/sh -e
+
+version=6.4.0-0-loong64
+image_path=/boot/vmlinuz-$version
+
+if [ "$1" != configure ]; then
+    exit 0
+fi
+
+depmod $version
+
+if [ -f /lib/modules/$version/.fresh-install ]; then
+    change=install
+else
+    change=upgrade
+fi
+linux-update-symlinks $change $version $image_path
+rm -f /lib/modules/$version/.fresh-install
+
+if [ -d /etc/kernel/postinst.d ]; then
+    DEB_MAINT_PARAMS="$*" run-parts --report --exit-on-error --arg=$version \
+	      --arg=$image_path /etc/kernel/postinst.d
+fi
+
+exit 0
diff -uNr a/debian/linux-image-6.4.0-0-loong64.postrm b/debian/linux-image-6.4.0-0-loong64.postrm
--- a/debian/linux-image-6.4.0-0-loong64.postrm	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.postrm	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,31 @@
+#!/bin/sh -e
+
+version=6.4.0-0-loong64
+image_path=/boot/vmlinuz-$version
+
+rm -f /lib/modules/$version/.fresh-install
+
+if [ "$1" != upgrade ] && command -v linux-update-symlinks >/dev/null; then
+    linux-update-symlinks remove $version $image_path
+fi
+
+if [ -d /etc/kernel/postrm.d ]; then
+    DEB_MAINT_PARAMS="$*" run-parts --report --exit-on-error --arg=$version \
+	      --arg=$image_path /etc/kernel/postrm.d
+fi
+
+if [ "$1" = purge ]; then
+    for extra_file in modules.dep modules.isapnpmap modules.pcimap \
+                      modules.usbmap modules.parportmap \
+                      modules.generic_string modules.ieee1394map \
+                      modules.ieee1394map modules.pnpbiosmap \
+                      modules.alias modules.ccwmap modules.inputmap \
+                      modules.symbols modules.ofmap \
+                      modules.seriomap modules.\*.bin \
+		      modules.softdep modules.devname; do
+	eval rm -f /lib/modules/$version/$extra_file
+    done
+    rmdir /lib/modules/$version || true
+fi
+
+exit 0
diff -uNr a/debian/linux-image-6.4.0-0-loong64.preinst b/debian/linux-image-6.4.0-0-loong64.preinst
--- a/debian/linux-image-6.4.0-0-loong64.preinst	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.preinst	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,21 @@
+#!/bin/sh -e
+
+version=6.4.0-0-loong64
+image_path=/boot/vmlinuz-$version
+
+if [ "$1" = abort-upgrade ]; then
+    exit 0
+fi
+
+if [ "$1" = install ]; then
+    # Create a flag file for postinst
+    mkdir -p /lib/modules/$version
+    touch /lib/modules/$version/.fresh-install
+fi
+
+if [ -d /etc/kernel/preinst.d ]; then
+    DEB_MAINT_PARAMS="$*" run-parts --report --exit-on-error --arg=$version \
+	      --arg=$image_path /etc/kernel/preinst.d
+fi
+
+exit 0
diff -uNr a/debian/linux-image-6.4.0-0-loong64.prerm b/debian/linux-image-6.4.0-0-loong64.prerm
--- a/debian/linux-image-6.4.0-0-loong64.prerm	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-6.4.0-0-loong64.prerm	2023-06-29 16:16:11.124256370 +0800
@@ -0,0 +1,17 @@
+#!/bin/sh -e
+
+version=6.4.0-0-loong64
+image_path=/boot/vmlinuz-$version
+
+if [ "$1" != remove ]; then
+    exit 0
+fi
+
+linux-check-removal $version
+
+if [ -d /etc/kernel/prerm.d ]; then
+    DEB_MAINT_PARAMS="$*" run-parts --report --exit-on-error --arg=$version \
+	      --arg=$image_path /etc/kernel/prerm.d
+fi
+
+exit 0
diff -uNr a/debian/linux-image-loong64.bug-presubj b/debian/linux-image-loong64.bug-presubj
--- a/debian/linux-image-loong64.bug-presubj	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-loong64.bug-presubj	2023-06-29 16:16:11.152255705 +0800
@@ -0,0 +1,5 @@
+You are about to report a bug in a Linux kernel meta package.
+This is probably not what you intended to do.
+
+If you want to report a bug in the Linux kernel or modules, you should use
+the package name linux-image-6.4.0-0-loong64 instead.
diff -uNr a/debian/linux-image-loong64-dbg.lintian-overrides b/debian/linux-image-loong64-dbg.lintian-overrides
--- a/debian/linux-image-loong64-dbg.lintian-overrides	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-loong64-dbg.lintian-overrides	2023-06-29 16:16:11.152255705 +0800
@@ -0,0 +1 @@
+linux-image-loong64-dbg: wrong-section-according-to-package-name linux-image-loong64-dbg => debug
diff -uNr a/debian/linux-image-loong64-dbg.maintscript b/debian/linux-image-loong64-dbg.maintscript
--- a/debian/linux-image-loong64-dbg.maintscript	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-loong64-dbg.maintscript	2023-06-29 16:16:11.152255705 +0800
@@ -0,0 +1 @@
+dir_to_symlink /usr/share/doc/linux-image-loong64-dbg linux-image-6.4.0-0-loong64-dbg 5.7~rc5-1~exp1 linux-image-loong64-dbg
diff -uNr a/debian/linux-image-loong64.maintscript b/debian/linux-image-loong64.maintscript
--- a/debian/linux-image-loong64.maintscript	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/linux-image-loong64.maintscript	2023-06-29 16:16:11.152255705 +0800
@@ -0,0 +1 @@
+dir_to_symlink /usr/share/doc/linux-image-loong64 linux-image-6.4.0-0-loong64 5.7~rc5-1~exp1 linux-image-loong64
diff -uNr a/debian/patches/loongarch/0001-LoongArch-Add-support-to-clone-a-time-namespace.patch b/debian/patches/loongarch/0001-LoongArch-Add-support-to-clone-a-time-namespace.patch
--- a/debian/patches/loongarch/0001-LoongArch-Add-support-to-clone-a-time-namespace.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0001-LoongArch-Add-support-to-clone-a-time-namespace.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,354 @@
+From 9d5d6901f8fcc6a01490da66c2e2e5acd7fd4914 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:12 +0800
+Subject: [PATCH 01/19] LoongArch: Add support to clone a time namespace
+
+We can see that "Time namespaces are not supported" on LoongArch:
+
+(1) clone3 test
+  # cd tools/testing/selftests/clone3 && make && ./clone3
+  ...
+  # Time namespaces are not supported
+  ok 18 # SKIP Skipping clone3() with CLONE_NEWTIME
+  # Totals: pass:17 fail:0 xfail:0 xpass:0 skip:1 error:0
+
+(2) timens test
+  # cd tools/testing/selftests/timens && make && ./timens
+  ...
+  1..0 # SKIP Time namespaces are not supported
+
+On LoongArch the current kernel does not support CONFIG_TIME_NS which
+depends on GENERIC_VDSO_TIME_NS, select GENERIC_VDSO_TIME_NS to enable
+CONFIG_TIME_NS to build kernel/time/namespace.c.
+
+Additionally, it needs to define some arch-dependent functions for the
+timens, such as __arch_get_timens_vdso_data(), arch_get_vdso_data() and
+vdso_join_timens().
+
+At the same time, modify the layout of vvar to use one page size for
+generic vdso data, expand another page size for timens vdso data and
+assign LOONGARCH_VDSO_DATA_SIZE (maybe exceeds a page size if expand in
+the future) for loongarch vdso data, at last add the callback function
+vvar_fault() and modify stack_top().
+
+With this patch under CONFIG_TIME_NS:
+
+(1) clone3 test
+  # cd tools/testing/selftests/clone3 && make && ./clone3
+  ...
+  ok 18 [739] Result (0) matches expectation (0)
+  # Totals: pass:18 fail:0 xfail:0 xpass:0 skip:0 error:0
+
+(2) timens test
+  # cd tools/testing/selftests/timens && make && ./timens
+  ...
+  # Totals: pass:10 fail:0 xfail:0 xpass:0 skip:0 error:0
+
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/Kconfig                        |  1 +
+ arch/loongarch/include/asm/page.h             |  1 +
+ .../loongarch/include/asm/vdso/gettimeofday.h |  9 +-
+ arch/loongarch/include/asm/vdso/vdso.h        | 32 +++++-
+ arch/loongarch/kernel/process.c               |  2 +-
+ arch/loongarch/kernel/vdso.c                  | 98 ++++++++++++++++---
+ arch/loongarch/vdso/vgetcpu.c                 |  2 +-
+ 7 files changed, 121 insertions(+), 24 deletions(-)
+
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index d38b066fc931..93b167f0203d 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -80,6 +80,7 @@ config LOONGARCH
+ 	select GENERIC_SCHED_CLOCK
+ 	select GENERIC_SMP_IDLE_THREAD
+ 	select GENERIC_TIME_VSYSCALL
++	select GENERIC_VDSO_TIME_NS
+ 	select GPIOLIB
+ 	select HAS_IOPORT
+ 	select HAVE_ARCH_AUDITSYSCALL
+diff --git a/arch/loongarch/include/asm/page.h b/arch/loongarch/include/asm/page.h
+index fb5338b352e6..26e8dccb6619 100644
+--- a/arch/loongarch/include/asm/page.h
++++ b/arch/loongarch/include/asm/page.h
+@@ -81,6 +81,7 @@ typedef struct { unsigned long pgprot; } pgprot_t;
+ #define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
+ 
+ #define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
++#define sym_to_pfn(x)		__phys_to_pfn(__pa_symbol(x))
+ 
+ #define virt_to_pfn(kaddr)	PFN_DOWN(PHYSADDR(kaddr))
+ #define virt_to_page(kaddr)	pfn_to_page(virt_to_pfn(kaddr))
+diff --git a/arch/loongarch/include/asm/vdso/gettimeofday.h b/arch/loongarch/include/asm/vdso/gettimeofday.h
+index 7b2cd37641e2..89e6b222c2f2 100644
+--- a/arch/loongarch/include/asm/vdso/gettimeofday.h
++++ b/arch/loongarch/include/asm/vdso/gettimeofday.h
+@@ -91,9 +91,16 @@ static inline bool loongarch_vdso_hres_capable(void)
+ 
+ static __always_inline const struct vdso_data *__arch_get_vdso_data(void)
+ {
+-	return get_vdso_data();
++	return (const struct vdso_data *)get_vdso_data();
+ }
+ 
++#ifdef CONFIG_TIME_NS
++static __always_inline
++const struct vdso_data *__arch_get_timens_vdso_data(const struct vdso_data *vd)
++{
++	return (const struct vdso_data *)(get_vdso_data() + VVAR_TIMENS_PAGE_OFFSET * PAGE_SIZE);
++}
++#endif
+ #endif /* !__ASSEMBLY__ */
+ 
+ #endif /* __ASM_VDSO_GETTIMEOFDAY_H */
+diff --git a/arch/loongarch/include/asm/vdso/vdso.h b/arch/loongarch/include/asm/vdso/vdso.h
+index 3b55d32a0619..5a12309d9fb5 100644
+--- a/arch/loongarch/include/asm/vdso/vdso.h
++++ b/arch/loongarch/include/asm/vdso/vdso.h
+@@ -16,10 +16,33 @@ struct vdso_pcpu_data {
+ 
+ struct loongarch_vdso_data {
+ 	struct vdso_pcpu_data pdata[NR_CPUS];
+-	struct vdso_data data[CS_BASES]; /* Arch-independent data */
+ };
+ 
+-#define VDSO_DATA_SIZE PAGE_ALIGN(sizeof(struct loongarch_vdso_data))
++/*
++ * The layout of vvar:
++ *
++ *                      high
++ * +---------------------+--------------------------+
++ * | loongarch vdso data | LOONGARCH_VDSO_DATA_SIZE |
++ * +---------------------+--------------------------+
++ * |  time-ns vdso data  |        PAGE_SIZE         |
++ * +---------------------+--------------------------+
++ * |  generic vdso data  |        PAGE_SIZE         |
++ * +---------------------+--------------------------+
++ *                      low
++ */
++#define LOONGARCH_VDSO_DATA_SIZE PAGE_ALIGN(sizeof(struct loongarch_vdso_data))
++#define LOONGARCH_VDSO_DATA_PAGES (LOONGARCH_VDSO_DATA_SIZE >> PAGE_SHIFT)
++
++enum vvar_pages {
++	VVAR_GENERIC_PAGE_OFFSET,
++	VVAR_TIMENS_PAGE_OFFSET,
++	VVAR_LOONGARCH_PAGES_START,
++	VVAR_LOONGARCH_PAGES_END = VVAR_LOONGARCH_PAGES_START + LOONGARCH_VDSO_DATA_PAGES - 1,
++	VVAR_NR_PAGES,
++};
++
++#define VVAR_SIZE (VVAR_NR_PAGES << PAGE_SHIFT)
+ 
+ static inline unsigned long get_vdso_base(void)
+ {
+@@ -34,10 +57,9 @@ static inline unsigned long get_vdso_base(void)
+ 	return addr;
+ }
+ 
+-static inline const struct vdso_data *get_vdso_data(void)
++static inline unsigned long get_vdso_data(void)
+ {
+-	return (const struct vdso_data *)(get_vdso_base()
+-			- VDSO_DATA_SIZE + SMP_CACHE_BYTES * NR_CPUS);
++	return get_vdso_base() - VVAR_SIZE;
+ }
+ 
+ #endif /* __ASSEMBLY__ */
+diff --git a/arch/loongarch/kernel/process.c b/arch/loongarch/kernel/process.c
+index b71e17c1cc0c..9535a0662480 100644
+--- a/arch/loongarch/kernel/process.c
++++ b/arch/loongarch/kernel/process.c
+@@ -285,7 +285,7 @@ unsigned long stack_top(void)
+ 
+ 	/* Space for the VDSO & data page */
+ 	top -= PAGE_ALIGN(current->thread.vdso->size);
+-	top -= PAGE_SIZE;
++	top -= VVAR_SIZE;
+ 
+ 	/* Space to randomize the VDSO base */
+ 	if (current->flags & PF_RANDOMIZE)
+diff --git a/arch/loongarch/kernel/vdso.c b/arch/loongarch/kernel/vdso.c
+index eaebd2e0f725..14941e4be66d 100644
+--- a/arch/loongarch/kernel/vdso.c
++++ b/arch/loongarch/kernel/vdso.c
+@@ -14,6 +14,7 @@
+ #include <linux/random.h>
+ #include <linux/sched.h>
+ #include <linux/slab.h>
++#include <linux/time_namespace.h>
+ #include <linux/timekeeper_internal.h>
+ 
+ #include <asm/page.h>
+@@ -26,12 +27,17 @@ extern char vdso_start[], vdso_end[];
+ 
+ /* Kernel-provided data used by the VDSO. */
+ static union {
+-	u8 page[VDSO_DATA_SIZE];
++	u8 page[PAGE_SIZE];
++	struct vdso_data data[CS_BASES];
++} generic_vdso_data __page_aligned_data;
++
++static union {
++	u8 page[LOONGARCH_VDSO_DATA_SIZE];
+ 	struct loongarch_vdso_data vdata;
+ } loongarch_vdso_data __page_aligned_data;
+ 
+ static struct page *vdso_pages[] = { NULL };
+-struct vdso_data *vdso_data = loongarch_vdso_data.vdata.data;
++struct vdso_data *vdso_data = generic_vdso_data.data;
+ struct vdso_pcpu_data *vdso_pdata = loongarch_vdso_data.vdata.pdata;
+ 
+ static int vdso_mremap(const struct vm_special_mapping *sm, struct vm_area_struct *new_vma)
+@@ -41,6 +47,43 @@ static int vdso_mremap(const struct vm_special_mapping *sm, struct vm_area_struc
+ 	return 0;
+ }
+ 
++static vm_fault_t vvar_fault(const struct vm_special_mapping *sm,
++			     struct vm_area_struct *vma, struct vm_fault *vmf)
++{
++	unsigned long pfn;
++	struct page *timens_page = find_timens_vvar_page(vma);
++
++	switch (vmf->pgoff) {
++	case VVAR_GENERIC_PAGE_OFFSET:
++		if (!timens_page)
++			pfn = sym_to_pfn(vdso_data);
++		else
++			pfn = page_to_pfn(timens_page);
++		break;
++#ifdef CONFIG_TIME_NS
++	case VVAR_TIMENS_PAGE_OFFSET:
++		/*
++		 * If a task belongs to a time namespace then a namespace specific
++		 * VVAR is mapped with the VVAR_GENERIC_PAGE_OFFSET and the real
++		 * VVAR page is mapped with the VVAR_TIMENS_PAGE_OFFSET offset.
++		 * See also the comment near timens_setup_vdso_data().
++		 */
++		if (!timens_page)
++			return VM_FAULT_SIGBUS;
++		else
++			pfn = sym_to_pfn(vdso_data);
++		break;
++#endif /* CONFIG_TIME_NS */
++	case VVAR_LOONGARCH_PAGES_START ... VVAR_LOONGARCH_PAGES_END:
++		pfn = sym_to_pfn(&loongarch_vdso_data) + vmf->pgoff - VVAR_LOONGARCH_PAGES_START;
++		break;
++	default:
++		return VM_FAULT_SIGBUS;
++	}
++
++	return vmf_insert_pfn(vma, vmf->address, pfn);
++}
++
+ struct loongarch_vdso_info vdso_info = {
+ 	.vdso = vdso_start,
+ 	.size = PAGE_SIZE,
+@@ -51,6 +94,7 @@ struct loongarch_vdso_info vdso_info = {
+ 	},
+ 	.data_mapping = {
+ 		.name = "[vvar]",
++		.fault = vvar_fault,
+ 	},
+ 	.offset_sigreturn = vdso_offset_sigreturn,
+ };
+@@ -73,6 +117,37 @@ static int __init init_vdso(void)
+ }
+ subsys_initcall(init_vdso);
+ 
++#ifdef CONFIG_TIME_NS
++struct vdso_data *arch_get_vdso_data(void *vvar_page)
++{
++	return (struct vdso_data *)(vvar_page);
++}
++
++/*
++ * The vvar mapping contains data for a specific time namespace, so when a
++ * task changes namespace we must unmap its vvar data for the old namespace.
++ * Subsequent faults will map in data for the new namespace.
++ *
++ * For more details see timens_setup_vdso_data().
++ */
++int vdso_join_timens(struct task_struct *task, struct time_namespace *ns)
++{
++	struct mm_struct *mm = task->mm;
++	struct vm_area_struct *vma;
++
++	VMA_ITERATOR(vmi, mm, 0);
++
++	mmap_read_lock(mm);
++	for_each_vma(vmi, vma) {
++		if (vma_is_special_mapping(vma, &vdso_info.data_mapping))
++			zap_vma_pages(vma);
++	}
++	mmap_read_unlock(mm);
++
++	return 0;
++}
++#endif
++
+ static unsigned long vdso_base(void)
+ {
+ 	unsigned long base = STACK_TOP;
+@@ -88,7 +163,7 @@ static unsigned long vdso_base(void)
+ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
+ {
+ 	int ret;
+-	unsigned long vvar_size, size, data_addr, vdso_addr;
++	unsigned long size, data_addr, vdso_addr;
+ 	struct mm_struct *mm = current->mm;
+ 	struct vm_area_struct *vma;
+ 	struct loongarch_vdso_info *info = current->thread.vdso;
+@@ -100,32 +175,23 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
+ 	 * Determine total area size. This includes the VDSO data itself
+ 	 * and the data pages.
+ 	 */
+-	vvar_size = VDSO_DATA_SIZE;
+-	size = vvar_size + info->size;
++	size = VVAR_SIZE + info->size;
+ 
+ 	data_addr = get_unmapped_area(NULL, vdso_base(), size, 0, 0);
+ 	if (IS_ERR_VALUE(data_addr)) {
+ 		ret = data_addr;
+ 		goto out;
+ 	}
+-	vdso_addr = data_addr + VDSO_DATA_SIZE;
+ 
+-	vma = _install_special_mapping(mm, data_addr, vvar_size,
+-				       VM_READ | VM_MAYREAD,
++	vma = _install_special_mapping(mm, data_addr, VVAR_SIZE,
++				       VM_READ | VM_MAYREAD | VM_PFNMAP,
+ 				       &info->data_mapping);
+ 	if (IS_ERR(vma)) {
+ 		ret = PTR_ERR(vma);
+ 		goto out;
+ 	}
+ 
+-	/* Map VDSO data page. */
+-	ret = remap_pfn_range(vma, data_addr,
+-			      virt_to_phys(&loongarch_vdso_data) >> PAGE_SHIFT,
+-			      vvar_size, PAGE_READONLY);
+-	if (ret)
+-		goto out;
+-
+-	/* Map VDSO code page. */
++	vdso_addr = data_addr + VVAR_SIZE;
+ 	vma = _install_special_mapping(mm, vdso_addr, info->size,
+ 				       VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,
+ 				       &info->code_mapping);
+diff --git a/arch/loongarch/vdso/vgetcpu.c b/arch/loongarch/vdso/vgetcpu.c
+index e02e775f5360..9e445be39763 100644
+--- a/arch/loongarch/vdso/vgetcpu.c
++++ b/arch/loongarch/vdso/vgetcpu.c
+@@ -21,7 +21,7 @@ static __always_inline int read_cpu_id(void)
+ 
+ static __always_inline const struct vdso_pcpu_data *get_pcpu_data(void)
+ {
+-	return (struct vdso_pcpu_data *)(get_vdso_base() - VDSO_DATA_SIZE);
++	return (struct vdso_pcpu_data *)(get_vdso_data() + VVAR_LOONGARCH_PAGES_START * PAGE_SIZE);
+ }
+ 
+ extern
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0002-LoongArch-Add-vector-extensions-support.patch b/debian/patches/loongarch/0002-LoongArch-Add-vector-extensions-support.patch
--- a/debian/patches/loongarch/0002-LoongArch-Add-vector-extensions-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0002-LoongArch-Add-vector-extensions-support.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,1773 @@
+From c6ecf8efa0c706e627aa8e41a0894775315d1002 Mon Sep 17 00:00:00 2001
+From: Huacai Chen <chenhuacai@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:12 +0800
+Subject: [PATCH 02/19] LoongArch: Add vector extensions support
+
+Add LoongArch's vector extensions support, which including 128bit LSX
+(i.e., Loongson SIMD eXtension) and 256bit LASX (i.e., Loongson Advanced
+SIMD eXtension).
+
+Linux kernel doesn't use vector itself, it only handle exceptions and
+context save/restore. So it only needs a subset of these instructions:
+
+* Vector load/store:   vld vst vldx vstx xvld xvst xvldx xvstx
+* 8bit-elements move:  vpickve2gr.b xvpickve2gr.b vinsgr2vr.b xvinsgr2vr.b
+* 16bit-elements move: vpickve2gr.h xvpickve2gr.h vinsgr2vr.h xvinsgr2vr.h
+* 32bit-elements move: vpickve2gr.w xvpickve2gr.w vinsgr2vr.w xvinsgr2vr.w
+* 64bit-elements move: vpickve2gr.d xvpickve2gr.d vinsgr2vr.d xvinsgr2vr.d
+* Elements permute:    vpermi.w vpermi.d xvpermi.w xvpermi.d xvpermi.q
+
+Introduce CC_HAS_LSX_EXTENSION and CC_HAS_LASX_EXTENSION to avoid non-
+vector toolchains complains unsupported instructions.
+
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/Kconfig                       |  51 ++-
+ arch/loongarch/include/asm/asmmacro.h        | 393 +++++++++++++++++++
+ arch/loongarch/include/asm/fpu.h             | 185 ++++++++-
+ arch/loongarch/include/uapi/asm/ptrace.h     |  16 +-
+ arch/loongarch/include/uapi/asm/sigcontext.h |  18 +
+ arch/loongarch/kernel/cpu-probe.c            |  12 +
+ arch/loongarch/kernel/fpu.S                  | 270 +++++++++++++
+ arch/loongarch/kernel/process.c              |  10 +-
+ arch/loongarch/kernel/ptrace.c               | 110 ++++++
+ arch/loongarch/kernel/signal.c               | 326 ++++++++++++++-
+ arch/loongarch/kernel/traps.c                |  84 +++-
+ 11 files changed, 1452 insertions(+), 23 deletions(-)
+
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index 93b167f0203d..dc00aa4f5c5e 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -162,14 +162,6 @@ config 32BIT
+ config 64BIT
+ 	def_bool y
+ 
+-config CPU_HAS_FPU
+-	bool
+-	default y
+-
+-config CPU_HAS_PREFETCH
+-	bool
+-	default y
+-
+ config GENERIC_BUG
+ 	def_bool y
+ 	depends on BUG
+@@ -242,6 +234,12 @@ config SCHED_OMIT_FRAME_POINTER
+ config AS_HAS_EXPLICIT_RELOCS
+ 	def_bool $(as-instr,x:pcalau12i \$t0$(comma)%pc_hi20(x))
+ 
++config CC_HAS_LSX_EXTENSION
++	def_bool $(cc-option,-mlsx)
++
++config CC_HAS_LASX_EXTENSION
++	def_bool $(cc-option,-mlasx)
++
+ menu "Kernel type and options"
+ 
+ source "kernel/Kconfig.hz"
+@@ -482,6 +480,43 @@ config ARCH_STRICT_ALIGN
+ 	  to run kernel only on systems with h/w unaligned access support in
+ 	  order to optimise for performance.
+ 
++config CPU_HAS_FPU
++	bool
++	default y
++
++config CPU_HAS_LSX
++	bool "Support for the Loongson SIMD Extension"
++	depends on CC_HAS_LSX_EXTENSION
++	help
++	  Loongson SIMD Extension (LSX) introduces 128 bit wide vector registers
++	  and a set of SIMD instructions to operate on them. When this option
++	  is enabled the kernel will support allocating & switching LSX
++	  vector register contexts. If you know that your kernel will only be
++	  running on CPUs which do not support LSX or that your userland will
++	  not be making use of it then you may wish to say N here to reduce
++	  the size & complexity of your kernel.
++
++	  If unsure, say Y.
++
++config CPU_HAS_LASX
++	bool "Support for the Loongson Advanced SIMD Extension"
++	depends on CPU_HAS_LSX
++	depends on CC_HAS_LASX_EXTENSION
++	help
++	  Loongson Advanced SIMD Extension (LASX) introduces 256 bit wide vector
++	  registers and a set of SIMD instructions to operate on them. When this
++	  option is enabled the kernel will support allocating & switching LASX
++	  vector register contexts. If you know that your kernel will only be
++	  running on CPUs which do not support LASX or that your userland will
++	  not be making use of it then you may wish to say N here to reduce
++	  the size & complexity of your kernel.
++
++	  If unsure, say Y.
++
++config CPU_HAS_PREFETCH
++	bool
++	default y
++
+ config KEXEC
+ 	bool "Kexec system call"
+ 	select KEXEC_CORE
+diff --git a/arch/loongarch/include/asm/asmmacro.h b/arch/loongarch/include/asm/asmmacro.h
+index c51a1b43acb4..79e1d53fea89 100644
+--- a/arch/loongarch/include/asm/asmmacro.h
++++ b/arch/loongarch/include/asm/asmmacro.h
+@@ -270,6 +270,399 @@
+ 	fld.d	$f31, \tmp, THREAD_FPR31 - THREAD_FPR0
+ 	.endm
+ 
++	.macro	lsx_save_data thread tmp
++	li.w	\tmp, THREAD_FPR0
++	PTR_ADD \tmp, \thread, \tmp
++	vst	$vr0, \tmp, THREAD_FPR0  - THREAD_FPR0
++	vst	$vr1, \tmp, THREAD_FPR1  - THREAD_FPR0
++	vst	$vr2, \tmp, THREAD_FPR2  - THREAD_FPR0
++	vst	$vr3, \tmp, THREAD_FPR3  - THREAD_FPR0
++	vst	$vr4, \tmp, THREAD_FPR4  - THREAD_FPR0
++	vst	$vr5, \tmp, THREAD_FPR5  - THREAD_FPR0
++	vst	$vr6, \tmp, THREAD_FPR6  - THREAD_FPR0
++	vst	$vr7, \tmp, THREAD_FPR7  - THREAD_FPR0
++	vst	$vr8, \tmp, THREAD_FPR8  - THREAD_FPR0
++	vst	$vr9, \tmp, THREAD_FPR9  - THREAD_FPR0
++	vst	$vr10, \tmp, THREAD_FPR10 - THREAD_FPR0
++	vst	$vr11, \tmp, THREAD_FPR11 - THREAD_FPR0
++	vst	$vr12, \tmp, THREAD_FPR12 - THREAD_FPR0
++	vst	$vr13, \tmp, THREAD_FPR13 - THREAD_FPR0
++	vst	$vr14, \tmp, THREAD_FPR14 - THREAD_FPR0
++	vst	$vr15, \tmp, THREAD_FPR15 - THREAD_FPR0
++	vst	$vr16, \tmp, THREAD_FPR16 - THREAD_FPR0
++	vst	$vr17, \tmp, THREAD_FPR17 - THREAD_FPR0
++	vst	$vr18, \tmp, THREAD_FPR18 - THREAD_FPR0
++	vst	$vr19, \tmp, THREAD_FPR19 - THREAD_FPR0
++	vst	$vr20, \tmp, THREAD_FPR20 - THREAD_FPR0
++	vst	$vr21, \tmp, THREAD_FPR21 - THREAD_FPR0
++	vst	$vr22, \tmp, THREAD_FPR22 - THREAD_FPR0
++	vst	$vr23, \tmp, THREAD_FPR23 - THREAD_FPR0
++	vst	$vr24, \tmp, THREAD_FPR24 - THREAD_FPR0
++	vst	$vr25, \tmp, THREAD_FPR25 - THREAD_FPR0
++	vst	$vr26, \tmp, THREAD_FPR26 - THREAD_FPR0
++	vst	$vr27, \tmp, THREAD_FPR27 - THREAD_FPR0
++	vst	$vr28, \tmp, THREAD_FPR28 - THREAD_FPR0
++	vst	$vr29, \tmp, THREAD_FPR29 - THREAD_FPR0
++	vst	$vr30, \tmp, THREAD_FPR30 - THREAD_FPR0
++	vst	$vr31, \tmp, THREAD_FPR31 - THREAD_FPR0
++	.endm
++
++	.macro	lsx_restore_data thread tmp
++	li.w	\tmp, THREAD_FPR0
++	PTR_ADD	\tmp, \thread, \tmp
++	vld	$vr0, \tmp, THREAD_FPR0  - THREAD_FPR0
++	vld	$vr1, \tmp, THREAD_FPR1  - THREAD_FPR0
++	vld	$vr2, \tmp, THREAD_FPR2  - THREAD_FPR0
++	vld	$vr3, \tmp, THREAD_FPR3  - THREAD_FPR0
++	vld	$vr4, \tmp, THREAD_FPR4  - THREAD_FPR0
++	vld	$vr5, \tmp, THREAD_FPR5  - THREAD_FPR0
++	vld	$vr6, \tmp, THREAD_FPR6  - THREAD_FPR0
++	vld	$vr7, \tmp, THREAD_FPR7  - THREAD_FPR0
++	vld	$vr8, \tmp, THREAD_FPR8  - THREAD_FPR0
++	vld	$vr9, \tmp, THREAD_FPR9  - THREAD_FPR0
++	vld	$vr10, \tmp, THREAD_FPR10 - THREAD_FPR0
++	vld	$vr11, \tmp, THREAD_FPR11 - THREAD_FPR0
++	vld	$vr12, \tmp, THREAD_FPR12 - THREAD_FPR0
++	vld	$vr13, \tmp, THREAD_FPR13 - THREAD_FPR0
++	vld	$vr14, \tmp, THREAD_FPR14 - THREAD_FPR0
++	vld	$vr15, \tmp, THREAD_FPR15 - THREAD_FPR0
++	vld	$vr16, \tmp, THREAD_FPR16 - THREAD_FPR0
++	vld	$vr17, \tmp, THREAD_FPR17 - THREAD_FPR0
++	vld	$vr18, \tmp, THREAD_FPR18 - THREAD_FPR0
++	vld	$vr19, \tmp, THREAD_FPR19 - THREAD_FPR0
++	vld	$vr20, \tmp, THREAD_FPR20 - THREAD_FPR0
++	vld	$vr21, \tmp, THREAD_FPR21 - THREAD_FPR0
++	vld	$vr22, \tmp, THREAD_FPR22 - THREAD_FPR0
++	vld	$vr23, \tmp, THREAD_FPR23 - THREAD_FPR0
++	vld	$vr24, \tmp, THREAD_FPR24 - THREAD_FPR0
++	vld	$vr25, \tmp, THREAD_FPR25 - THREAD_FPR0
++	vld	$vr26, \tmp, THREAD_FPR26 - THREAD_FPR0
++	vld	$vr27, \tmp, THREAD_FPR27 - THREAD_FPR0
++	vld	$vr28, \tmp, THREAD_FPR28 - THREAD_FPR0
++	vld	$vr29, \tmp, THREAD_FPR29 - THREAD_FPR0
++	vld	$vr30, \tmp, THREAD_FPR30 - THREAD_FPR0
++	vld	$vr31, \tmp, THREAD_FPR31 - THREAD_FPR0
++	.endm
++
++	.macro	lsx_save_all	thread tmp0 tmp1
++	fpu_save_cc		\thread, \tmp0, \tmp1
++	fpu_save_csr		\thread, \tmp0
++	lsx_save_data		\thread, \tmp0
++	.endm
++
++	.macro	lsx_restore_all	thread tmp0 tmp1
++	lsx_restore_data	\thread, \tmp0
++	fpu_restore_cc		\thread, \tmp0, \tmp1
++	fpu_restore_csr		\thread, \tmp0
++	.endm
++
++	.macro	lsx_save_upper vd base tmp off
++	vpickve2gr.d	\tmp, \vd, 1
++	st.d		\tmp, \base, (\off+8)
++	.endm
++
++	.macro	lsx_save_all_upper thread base tmp
++	li.w		\tmp, THREAD_FPR0
++	PTR_ADD		\base, \thread, \tmp
++	lsx_save_upper	$vr0,  \base, \tmp, (THREAD_FPR0-THREAD_FPR0)
++	lsx_save_upper	$vr1,  \base, \tmp, (THREAD_FPR1-THREAD_FPR0)
++	lsx_save_upper	$vr2,  \base, \tmp, (THREAD_FPR2-THREAD_FPR0)
++	lsx_save_upper	$vr3,  \base, \tmp, (THREAD_FPR3-THREAD_FPR0)
++	lsx_save_upper	$vr4,  \base, \tmp, (THREAD_FPR4-THREAD_FPR0)
++	lsx_save_upper	$vr5,  \base, \tmp, (THREAD_FPR5-THREAD_FPR0)
++	lsx_save_upper	$vr6,  \base, \tmp, (THREAD_FPR6-THREAD_FPR0)
++	lsx_save_upper	$vr7,  \base, \tmp, (THREAD_FPR7-THREAD_FPR0)
++	lsx_save_upper	$vr8,  \base, \tmp, (THREAD_FPR8-THREAD_FPR0)
++	lsx_save_upper	$vr9,  \base, \tmp, (THREAD_FPR9-THREAD_FPR0)
++	lsx_save_upper	$vr10, \base, \tmp, (THREAD_FPR10-THREAD_FPR0)
++	lsx_save_upper	$vr11, \base, \tmp, (THREAD_FPR11-THREAD_FPR0)
++	lsx_save_upper	$vr12, \base, \tmp, (THREAD_FPR12-THREAD_FPR0)
++	lsx_save_upper	$vr13, \base, \tmp, (THREAD_FPR13-THREAD_FPR0)
++	lsx_save_upper	$vr14, \base, \tmp, (THREAD_FPR14-THREAD_FPR0)
++	lsx_save_upper	$vr15, \base, \tmp, (THREAD_FPR15-THREAD_FPR0)
++	lsx_save_upper	$vr16, \base, \tmp, (THREAD_FPR16-THREAD_FPR0)
++	lsx_save_upper	$vr17, \base, \tmp, (THREAD_FPR17-THREAD_FPR0)
++	lsx_save_upper	$vr18, \base, \tmp, (THREAD_FPR18-THREAD_FPR0)
++	lsx_save_upper	$vr19, \base, \tmp, (THREAD_FPR19-THREAD_FPR0)
++	lsx_save_upper	$vr20, \base, \tmp, (THREAD_FPR20-THREAD_FPR0)
++	lsx_save_upper	$vr21, \base, \tmp, (THREAD_FPR21-THREAD_FPR0)
++	lsx_save_upper	$vr22, \base, \tmp, (THREAD_FPR22-THREAD_FPR0)
++	lsx_save_upper	$vr23, \base, \tmp, (THREAD_FPR23-THREAD_FPR0)
++	lsx_save_upper	$vr24, \base, \tmp, (THREAD_FPR24-THREAD_FPR0)
++	lsx_save_upper	$vr25, \base, \tmp, (THREAD_FPR25-THREAD_FPR0)
++	lsx_save_upper	$vr26, \base, \tmp, (THREAD_FPR26-THREAD_FPR0)
++	lsx_save_upper	$vr27, \base, \tmp, (THREAD_FPR27-THREAD_FPR0)
++	lsx_save_upper	$vr28, \base, \tmp, (THREAD_FPR28-THREAD_FPR0)
++	lsx_save_upper	$vr29, \base, \tmp, (THREAD_FPR29-THREAD_FPR0)
++	lsx_save_upper	$vr30, \base, \tmp, (THREAD_FPR30-THREAD_FPR0)
++	lsx_save_upper	$vr31, \base, \tmp, (THREAD_FPR31-THREAD_FPR0)
++	.endm
++
++	.macro	lsx_restore_upper vd base tmp off
++	ld.d		\tmp, \base, (\off+8)
++	vinsgr2vr.d	\vd,  \tmp, 1
++	.endm
++
++	.macro	lsx_restore_all_upper thread base tmp
++	li.w		  \tmp, THREAD_FPR0
++	PTR_ADD		  \base, \thread, \tmp
++	lsx_restore_upper $vr0,  \base, \tmp, (THREAD_FPR0-THREAD_FPR0)
++	lsx_restore_upper $vr1,  \base, \tmp, (THREAD_FPR1-THREAD_FPR0)
++	lsx_restore_upper $vr2,  \base, \tmp, (THREAD_FPR2-THREAD_FPR0)
++	lsx_restore_upper $vr3,  \base, \tmp, (THREAD_FPR3-THREAD_FPR0)
++	lsx_restore_upper $vr4,  \base, \tmp, (THREAD_FPR4-THREAD_FPR0)
++	lsx_restore_upper $vr5,  \base, \tmp, (THREAD_FPR5-THREAD_FPR0)
++	lsx_restore_upper $vr6,  \base, \tmp, (THREAD_FPR6-THREAD_FPR0)
++	lsx_restore_upper $vr7,  \base, \tmp, (THREAD_FPR7-THREAD_FPR0)
++	lsx_restore_upper $vr8,  \base, \tmp, (THREAD_FPR8-THREAD_FPR0)
++	lsx_restore_upper $vr9,  \base, \tmp, (THREAD_FPR9-THREAD_FPR0)
++	lsx_restore_upper $vr10, \base, \tmp, (THREAD_FPR10-THREAD_FPR0)
++	lsx_restore_upper $vr11, \base, \tmp, (THREAD_FPR11-THREAD_FPR0)
++	lsx_restore_upper $vr12, \base, \tmp, (THREAD_FPR12-THREAD_FPR0)
++	lsx_restore_upper $vr13, \base, \tmp, (THREAD_FPR13-THREAD_FPR0)
++	lsx_restore_upper $vr14, \base, \tmp, (THREAD_FPR14-THREAD_FPR0)
++	lsx_restore_upper $vr15, \base, \tmp, (THREAD_FPR15-THREAD_FPR0)
++	lsx_restore_upper $vr16, \base, \tmp, (THREAD_FPR16-THREAD_FPR0)
++	lsx_restore_upper $vr17, \base, \tmp, (THREAD_FPR17-THREAD_FPR0)
++	lsx_restore_upper $vr18, \base, \tmp, (THREAD_FPR18-THREAD_FPR0)
++	lsx_restore_upper $vr19, \base, \tmp, (THREAD_FPR19-THREAD_FPR0)
++	lsx_restore_upper $vr20, \base, \tmp, (THREAD_FPR20-THREAD_FPR0)
++	lsx_restore_upper $vr21, \base, \tmp, (THREAD_FPR21-THREAD_FPR0)
++	lsx_restore_upper $vr22, \base, \tmp, (THREAD_FPR22-THREAD_FPR0)
++	lsx_restore_upper $vr23, \base, \tmp, (THREAD_FPR23-THREAD_FPR0)
++	lsx_restore_upper $vr24, \base, \tmp, (THREAD_FPR24-THREAD_FPR0)
++	lsx_restore_upper $vr25, \base, \tmp, (THREAD_FPR25-THREAD_FPR0)
++	lsx_restore_upper $vr26, \base, \tmp, (THREAD_FPR26-THREAD_FPR0)
++	lsx_restore_upper $vr27, \base, \tmp, (THREAD_FPR27-THREAD_FPR0)
++	lsx_restore_upper $vr28, \base, \tmp, (THREAD_FPR28-THREAD_FPR0)
++	lsx_restore_upper $vr29, \base, \tmp, (THREAD_FPR29-THREAD_FPR0)
++	lsx_restore_upper $vr30, \base, \tmp, (THREAD_FPR30-THREAD_FPR0)
++	lsx_restore_upper $vr31, \base, \tmp, (THREAD_FPR31-THREAD_FPR0)
++	.endm
++
++	.macro	lsx_init_upper vd tmp
++	vinsgr2vr.d	\vd, \tmp, 1
++	.endm
++
++	.macro	lsx_init_all_upper tmp
++	not		\tmp, zero
++	lsx_init_upper	$vr0 \tmp
++	lsx_init_upper	$vr1 \tmp
++	lsx_init_upper	$vr2 \tmp
++	lsx_init_upper	$vr3 \tmp
++	lsx_init_upper	$vr4 \tmp
++	lsx_init_upper	$vr5 \tmp
++	lsx_init_upper	$vr6 \tmp
++	lsx_init_upper	$vr7 \tmp
++	lsx_init_upper	$vr8 \tmp
++	lsx_init_upper	$vr9 \tmp
++	lsx_init_upper	$vr10 \tmp
++	lsx_init_upper	$vr11 \tmp
++	lsx_init_upper	$vr12 \tmp
++	lsx_init_upper	$vr13 \tmp
++	lsx_init_upper	$vr14 \tmp
++	lsx_init_upper	$vr15 \tmp
++	lsx_init_upper	$vr16 \tmp
++	lsx_init_upper	$vr17 \tmp
++	lsx_init_upper	$vr18 \tmp
++	lsx_init_upper	$vr19 \tmp
++	lsx_init_upper	$vr20 \tmp
++	lsx_init_upper	$vr21 \tmp
++	lsx_init_upper	$vr22 \tmp
++	lsx_init_upper	$vr23 \tmp
++	lsx_init_upper	$vr24 \tmp
++	lsx_init_upper	$vr25 \tmp
++	lsx_init_upper	$vr26 \tmp
++	lsx_init_upper	$vr27 \tmp
++	lsx_init_upper	$vr28 \tmp
++	lsx_init_upper	$vr29 \tmp
++	lsx_init_upper	$vr30 \tmp
++	lsx_init_upper	$vr31 \tmp
++	.endm
++
++	.macro	lasx_save_data thread tmp
++	li.w	\tmp, THREAD_FPR0
++	PTR_ADD	\tmp, \thread, \tmp
++	xvst	$xr0, \tmp, THREAD_FPR0  - THREAD_FPR0
++	xvst	$xr1, \tmp, THREAD_FPR1  - THREAD_FPR0
++	xvst	$xr2, \tmp, THREAD_FPR2  - THREAD_FPR0
++	xvst	$xr3, \tmp, THREAD_FPR3  - THREAD_FPR0
++	xvst	$xr4, \tmp, THREAD_FPR4  - THREAD_FPR0
++	xvst	$xr5, \tmp, THREAD_FPR5  - THREAD_FPR0
++	xvst	$xr6, \tmp, THREAD_FPR6  - THREAD_FPR0
++	xvst	$xr7, \tmp, THREAD_FPR7  - THREAD_FPR0
++	xvst	$xr8, \tmp, THREAD_FPR8  - THREAD_FPR0
++	xvst	$xr9, \tmp, THREAD_FPR9  - THREAD_FPR0
++	xvst	$xr10, \tmp, THREAD_FPR10 - THREAD_FPR0
++	xvst	$xr11, \tmp, THREAD_FPR11 - THREAD_FPR0
++	xvst	$xr12, \tmp, THREAD_FPR12 - THREAD_FPR0
++	xvst	$xr13, \tmp, THREAD_FPR13 - THREAD_FPR0
++	xvst	$xr14, \tmp, THREAD_FPR14 - THREAD_FPR0
++	xvst	$xr15, \tmp, THREAD_FPR15 - THREAD_FPR0
++	xvst	$xr16, \tmp, THREAD_FPR16 - THREAD_FPR0
++	xvst	$xr17, \tmp, THREAD_FPR17 - THREAD_FPR0
++	xvst	$xr18, \tmp, THREAD_FPR18 - THREAD_FPR0
++	xvst	$xr19, \tmp, THREAD_FPR19 - THREAD_FPR0
++	xvst	$xr20, \tmp, THREAD_FPR20 - THREAD_FPR0
++	xvst	$xr21, \tmp, THREAD_FPR21 - THREAD_FPR0
++	xvst	$xr22, \tmp, THREAD_FPR22 - THREAD_FPR0
++	xvst	$xr23, \tmp, THREAD_FPR23 - THREAD_FPR0
++	xvst	$xr24, \tmp, THREAD_FPR24 - THREAD_FPR0
++	xvst	$xr25, \tmp, THREAD_FPR25 - THREAD_FPR0
++	xvst	$xr26, \tmp, THREAD_FPR26 - THREAD_FPR0
++	xvst	$xr27, \tmp, THREAD_FPR27 - THREAD_FPR0
++	xvst	$xr28, \tmp, THREAD_FPR28 - THREAD_FPR0
++	xvst	$xr29, \tmp, THREAD_FPR29 - THREAD_FPR0
++	xvst	$xr30, \tmp, THREAD_FPR30 - THREAD_FPR0
++	xvst	$xr31, \tmp, THREAD_FPR31 - THREAD_FPR0
++	.endm
++
++	.macro	lasx_restore_data thread tmp
++	li.w	\tmp, THREAD_FPR0
++	PTR_ADD	\tmp, \thread, \tmp
++	xvld	$xr0, \tmp, THREAD_FPR0  - THREAD_FPR0
++	xvld	$xr1, \tmp, THREAD_FPR1  - THREAD_FPR0
++	xvld	$xr2, \tmp, THREAD_FPR2  - THREAD_FPR0
++	xvld	$xr3, \tmp, THREAD_FPR3  - THREAD_FPR0
++	xvld	$xr4, \tmp, THREAD_FPR4  - THREAD_FPR0
++	xvld	$xr5, \tmp, THREAD_FPR5  - THREAD_FPR0
++	xvld	$xr6, \tmp, THREAD_FPR6  - THREAD_FPR0
++	xvld	$xr7, \tmp, THREAD_FPR7  - THREAD_FPR0
++	xvld	$xr8, \tmp, THREAD_FPR8  - THREAD_FPR0
++	xvld	$xr9, \tmp, THREAD_FPR9  - THREAD_FPR0
++	xvld	$xr10, \tmp, THREAD_FPR10 - THREAD_FPR0
++	xvld	$xr11, \tmp, THREAD_FPR11 - THREAD_FPR0
++	xvld	$xr12, \tmp, THREAD_FPR12 - THREAD_FPR0
++	xvld	$xr13, \tmp, THREAD_FPR13 - THREAD_FPR0
++	xvld	$xr14, \tmp, THREAD_FPR14 - THREAD_FPR0
++	xvld	$xr15, \tmp, THREAD_FPR15 - THREAD_FPR0
++	xvld	$xr16, \tmp, THREAD_FPR16 - THREAD_FPR0
++	xvld	$xr17, \tmp, THREAD_FPR17 - THREAD_FPR0
++	xvld	$xr18, \tmp, THREAD_FPR18 - THREAD_FPR0
++	xvld	$xr19, \tmp, THREAD_FPR19 - THREAD_FPR0
++	xvld	$xr20, \tmp, THREAD_FPR20 - THREAD_FPR0
++	xvld	$xr21, \tmp, THREAD_FPR21 - THREAD_FPR0
++	xvld	$xr22, \tmp, THREAD_FPR22 - THREAD_FPR0
++	xvld	$xr23, \tmp, THREAD_FPR23 - THREAD_FPR0
++	xvld	$xr24, \tmp, THREAD_FPR24 - THREAD_FPR0
++	xvld	$xr25, \tmp, THREAD_FPR25 - THREAD_FPR0
++	xvld	$xr26, \tmp, THREAD_FPR26 - THREAD_FPR0
++	xvld	$xr27, \tmp, THREAD_FPR27 - THREAD_FPR0
++	xvld	$xr28, \tmp, THREAD_FPR28 - THREAD_FPR0
++	xvld	$xr29, \tmp, THREAD_FPR29 - THREAD_FPR0
++	xvld	$xr30, \tmp, THREAD_FPR30 - THREAD_FPR0
++	xvld	$xr31, \tmp, THREAD_FPR31 - THREAD_FPR0
++	.endm
++
++	.macro	lasx_save_all	thread tmp0 tmp1
++	fpu_save_cc		\thread, \tmp0, \tmp1
++	fpu_save_csr		\thread, \tmp0
++	lasx_save_data		\thread, \tmp0
++	.endm
++
++	.macro	lasx_restore_all thread tmp0 tmp1
++	lasx_restore_data	\thread, \tmp0
++	fpu_restore_cc		\thread, \tmp0, \tmp1
++	fpu_restore_csr		\thread, \tmp0
++	.endm
++
++	.macro	lasx_save_upper xd base tmp off
++	/* Nothing */
++	.endm
++
++	.macro	lasx_save_all_upper thread base tmp
++	/* Nothing */
++	.endm
++
++	.macro	lasx_restore_upper xd base tmp0 tmp1 off
++	vld		\tmp0, \base, (\off+16)
++	xvpermi.q 	\xd,   \tmp1, 0x2
++	.endm
++
++	.macro	lasx_restore_all_upper thread base tmp
++	li.w		\tmp, THREAD_FPR0
++	PTR_ADD		\base, \thread, \tmp
++	/* Save $vr31 ($xr31 lower bits) with xvpickve2gr */
++	xvpickve2gr.d	$r17, $xr31, 0
++	xvpickve2gr.d	$r18, $xr31, 1
++	lasx_restore_upper $xr0, \base, $vr31, $xr31, (THREAD_FPR0-THREAD_FPR0)
++	lasx_restore_upper $xr1, \base, $vr31, $xr31, (THREAD_FPR1-THREAD_FPR0)
++	lasx_restore_upper $xr2, \base, $vr31, $xr31, (THREAD_FPR2-THREAD_FPR0)
++	lasx_restore_upper $xr3, \base, $vr31, $xr31, (THREAD_FPR3-THREAD_FPR0)
++	lasx_restore_upper $xr4, \base, $vr31, $xr31, (THREAD_FPR4-THREAD_FPR0)
++	lasx_restore_upper $xr5, \base, $vr31, $xr31, (THREAD_FPR5-THREAD_FPR0)
++	lasx_restore_upper $xr6, \base, $vr31, $xr31, (THREAD_FPR6-THREAD_FPR0)
++	lasx_restore_upper $xr7, \base, $vr31, $xr31, (THREAD_FPR7-THREAD_FPR0)
++	lasx_restore_upper $xr8, \base, $vr31, $xr31, (THREAD_FPR8-THREAD_FPR0)
++	lasx_restore_upper $xr9, \base, $vr31, $xr31, (THREAD_FPR9-THREAD_FPR0)
++	lasx_restore_upper $xr10, \base, $vr31, $xr31, (THREAD_FPR10-THREAD_FPR0)
++	lasx_restore_upper $xr11, \base, $vr31, $xr31, (THREAD_FPR11-THREAD_FPR0)
++	lasx_restore_upper $xr12, \base, $vr31, $xr31, (THREAD_FPR12-THREAD_FPR0)
++	lasx_restore_upper $xr13, \base, $vr31, $xr31, (THREAD_FPR13-THREAD_FPR0)
++	lasx_restore_upper $xr14, \base, $vr31, $xr31, (THREAD_FPR14-THREAD_FPR0)
++	lasx_restore_upper $xr15, \base, $vr31, $xr31, (THREAD_FPR15-THREAD_FPR0)
++	lasx_restore_upper $xr16, \base, $vr31, $xr31, (THREAD_FPR16-THREAD_FPR0)
++	lasx_restore_upper $xr17, \base, $vr31, $xr31, (THREAD_FPR17-THREAD_FPR0)
++	lasx_restore_upper $xr18, \base, $vr31, $xr31, (THREAD_FPR18-THREAD_FPR0)
++	lasx_restore_upper $xr19, \base, $vr31, $xr31, (THREAD_FPR19-THREAD_FPR0)
++	lasx_restore_upper $xr20, \base, $vr31, $xr31, (THREAD_FPR20-THREAD_FPR0)
++	lasx_restore_upper $xr21, \base, $vr31, $xr31, (THREAD_FPR21-THREAD_FPR0)
++	lasx_restore_upper $xr22, \base, $vr31, $xr31, (THREAD_FPR22-THREAD_FPR0)
++	lasx_restore_upper $xr23, \base, $vr31, $xr31, (THREAD_FPR23-THREAD_FPR0)
++	lasx_restore_upper $xr24, \base, $vr31, $xr31, (THREAD_FPR24-THREAD_FPR0)
++	lasx_restore_upper $xr25, \base, $vr31, $xr31, (THREAD_FPR25-THREAD_FPR0)
++	lasx_restore_upper $xr26, \base, $vr31, $xr31, (THREAD_FPR26-THREAD_FPR0)
++	lasx_restore_upper $xr27, \base, $vr31, $xr31, (THREAD_FPR27-THREAD_FPR0)
++	lasx_restore_upper $xr28, \base, $vr31, $xr31, (THREAD_FPR28-THREAD_FPR0)
++	lasx_restore_upper $xr29, \base, $vr31, $xr31, (THREAD_FPR29-THREAD_FPR0)
++	lasx_restore_upper $xr30, \base, $vr31, $xr31, (THREAD_FPR30-THREAD_FPR0)
++	lasx_restore_upper $xr31, \base, $vr31, $xr31, (THREAD_FPR31-THREAD_FPR0)
++	/* Restore $vr31 ($xr31 lower bits) with xvinsgr2vr */
++	xvinsgr2vr.d	$xr31, $r17, 0
++	xvinsgr2vr.d	$xr31, $r18, 1
++	.endm
++
++	.macro	lasx_init_upper xd tmp
++	xvinsgr2vr.d	\xd, \tmp, 2
++	xvinsgr2vr.d	\xd, \tmp, 3
++	.endm
++
++	.macro	lasx_init_all_upper tmp
++	not		\tmp, zero
++	lasx_init_upper	$xr0 \tmp
++	lasx_init_upper	$xr1 \tmp
++	lasx_init_upper	$xr2 \tmp
++	lasx_init_upper	$xr3 \tmp
++	lasx_init_upper	$xr4 \tmp
++	lasx_init_upper	$xr5 \tmp
++	lasx_init_upper	$xr6 \tmp
++	lasx_init_upper	$xr7 \tmp
++	lasx_init_upper	$xr8 \tmp
++	lasx_init_upper	$xr9 \tmp
++	lasx_init_upper	$xr10 \tmp
++	lasx_init_upper	$xr11 \tmp
++	lasx_init_upper	$xr12 \tmp
++	lasx_init_upper	$xr13 \tmp
++	lasx_init_upper	$xr14 \tmp
++	lasx_init_upper	$xr15 \tmp
++	lasx_init_upper	$xr16 \tmp
++	lasx_init_upper	$xr17 \tmp
++	lasx_init_upper	$xr18 \tmp
++	lasx_init_upper	$xr19 \tmp
++	lasx_init_upper	$xr20 \tmp
++	lasx_init_upper	$xr21 \tmp
++	lasx_init_upper	$xr22 \tmp
++	lasx_init_upper	$xr23 \tmp
++	lasx_init_upper	$xr24 \tmp
++	lasx_init_upper	$xr25 \tmp
++	lasx_init_upper	$xr26 \tmp
++	lasx_init_upper	$xr27 \tmp
++	lasx_init_upper	$xr28 \tmp
++	lasx_init_upper	$xr29 \tmp
++	lasx_init_upper	$xr30 \tmp
++	lasx_init_upper	$xr31 \tmp
++	.endm
++
+ .macro not dst src
+ 	nor	\dst, \src, zero
+ .endm
+diff --git a/arch/loongarch/include/asm/fpu.h b/arch/loongarch/include/asm/fpu.h
+index 192f8e35d912..e4193d637f66 100644
+--- a/arch/loongarch/include/asm/fpu.h
++++ b/arch/loongarch/include/asm/fpu.h
+@@ -28,6 +28,26 @@ extern void _init_fpu(unsigned int);
+ extern void _save_fp(struct loongarch_fpu *);
+ extern void _restore_fp(struct loongarch_fpu *);
+ 
++extern void _save_lsx(struct loongarch_fpu *fpu);
++extern void _restore_lsx(struct loongarch_fpu *fpu);
++extern void _init_lsx_upper(void);
++extern void _restore_lsx_upper(struct loongarch_fpu *fpu);
++
++extern void _save_lasx(struct loongarch_fpu *fpu);
++extern void _restore_lasx(struct loongarch_fpu *fpu);
++extern void _init_lasx_upper(void);
++extern void _restore_lasx_upper(struct loongarch_fpu *fpu);
++
++static inline void enable_lsx(void);
++static inline void disable_lsx(void);
++static inline void save_lsx(struct task_struct *t);
++static inline void restore_lsx(struct task_struct *t);
++
++static inline void enable_lasx(void);
++static inline void disable_lasx(void);
++static inline void save_lasx(struct task_struct *t);
++static inline void restore_lasx(struct task_struct *t);
++
+ /*
+  * Mask the FCSR Cause bits according to the Enable bits, observing
+  * that Unimplemented is always enabled.
+@@ -44,6 +64,29 @@ static inline int is_fp_enabled(void)
+ 		1 : 0;
+ }
+ 
++static inline int is_lsx_enabled(void)
++{
++	if (!cpu_has_lsx)
++		return 0;
++
++	return (csr_read32(LOONGARCH_CSR_EUEN) & CSR_EUEN_LSXEN) ?
++		1 : 0;
++}
++
++static inline int is_lasx_enabled(void)
++{
++	if (!cpu_has_lasx)
++		return 0;
++
++	return (csr_read32(LOONGARCH_CSR_EUEN) & CSR_EUEN_LASXEN) ?
++		1 : 0;
++}
++
++static inline int is_simd_enabled(void)
++{
++	return is_lsx_enabled() | is_lasx_enabled();
++}
++
+ #define enable_fpu()		set_csr_euen(CSR_EUEN_FPEN)
+ 
+ #define disable_fpu()		clear_csr_euen(CSR_EUEN_FPEN)
+@@ -81,9 +124,22 @@ static inline void own_fpu(int restore)
+ static inline void lose_fpu_inatomic(int save, struct task_struct *tsk)
+ {
+ 	if (is_fpu_owner()) {
+-		if (save)
+-			_save_fp(&tsk->thread.fpu);
+-		disable_fpu();
++		if (!is_simd_enabled()) {
++			if (save)
++				_save_fp(&tsk->thread.fpu);
++			disable_fpu();
++		} else {
++			if (save) {
++				if (!is_lasx_enabled())
++					save_lsx(tsk);
++				else
++					save_lasx(tsk);
++			}
++			disable_fpu();
++			disable_lsx();
++			disable_lasx();
++			clear_tsk_thread_flag(tsk, TIF_USEDSIMD);
++		}
+ 		clear_tsk_thread_flag(tsk, TIF_USEDFPU);
+ 	}
+ 	KSTK_EUEN(tsk) &= ~(CSR_EUEN_FPEN | CSR_EUEN_LSXEN | CSR_EUEN_LASXEN);
+@@ -129,4 +185,127 @@ static inline union fpureg *get_fpu_regs(struct task_struct *tsk)
+ 	return tsk->thread.fpu.fpr;
+ }
+ 
++static inline int is_simd_owner(void)
++{
++	return test_thread_flag(TIF_USEDSIMD);
++}
++
++#ifdef CONFIG_CPU_HAS_LSX
++
++static inline void enable_lsx(void)
++{
++	if (cpu_has_lsx)
++		csr_xchg32(CSR_EUEN_LSXEN, CSR_EUEN_LSXEN, LOONGARCH_CSR_EUEN);
++}
++
++static inline void disable_lsx(void)
++{
++	if (cpu_has_lsx)
++		csr_xchg32(0, CSR_EUEN_LSXEN, LOONGARCH_CSR_EUEN);
++}
++
++static inline void save_lsx(struct task_struct *t)
++{
++	if (cpu_has_lsx)
++		_save_lsx(&t->thread.fpu);
++}
++
++static inline void restore_lsx(struct task_struct *t)
++{
++	if (cpu_has_lsx)
++		_restore_lsx(&t->thread.fpu);
++}
++
++static inline void init_lsx_upper(void)
++{
++	/*
++	 * Check cpu_has_lsx only if it's a constant. This will allow the
++	 * compiler to optimise out code for CPUs without LSX without adding
++	 * an extra redundant check for CPUs with LSX.
++	 */
++	if (__builtin_constant_p(cpu_has_lsx) && !cpu_has_lsx)
++		return;
++
++	_init_lsx_upper();
++}
++
++static inline void restore_lsx_upper(struct task_struct *t)
++{
++	if (cpu_has_lsx)
++		_restore_lsx_upper(&t->thread.fpu);
++}
++
++#else
++static inline void enable_lsx(void) {}
++static inline void disable_lsx(void) {}
++static inline void save_lsx(struct task_struct *t) {}
++static inline void restore_lsx(struct task_struct *t) {}
++static inline void init_lsx_upper(void) {}
++static inline void restore_lsx_upper(struct task_struct *t) {}
++#endif
++
++#ifdef CONFIG_CPU_HAS_LASX
++
++static inline void enable_lasx(void)
++{
++
++	if (cpu_has_lasx)
++		csr_xchg32(CSR_EUEN_LASXEN, CSR_EUEN_LASXEN, LOONGARCH_CSR_EUEN);
++}
++
++static inline void disable_lasx(void)
++{
++	if (cpu_has_lasx)
++		csr_xchg32(0, CSR_EUEN_LASXEN, LOONGARCH_CSR_EUEN);
++}
++
++static inline void save_lasx(struct task_struct *t)
++{
++	if (cpu_has_lasx)
++		_save_lasx(&t->thread.fpu);
++}
++
++static inline void restore_lasx(struct task_struct *t)
++{
++	if (cpu_has_lasx)
++		_restore_lasx(&t->thread.fpu);
++}
++
++static inline void init_lasx_upper(void)
++{
++	if (cpu_has_lasx)
++		_init_lasx_upper();
++}
++
++static inline void restore_lasx_upper(struct task_struct *t)
++{
++	if (cpu_has_lasx)
++		_restore_lasx_upper(&t->thread.fpu);
++}
++
++#else
++static inline void enable_lasx(void) {}
++static inline void disable_lasx(void) {}
++static inline void save_lasx(struct task_struct *t) {}
++static inline void restore_lasx(struct task_struct *t) {}
++static inline void init_lasx_upper(void) {}
++static inline void restore_lasx_upper(struct task_struct *t) {}
++#endif
++
++static inline int thread_lsx_context_live(void)
++{
++	if (__builtin_constant_p(cpu_has_lsx) && !cpu_has_lsx)
++		return 0;
++
++	return test_thread_flag(TIF_LSX_CTX_LIVE);
++}
++
++static inline int thread_lasx_context_live(void)
++{
++	if (__builtin_constant_p(cpu_has_lasx) && !cpu_has_lasx)
++		return 0;
++
++	return test_thread_flag(TIF_LASX_CTX_LIVE);
++}
++
+ #endif /* _ASM_FPU_H */
+diff --git a/arch/loongarch/include/uapi/asm/ptrace.h b/arch/loongarch/include/uapi/asm/ptrace.h
+index 82d811b5c6e9..06e3be52cb04 100644
+--- a/arch/loongarch/include/uapi/asm/ptrace.h
++++ b/arch/loongarch/include/uapi/asm/ptrace.h
+@@ -41,9 +41,19 @@ struct user_pt_regs {
+ } __attribute__((aligned(8)));
+ 
+ struct user_fp_state {
+-	uint64_t    fpr[32];
+-	uint64_t    fcc;
+-	uint32_t    fcsr;
++	uint64_t fpr[32];
++	uint64_t fcc;
++	uint32_t fcsr;
++};
++
++struct user_lsx_state {
++	/* 32 registers, 128 bits width per register. */
++	uint64_t vregs[32*2];
++};
++
++struct user_lasx_state {
++	/* 32 registers, 256 bits width per register. */
++	uint64_t vregs[32*4];
+ };
+ 
+ struct user_watch_state {
+diff --git a/arch/loongarch/include/uapi/asm/sigcontext.h b/arch/loongarch/include/uapi/asm/sigcontext.h
+index 52e49b8bf4be..4cd7d16f7037 100644
+--- a/arch/loongarch/include/uapi/asm/sigcontext.h
++++ b/arch/loongarch/include/uapi/asm/sigcontext.h
+@@ -41,4 +41,22 @@ struct fpu_context {
+ 	__u32	fcsr;
+ };
+ 
++/* LSX context */
++#define LSX_CTX_MAGIC		0x53580001
++#define LSX_CTX_ALIGN		16
++struct lsx_context {
++	__u64	regs[2*32];
++	__u64	fcc;
++	__u32	fcsr;
++};
++
++/* LASX context */
++#define LASX_CTX_MAGIC		0x41535801
++#define LASX_CTX_ALIGN		32
++struct lasx_context {
++	__u64	regs[4*32];
++	__u64	fcc;
++	__u32	fcsr;
++};
++
+ #endif /* _UAPI_ASM_SIGCONTEXT_H */
+diff --git a/arch/loongarch/kernel/cpu-probe.c b/arch/loongarch/kernel/cpu-probe.c
+index 5adf0f736c6d..f42acc6c8df6 100644
+--- a/arch/loongarch/kernel/cpu-probe.c
++++ b/arch/loongarch/kernel/cpu-probe.c
+@@ -116,6 +116,18 @@ static void cpu_probe_common(struct cpuinfo_loongarch *c)
+ 		c->options |= LOONGARCH_CPU_FPU;
+ 		elf_hwcap |= HWCAP_LOONGARCH_FPU;
+ 	}
++#ifdef CONFIG_CPU_HAS_LSX
++	if (config & CPUCFG2_LSX) {
++		c->options |= LOONGARCH_CPU_LSX;
++		elf_hwcap |= HWCAP_LOONGARCH_LSX;
++	}
++#endif
++#ifdef CONFIG_CPU_HAS_LASX
++	if (config & CPUCFG2_LASX) {
++		c->options |= LOONGARCH_CPU_LASX;
++		elf_hwcap |= HWCAP_LOONGARCH_LASX;
++	}
++#endif
+ 	if (config & CPUCFG2_COMPLEX) {
+ 		c->options |= LOONGARCH_CPU_COMPLEX;
+ 		elf_hwcap |= HWCAP_LOONGARCH_COMPLEX;
+diff --git a/arch/loongarch/kernel/fpu.S b/arch/loongarch/kernel/fpu.S
+index ccde94140c89..f3df5f0a4509 100644
+--- a/arch/loongarch/kernel/fpu.S
++++ b/arch/loongarch/kernel/fpu.S
+@@ -145,6 +145,154 @@
+ 	movgr2fcsr	fcsr0, \tmp0
+ 	.endm
+ 
++	.macro sc_save_lsx base
++#ifdef CONFIG_CPU_HAS_LSX
++	EX	vst	$vr0,  \base, (0 * LSX_REG_WIDTH)
++	EX	vst	$vr1,  \base, (1 * LSX_REG_WIDTH)
++	EX	vst	$vr2,  \base, (2 * LSX_REG_WIDTH)
++	EX	vst	$vr3,  \base, (3 * LSX_REG_WIDTH)
++	EX	vst	$vr4,  \base, (4 * LSX_REG_WIDTH)
++	EX	vst	$vr5,  \base, (5 * LSX_REG_WIDTH)
++	EX	vst	$vr6,  \base, (6 * LSX_REG_WIDTH)
++	EX	vst	$vr7,  \base, (7 * LSX_REG_WIDTH)
++	EX	vst	$vr8,  \base, (8 * LSX_REG_WIDTH)
++	EX	vst	$vr9,  \base, (9 * LSX_REG_WIDTH)
++	EX	vst	$vr10, \base, (10 * LSX_REG_WIDTH)
++	EX	vst	$vr11, \base, (11 * LSX_REG_WIDTH)
++	EX	vst	$vr12, \base, (12 * LSX_REG_WIDTH)
++	EX	vst	$vr13, \base, (13 * LSX_REG_WIDTH)
++	EX	vst	$vr14, \base, (14 * LSX_REG_WIDTH)
++	EX	vst	$vr15, \base, (15 * LSX_REG_WIDTH)
++	EX	vst	$vr16, \base, (16 * LSX_REG_WIDTH)
++	EX	vst	$vr17, \base, (17 * LSX_REG_WIDTH)
++	EX	vst	$vr18, \base, (18 * LSX_REG_WIDTH)
++	EX	vst	$vr19, \base, (19 * LSX_REG_WIDTH)
++	EX	vst	$vr20, \base, (20 * LSX_REG_WIDTH)
++	EX	vst	$vr21, \base, (21 * LSX_REG_WIDTH)
++	EX	vst	$vr22, \base, (22 * LSX_REG_WIDTH)
++	EX	vst	$vr23, \base, (23 * LSX_REG_WIDTH)
++	EX	vst	$vr24, \base, (24 * LSX_REG_WIDTH)
++	EX	vst	$vr25, \base, (25 * LSX_REG_WIDTH)
++	EX	vst	$vr26, \base, (26 * LSX_REG_WIDTH)
++	EX	vst	$vr27, \base, (27 * LSX_REG_WIDTH)
++	EX	vst	$vr28, \base, (28 * LSX_REG_WIDTH)
++	EX	vst	$vr29, \base, (29 * LSX_REG_WIDTH)
++	EX	vst	$vr30, \base, (30 * LSX_REG_WIDTH)
++	EX	vst	$vr31, \base, (31 * LSX_REG_WIDTH)
++#endif
++	.endm
++
++	.macro sc_restore_lsx base
++#ifdef CONFIG_CPU_HAS_LSX
++	EX	vld	$vr0,  \base, (0 * LSX_REG_WIDTH)
++	EX	vld	$vr1,  \base, (1 * LSX_REG_WIDTH)
++	EX	vld	$vr2,  \base, (2 * LSX_REG_WIDTH)
++	EX	vld	$vr3,  \base, (3 * LSX_REG_WIDTH)
++	EX	vld	$vr4,  \base, (4 * LSX_REG_WIDTH)
++	EX	vld	$vr5,  \base, (5 * LSX_REG_WIDTH)
++	EX	vld	$vr6,  \base, (6 * LSX_REG_WIDTH)
++	EX	vld	$vr7,  \base, (7 * LSX_REG_WIDTH)
++	EX	vld	$vr8,  \base, (8 * LSX_REG_WIDTH)
++	EX	vld	$vr9,  \base, (9 * LSX_REG_WIDTH)
++	EX	vld	$vr10, \base, (10 * LSX_REG_WIDTH)
++	EX	vld	$vr11, \base, (11 * LSX_REG_WIDTH)
++	EX	vld	$vr12, \base, (12 * LSX_REG_WIDTH)
++	EX	vld	$vr13, \base, (13 * LSX_REG_WIDTH)
++	EX	vld	$vr14, \base, (14 * LSX_REG_WIDTH)
++	EX	vld	$vr15, \base, (15 * LSX_REG_WIDTH)
++	EX	vld	$vr16, \base, (16 * LSX_REG_WIDTH)
++	EX	vld	$vr17, \base, (17 * LSX_REG_WIDTH)
++	EX	vld	$vr18, \base, (18 * LSX_REG_WIDTH)
++	EX	vld	$vr19, \base, (19 * LSX_REG_WIDTH)
++	EX	vld	$vr20, \base, (20 * LSX_REG_WIDTH)
++	EX	vld	$vr21, \base, (21 * LSX_REG_WIDTH)
++	EX	vld	$vr22, \base, (22 * LSX_REG_WIDTH)
++	EX	vld	$vr23, \base, (23 * LSX_REG_WIDTH)
++	EX	vld	$vr24, \base, (24 * LSX_REG_WIDTH)
++	EX	vld	$vr25, \base, (25 * LSX_REG_WIDTH)
++	EX	vld	$vr26, \base, (26 * LSX_REG_WIDTH)
++	EX	vld	$vr27, \base, (27 * LSX_REG_WIDTH)
++	EX	vld	$vr28, \base, (28 * LSX_REG_WIDTH)
++	EX	vld	$vr29, \base, (29 * LSX_REG_WIDTH)
++	EX	vld	$vr30, \base, (30 * LSX_REG_WIDTH)
++	EX	vld	$vr31, \base, (31 * LSX_REG_WIDTH)
++#endif
++	.endm
++
++	.macro sc_save_lasx base
++#ifdef CONFIG_CPU_HAS_LASX
++	EX	xvst	$xr0,  \base, (0 * LASX_REG_WIDTH)
++	EX	xvst	$xr1,  \base, (1 * LASX_REG_WIDTH)
++	EX	xvst	$xr2,  \base, (2 * LASX_REG_WIDTH)
++	EX	xvst	$xr3,  \base, (3 * LASX_REG_WIDTH)
++	EX	xvst	$xr4,  \base, (4 * LASX_REG_WIDTH)
++	EX	xvst	$xr5,  \base, (5 * LASX_REG_WIDTH)
++	EX	xvst	$xr6,  \base, (6 * LASX_REG_WIDTH)
++	EX	xvst	$xr7,  \base, (7 * LASX_REG_WIDTH)
++	EX	xvst	$xr8,  \base, (8 * LASX_REG_WIDTH)
++	EX	xvst	$xr9,  \base, (9 * LASX_REG_WIDTH)
++	EX	xvst	$xr10, \base, (10 * LASX_REG_WIDTH)
++	EX	xvst	$xr11, \base, (11 * LASX_REG_WIDTH)
++	EX	xvst	$xr12, \base, (12 * LASX_REG_WIDTH)
++	EX	xvst	$xr13, \base, (13 * LASX_REG_WIDTH)
++	EX	xvst	$xr14, \base, (14 * LASX_REG_WIDTH)
++	EX	xvst	$xr15, \base, (15 * LASX_REG_WIDTH)
++	EX	xvst	$xr16, \base, (16 * LASX_REG_WIDTH)
++	EX	xvst	$xr17, \base, (17 * LASX_REG_WIDTH)
++	EX	xvst	$xr18, \base, (18 * LASX_REG_WIDTH)
++	EX	xvst	$xr19, \base, (19 * LASX_REG_WIDTH)
++	EX	xvst	$xr20, \base, (20 * LASX_REG_WIDTH)
++	EX	xvst	$xr21, \base, (21 * LASX_REG_WIDTH)
++	EX	xvst	$xr22, \base, (22 * LASX_REG_WIDTH)
++	EX	xvst	$xr23, \base, (23 * LASX_REG_WIDTH)
++	EX	xvst	$xr24, \base, (24 * LASX_REG_WIDTH)
++	EX	xvst	$xr25, \base, (25 * LASX_REG_WIDTH)
++	EX	xvst	$xr26, \base, (26 * LASX_REG_WIDTH)
++	EX	xvst	$xr27, \base, (27 * LASX_REG_WIDTH)
++	EX	xvst	$xr28, \base, (28 * LASX_REG_WIDTH)
++	EX	xvst	$xr29, \base, (29 * LASX_REG_WIDTH)
++	EX	xvst	$xr30, \base, (30 * LASX_REG_WIDTH)
++	EX	xvst	$xr31, \base, (31 * LASX_REG_WIDTH)
++#endif
++	.endm
++
++	.macro sc_restore_lasx base
++#ifdef CONFIG_CPU_HAS_LASX
++	EX	xvld	$xr0,  \base, (0 * LASX_REG_WIDTH)
++	EX	xvld	$xr1,  \base, (1 * LASX_REG_WIDTH)
++	EX	xvld	$xr2,  \base, (2 * LASX_REG_WIDTH)
++	EX	xvld	$xr3,  \base, (3 * LASX_REG_WIDTH)
++	EX	xvld	$xr4,  \base, (4 * LASX_REG_WIDTH)
++	EX	xvld	$xr5,  \base, (5 * LASX_REG_WIDTH)
++	EX	xvld	$xr6,  \base, (6 * LASX_REG_WIDTH)
++	EX	xvld	$xr7,  \base, (7 * LASX_REG_WIDTH)
++	EX	xvld	$xr8,  \base, (8 * LASX_REG_WIDTH)
++	EX	xvld	$xr9,  \base, (9 * LASX_REG_WIDTH)
++	EX	xvld	$xr10, \base, (10 * LASX_REG_WIDTH)
++	EX	xvld	$xr11, \base, (11 * LASX_REG_WIDTH)
++	EX	xvld	$xr12, \base, (12 * LASX_REG_WIDTH)
++	EX	xvld	$xr13, \base, (13 * LASX_REG_WIDTH)
++	EX	xvld	$xr14, \base, (14 * LASX_REG_WIDTH)
++	EX	xvld	$xr15, \base, (15 * LASX_REG_WIDTH)
++	EX	xvld	$xr16, \base, (16 * LASX_REG_WIDTH)
++	EX	xvld	$xr17, \base, (17 * LASX_REG_WIDTH)
++	EX	xvld	$xr18, \base, (18 * LASX_REG_WIDTH)
++	EX	xvld	$xr19, \base, (19 * LASX_REG_WIDTH)
++	EX	xvld	$xr20, \base, (20 * LASX_REG_WIDTH)
++	EX	xvld	$xr21, \base, (21 * LASX_REG_WIDTH)
++	EX	xvld	$xr22, \base, (22 * LASX_REG_WIDTH)
++	EX	xvld	$xr23, \base, (23 * LASX_REG_WIDTH)
++	EX	xvld	$xr24, \base, (24 * LASX_REG_WIDTH)
++	EX	xvld	$xr25, \base, (25 * LASX_REG_WIDTH)
++	EX	xvld	$xr26, \base, (26 * LASX_REG_WIDTH)
++	EX	xvld	$xr27, \base, (27 * LASX_REG_WIDTH)
++	EX	xvld	$xr28, \base, (28 * LASX_REG_WIDTH)
++	EX	xvld	$xr29, \base, (29 * LASX_REG_WIDTH)
++	EX	xvld	$xr30, \base, (30 * LASX_REG_WIDTH)
++	EX	xvld	$xr31, \base, (31 * LASX_REG_WIDTH)
++#endif
++	.endm
++
+ /*
+  * Save a thread's fp context.
+  */
+@@ -166,6 +314,76 @@ SYM_FUNC_START(_restore_fp)
+ 	jr			ra
+ SYM_FUNC_END(_restore_fp)
+ 
++#ifdef CONFIG_CPU_HAS_LSX
++
++/*
++ * Save a thread's LSX vector context.
++ */
++SYM_FUNC_START(_save_lsx)
++	lsx_save_all	a0 t1 t2
++	jr	ra
++SYM_FUNC_END(_save_lsx)
++EXPORT_SYMBOL(_save_lsx)
++
++/*
++ * Restore a thread's LSX vector context.
++ */
++SYM_FUNC_START(_restore_lsx)
++	lsx_restore_all	a0 t1 t2
++	jr	ra
++SYM_FUNC_END(_restore_lsx)
++
++SYM_FUNC_START(_save_lsx_upper)
++	lsx_save_all_upper a0 t0 t1
++	jr	ra
++SYM_FUNC_END(_save_lsx_upper)
++
++SYM_FUNC_START(_restore_lsx_upper)
++	lsx_restore_all_upper a0 t0 t1
++	jr	ra
++SYM_FUNC_END(_restore_lsx_upper)
++
++SYM_FUNC_START(_init_lsx_upper)
++	lsx_init_all_upper t1
++	jr	ra
++SYM_FUNC_END(_init_lsx_upper)
++#endif
++
++#ifdef CONFIG_CPU_HAS_LASX
++
++/*
++ * Save a thread's LASX vector context.
++ */
++SYM_FUNC_START(_save_lasx)
++	lasx_save_all	a0 t1 t2
++	jr	ra
++SYM_FUNC_END(_save_lasx)
++EXPORT_SYMBOL(_save_lasx)
++
++/*
++ * Restore a thread's LASX vector context.
++ */
++SYM_FUNC_START(_restore_lasx)
++	lasx_restore_all a0 t1 t2
++	jr	ra
++SYM_FUNC_END(_restore_lasx)
++
++SYM_FUNC_START(_save_lasx_upper)
++	lasx_save_all_upper a0 t0 t1
++	jr	ra
++SYM_FUNC_END(_save_lasx_upper)
++
++SYM_FUNC_START(_restore_lasx_upper)
++	lasx_restore_all_upper a0 t0 t1
++	jr	ra
++SYM_FUNC_END(_restore_lasx_upper)
++
++SYM_FUNC_START(_init_lasx_upper)
++	lasx_init_all_upper t1
++	jr	ra
++SYM_FUNC_END(_init_lasx_upper)
++#endif
++
+ /*
+  * Load the FPU with signalling NANS.  This bit pattern we're using has
+  * the property that no matter whether considered as single or as double
+@@ -244,6 +462,58 @@ SYM_FUNC_START(_restore_fp_context)
+ 	jr		ra
+ SYM_FUNC_END(_restore_fp_context)
+ 
++/*
++ * a0: fpregs
++ * a1: fcc
++ * a2: fcsr
++ */
++SYM_FUNC_START(_save_lsx_context)
++	sc_save_fcc a1, t0, t1
++	sc_save_fcsr a2, t0
++	sc_save_lsx a0
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_save_lsx_context)
++
++/*
++ * a0: fpregs
++ * a1: fcc
++ * a2: fcsr
++ */
++SYM_FUNC_START(_restore_lsx_context)
++	sc_restore_lsx a0
++	sc_restore_fcc a1, t1, t2
++	sc_restore_fcsr a2, t1
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_restore_lsx_context)
++
++/*
++ * a0: fpregs
++ * a1: fcc
++ * a2: fcsr
++ */
++SYM_FUNC_START(_save_lasx_context)
++	sc_save_fcc a1, t0, t1
++	sc_save_fcsr a2, t0
++	sc_save_lasx a0
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_save_lasx_context)
++
++/*
++ * a0: fpregs
++ * a1: fcc
++ * a2: fcsr
++ */
++SYM_FUNC_START(_restore_lasx_context)
++	sc_restore_lasx a0
++	sc_restore_fcc a1, t1, t2
++	sc_restore_fcsr a2, t1
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_restore_lasx_context)
++
+ SYM_FUNC_START(fault)
+ 	li.w	a0, -EFAULT				# failure
+ 	jr	ra
+diff --git a/arch/loongarch/kernel/process.c b/arch/loongarch/kernel/process.c
+index 9535a0662480..2e04eb07abb6 100644
+--- a/arch/loongarch/kernel/process.c
++++ b/arch/loongarch/kernel/process.c
+@@ -117,8 +117,14 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
+ 	 */
+ 	preempt_disable();
+ 
+-	if (is_fpu_owner())
+-		save_fp(current);
++	if (is_fpu_owner()) {
++		if (is_lasx_enabled())
++			save_lasx(current);
++		else if (is_lsx_enabled())
++			save_lsx(current);
++		else
++			save_fp(current);
++	}
+ 
+ 	preempt_enable();
+ 
+diff --git a/arch/loongarch/kernel/ptrace.c b/arch/loongarch/kernel/ptrace.c
+index 5fcffb452367..a0767c3a0f0a 100644
+--- a/arch/loongarch/kernel/ptrace.c
++++ b/arch/loongarch/kernel/ptrace.c
+@@ -250,6 +250,90 @@ static int cfg_set(struct task_struct *target,
+ 	return 0;
+ }
+ 
++#ifdef CONFIG_CPU_HAS_LSX
++
++static void copy_pad_fprs(struct task_struct *target,
++			 const struct user_regset *regset,
++			 struct membuf *to, unsigned int live_sz)
++{
++	int i, j;
++	unsigned long long fill = ~0ull;
++	unsigned int cp_sz, pad_sz;
++
++	cp_sz = min(regset->size, live_sz);
++	pad_sz = regset->size - cp_sz;
++	WARN_ON(pad_sz % sizeof(fill));
++
++	for (i = 0; i < NUM_FPU_REGS; i++) {
++		membuf_write(to, &target->thread.fpu.fpr[i], cp_sz);
++		for (j = 0; j < (pad_sz / sizeof(fill)); j++) {
++			membuf_store(to, fill);
++		}
++	}
++}
++
++static int simd_get(struct task_struct *target,
++		    const struct user_regset *regset,
++		    struct membuf to)
++{
++	const unsigned int wr_size = NUM_FPU_REGS * regset->size;
++
++	if (!tsk_used_math(target)) {
++		/* The task hasn't used FP or LSX, fill with 0xff */
++		copy_pad_fprs(target, regset, &to, 0);
++	} else if (!test_tsk_thread_flag(target, TIF_LSX_CTX_LIVE)) {
++		/* Copy scalar FP context, fill the rest with 0xff */
++		copy_pad_fprs(target, regset, &to, 8);
++#ifdef CONFIG_CPU_HAS_LASX
++	} else if (!test_tsk_thread_flag(target, TIF_LASX_CTX_LIVE)) {
++		/* Copy LSX 128 Bit context, fill the rest with 0xff */
++		copy_pad_fprs(target, regset, &to, 16);
++#endif
++	} else if (sizeof(target->thread.fpu.fpr[0]) == regset->size) {
++		/* Trivially copy the vector registers */
++		membuf_write(&to, &target->thread.fpu.fpr, wr_size);
++	} else {
++		/* Copy as much context as possible, fill the rest with 0xff */
++		copy_pad_fprs(target, regset, &to, sizeof(target->thread.fpu.fpr[0]));
++	}
++
++	return 0;
++}
++
++static int simd_set(struct task_struct *target,
++		    const struct user_regset *regset,
++		    unsigned int pos, unsigned int count,
++		    const void *kbuf, const void __user *ubuf)
++{
++	const unsigned int wr_size = NUM_FPU_REGS * regset->size;
++	unsigned int cp_sz;
++	int i, err, start;
++
++	init_fp_ctx(target);
++
++	if (sizeof(target->thread.fpu.fpr[0]) == regset->size) {
++		/* Trivially copy the vector registers */
++		err = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
++					 &target->thread.fpu.fpr,
++					 0, wr_size);
++	} else {
++		/* Copy as much context as possible */
++		cp_sz = min_t(unsigned int, regset->size,
++			      sizeof(target->thread.fpu.fpr[0]));
++
++		i = start = err = 0;
++		for (; i < NUM_FPU_REGS; i++, start += regset->size) {
++			err |= user_regset_copyin(&pos, &count, &kbuf, &ubuf,
++						  &target->thread.fpu.fpr[i],
++						  start, start + cp_sz);
++		}
++	}
++
++	return err;
++}
++
++#endif /* CONFIG_CPU_HAS_LSX */
++
+ #ifdef CONFIG_HAVE_HW_BREAKPOINT
+ 
+ /*
+@@ -708,6 +792,12 @@ enum loongarch_regset {
+ 	REGSET_GPR,
+ 	REGSET_FPR,
+ 	REGSET_CPUCFG,
++#ifdef CONFIG_CPU_HAS_LSX
++	REGSET_LSX,
++#endif
++#ifdef CONFIG_CPU_HAS_LASX
++	REGSET_LASX,
++#endif
+ #ifdef CONFIG_HAVE_HW_BREAKPOINT
+ 	REGSET_HW_BREAK,
+ 	REGSET_HW_WATCH,
+@@ -739,6 +829,26 @@ static const struct user_regset loongarch64_regsets[] = {
+ 		.regset_get	= cfg_get,
+ 		.set		= cfg_set,
+ 	},
++#ifdef CONFIG_CPU_HAS_LSX
++	[REGSET_LSX] = {
++		.core_note_type	= NT_LOONGARCH_LSX,
++		.n		= NUM_FPU_REGS,
++		.size		= 16,
++		.align		= 16,
++		.regset_get	= simd_get,
++		.set		= simd_set,
++	},
++#endif
++#ifdef CONFIG_CPU_HAS_LASX
++	[REGSET_LASX] = {
++		.core_note_type	= NT_LOONGARCH_LASX,
++		.n		= NUM_FPU_REGS,
++		.size		= 32,
++		.align		= 32,
++		.regset_get	= simd_get,
++		.set		= simd_set,
++	},
++#endif
+ #ifdef CONFIG_HAVE_HW_BREAKPOINT
+ 	[REGSET_HW_BREAK] = {
+ 		.core_note_type = NT_LOONGARCH_HW_BREAK,
+diff --git a/arch/loongarch/kernel/signal.c b/arch/loongarch/kernel/signal.c
+index 8f5b7986374b..ceb899366c0a 100644
+--- a/arch/loongarch/kernel/signal.c
++++ b/arch/loongarch/kernel/signal.c
+@@ -50,6 +50,14 @@ extern asmlinkage int
+ _save_fp_context(void __user *fpregs, void __user *fcc, void __user *csr);
+ extern asmlinkage int
+ _restore_fp_context(void __user *fpregs, void __user *fcc, void __user *csr);
++extern asmlinkage int
++_save_lsx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
++extern asmlinkage int
++_restore_lsx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
++extern asmlinkage int
++_save_lasx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
++extern asmlinkage int
++_restore_lasx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
+ 
+ struct rt_sigframe {
+ 	struct siginfo rs_info;
+@@ -65,6 +73,8 @@ struct extctx_layout {
+ 	unsigned long size;
+ 	unsigned int flags;
+ 	struct _ctx_layout fpu;
++	struct _ctx_layout lsx;
++	struct _ctx_layout lasx;
+ 	struct _ctx_layout end;
+ };
+ 
+@@ -115,6 +125,96 @@ static int copy_fpu_from_sigcontext(struct fpu_context __user *ctx)
+ 	return err;
+ }
+ 
++static int copy_lsx_to_sigcontext(struct lsx_context __user *ctx)
++{
++	int i;
++	int err = 0;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	for (i = 0; i < NUM_FPU_REGS; i++) {
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 0),
++				  &regs[2*i]);
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 1),
++				  &regs[2*i+1]);
++	}
++	err |= __put_user(current->thread.fpu.fcc, fcc);
++	err |= __put_user(current->thread.fpu.fcsr, fcsr);
++
++	return err;
++}
++
++static int copy_lsx_from_sigcontext(struct lsx_context __user *ctx)
++{
++	int i;
++	int err = 0;
++	u64 fpr_val;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	for (i = 0; i < NUM_FPU_REGS; i++) {
++		err |= __get_user(fpr_val, &regs[2*i]);
++		set_fpr64(&current->thread.fpu.fpr[i], 0, fpr_val);
++		err |= __get_user(fpr_val, &regs[2*i+1]);
++		set_fpr64(&current->thread.fpu.fpr[i], 1, fpr_val);
++	}
++	err |= __get_user(current->thread.fpu.fcc, fcc);
++	err |= __get_user(current->thread.fpu.fcsr, fcsr);
++
++	return err;
++}
++
++static int copy_lasx_to_sigcontext(struct lasx_context __user *ctx)
++{
++	int i;
++	int err = 0;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	for (i = 0; i < NUM_FPU_REGS; i++) {
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 0),
++				  &regs[4*i]);
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 1),
++				  &regs[4*i+1]);
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 2),
++				  &regs[4*i+2]);
++		err |= __put_user(get_fpr64(&current->thread.fpu.fpr[i], 3),
++				  &regs[4*i+3]);
++	}
++	err |= __put_user(current->thread.fpu.fcc, fcc);
++	err |= __put_user(current->thread.fpu.fcsr, fcsr);
++
++	return err;
++}
++
++static int copy_lasx_from_sigcontext(struct lasx_context __user *ctx)
++{
++	int i;
++	int err = 0;
++	u64 fpr_val;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	for (i = 0; i < NUM_FPU_REGS; i++) {
++		err |= __get_user(fpr_val, &regs[4*i]);
++		set_fpr64(&current->thread.fpu.fpr[i], 0, fpr_val);
++		err |= __get_user(fpr_val, &regs[4*i+1]);
++		set_fpr64(&current->thread.fpu.fpr[i], 1, fpr_val);
++		err |= __get_user(fpr_val, &regs[4*i+2]);
++		set_fpr64(&current->thread.fpu.fpr[i], 2, fpr_val);
++		err |= __get_user(fpr_val, &regs[4*i+3]);
++		set_fpr64(&current->thread.fpu.fpr[i], 3, fpr_val);
++	}
++	err |= __get_user(current->thread.fpu.fcc, fcc);
++	err |= __get_user(current->thread.fpu.fcsr, fcsr);
++
++	return err;
++}
++
+ /*
+  * Wrappers for the assembly _{save,restore}_fp_context functions.
+  */
+@@ -136,6 +236,42 @@ static int restore_hw_fpu_context(struct fpu_context __user *ctx)
+ 	return _restore_fp_context(regs, fcc, fcsr);
+ }
+ 
++static int save_hw_lsx_context(struct lsx_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	return _save_lsx_context(regs, fcc, fcsr);
++}
++
++static int restore_hw_lsx_context(struct lsx_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	return _restore_lsx_context(regs, fcc, fcsr);
++}
++
++static int save_hw_lasx_context(struct lasx_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	return _save_lasx_context(regs, fcc, fcsr);
++}
++
++static int restore_hw_lasx_context(struct lasx_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint64_t __user *fcc	= &ctx->fcc;
++	uint32_t __user *fcsr	= &ctx->fcsr;
++
++	return _restore_lasx_context(regs, fcc, fcsr);
++}
++
+ static int fcsr_pending(unsigned int __user *fcsr)
+ {
+ 	int err, sig = 0;
+@@ -227,6 +363,162 @@ static int protected_restore_fpu_context(struct extctx_layout *extctx)
+ 	return err ?: sig;
+ }
+ 
++static int protected_save_lsx_context(struct extctx_layout *extctx)
++{
++	int err = 0;
++	struct sctx_info __user *info = extctx->lsx.addr;
++	struct lsx_context __user *lsx_ctx = (struct lsx_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lsx_ctx->regs;
++	uint64_t __user *fcc	= &lsx_ctx->fcc;
++	uint32_t __user *fcsr	= &lsx_ctx->fcsr;
++
++	while (1) {
++		lock_fpu_owner();
++		if (is_lsx_enabled())
++			err = save_hw_lsx_context(lsx_ctx);
++		else {
++			if (is_fpu_owner())
++				save_fp(current);
++			err = copy_lsx_to_sigcontext(lsx_ctx);
++		}
++		unlock_fpu_owner();
++
++		err |= __put_user(LSX_CTX_MAGIC, &info->magic);
++		err |= __put_user(extctx->lsx.size, &info->size);
++
++		if (likely(!err))
++			break;
++		/* Touch the LSX context and try again */
++		err = __put_user(0, &regs[0]) |
++			__put_user(0, &regs[32*2-1]) |
++			__put_user(0, fcc) |
++			__put_user(0, fcsr);
++		if (err)
++			return err;	/* really bad sigcontext */
++	}
++
++	return err;
++}
++
++static int protected_restore_lsx_context(struct extctx_layout *extctx)
++{
++	int err = 0, sig = 0, tmp __maybe_unused;
++	struct sctx_info __user *info = extctx->lsx.addr;
++	struct lsx_context __user *lsx_ctx = (struct lsx_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lsx_ctx->regs;
++	uint64_t __user *fcc	= &lsx_ctx->fcc;
++	uint32_t __user *fcsr	= &lsx_ctx->fcsr;
++
++	err = sig = fcsr_pending(fcsr);
++	if (err < 0)
++		return err;
++
++	while (1) {
++		lock_fpu_owner();
++		if (is_lsx_enabled())
++			err = restore_hw_lsx_context(lsx_ctx);
++		else {
++			err = copy_lsx_from_sigcontext(lsx_ctx);
++			if (is_fpu_owner())
++				restore_fp(current);
++		}
++		unlock_fpu_owner();
++
++		if (likely(!err))
++			break;
++		/* Touch the LSX context and try again */
++		err = __get_user(tmp, &regs[0]) |
++			__get_user(tmp, &regs[32*2-1]) |
++			__get_user(tmp, fcc) |
++			__get_user(tmp, fcsr);
++		if (err)
++			break;	/* really bad sigcontext */
++	}
++
++	return err ?: sig;
++}
++
++static int protected_save_lasx_context(struct extctx_layout *extctx)
++{
++	int err = 0;
++	struct sctx_info __user *info = extctx->lasx.addr;
++	struct lasx_context __user *lasx_ctx =
++		(struct lasx_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lasx_ctx->regs;
++	uint64_t __user *fcc	= &lasx_ctx->fcc;
++	uint32_t __user *fcsr	= &lasx_ctx->fcsr;
++
++	while (1) {
++		lock_fpu_owner();
++		if (is_lasx_enabled())
++			err = save_hw_lasx_context(lasx_ctx);
++		else {
++			if (is_lsx_enabled())
++				save_lsx(current);
++			else if (is_fpu_owner())
++				save_fp(current);
++			err = copy_lasx_to_sigcontext(lasx_ctx);
++		}
++		unlock_fpu_owner();
++
++		err |= __put_user(LASX_CTX_MAGIC, &info->magic);
++		err |= __put_user(extctx->lasx.size, &info->size);
++
++		if (likely(!err))
++			break;
++		/* Touch the LASX context and try again */
++		err = __put_user(0, &regs[0]) |
++			__put_user(0, &regs[32*4-1]) |
++			__put_user(0, fcc) |
++			__put_user(0, fcsr);
++		if (err)
++			return err;	/* really bad sigcontext */
++	}
++
++	return err;
++}
++
++static int protected_restore_lasx_context(struct extctx_layout *extctx)
++{
++	int err = 0, sig = 0, tmp __maybe_unused;
++	struct sctx_info __user *info = extctx->lasx.addr;
++	struct lasx_context __user *lasx_ctx =
++		(struct lasx_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lasx_ctx->regs;
++	uint64_t __user *fcc	= &lasx_ctx->fcc;
++	uint32_t __user *fcsr	= &lasx_ctx->fcsr;
++
++	err = sig = fcsr_pending(fcsr);
++	if (err < 0)
++		return err;
++
++	while (1) {
++		lock_fpu_owner();
++		if (is_lasx_enabled())
++			err = restore_hw_lasx_context(lasx_ctx);
++		else {
++			err = copy_lasx_from_sigcontext(lasx_ctx);
++			if (is_lsx_enabled())
++				restore_lsx(current);
++			else if (is_fpu_owner())
++				restore_fp(current);
++		}
++		unlock_fpu_owner();
++
++		if (likely(!err))
++			break;
++		/* Touch the LASX context and try again */
++		err = __get_user(tmp, &regs[0]) |
++			__get_user(tmp, &regs[32*4-1]) |
++			__get_user(tmp, fcc) |
++			__get_user(tmp, fcsr);
++		if (err)
++			break;	/* really bad sigcontext */
++	}
++
++	return err ?: sig;
++}
++
+ static int setup_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc,
+ 			    struct extctx_layout *extctx)
+ {
+@@ -240,7 +532,11 @@ static int setup_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc,
+ 	for (i = 1; i < 32; i++)
+ 		err |= __put_user(regs->regs[i], &sc->sc_regs[i]);
+ 
+-	if (extctx->fpu.addr)
++	if (extctx->lasx.addr)
++		err |= protected_save_lasx_context(extctx);
++	else if (extctx->lsx.addr)
++		err |= protected_save_lsx_context(extctx);
++	else if (extctx->fpu.addr)
+ 		err |= protected_save_fpu_context(extctx);
+ 
+ 	/* Set the "end" magic */
+@@ -274,6 +570,20 @@ static int parse_extcontext(struct sigcontext __user *sc, struct extctx_layout *
+ 			extctx->fpu.addr = info;
+ 			break;
+ 
++		case LSX_CTX_MAGIC:
++			if (size < (sizeof(struct sctx_info) +
++				    sizeof(struct lsx_context)))
++				goto invalid;
++			extctx->lsx.addr = info;
++			break;
++
++		case LASX_CTX_MAGIC:
++			if (size < (sizeof(struct sctx_info) +
++				    sizeof(struct lasx_context)))
++				goto invalid;
++			extctx->lasx.addr = info;
++			break;
++
+ 		default:
+ 			goto invalid;
+ 		}
+@@ -319,7 +629,11 @@ static int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc
+ 	for (i = 1; i < 32; i++)
+ 		err |= __get_user(regs->regs[i], &sc->sc_regs[i]);
+ 
+-	if (extctx.fpu.addr)
++	if (extctx.lasx.addr)
++		err |= protected_restore_lasx_context(&extctx);
++	else if (extctx.lsx.addr)
++		err |= protected_restore_lsx_context(&extctx);
++	else if (extctx.fpu.addr)
+ 		err |= protected_restore_fpu_context(&extctx);
+ 
+ bad:
+@@ -375,7 +689,13 @@ static unsigned long setup_extcontext(struct extctx_layout *extctx, unsigned lon
+ 	extctx->size += extctx->end.size;
+ 
+ 	if (extctx->flags & SC_USED_FP) {
+-		if (cpu_has_fpu)
++		if (cpu_has_lasx && thread_lasx_context_live())
++			new_sp = extframe_alloc(extctx, &extctx->lasx,
++			  sizeof(struct lasx_context), LASX_CTX_ALIGN, new_sp);
++		else if (cpu_has_lsx && thread_lsx_context_live())
++			new_sp = extframe_alloc(extctx, &extctx->lsx,
++			  sizeof(struct lsx_context), LSX_CTX_ALIGN, new_sp);
++		else if (cpu_has_fpu)
+ 			new_sp = extframe_alloc(extctx, &extctx->fpu,
+ 			  sizeof(struct fpu_context), FPU_CTX_ALIGN, new_sp);
+ 	}
+diff --git a/arch/loongarch/kernel/traps.c b/arch/loongarch/kernel/traps.c
+index 8db26e4ca447..417cec119638 100644
+--- a/arch/loongarch/kernel/traps.c
++++ b/arch/loongarch/kernel/traps.c
+@@ -852,12 +852,67 @@ static void init_restore_fp(void)
+ 	BUG_ON(!is_fp_enabled());
+ }
+ 
++static void init_restore_lsx(void)
++{
++	enable_lsx();
++
++	if (!thread_lsx_context_live()) {
++		/* First time LSX context user */
++		init_restore_fp();
++		init_lsx_upper();
++		set_thread_flag(TIF_LSX_CTX_LIVE);
++	} else {
++		if (!is_simd_owner()) {
++			if (is_fpu_owner()) {
++				restore_lsx_upper(current);
++			} else {
++				__own_fpu();
++				restore_lsx(current);
++			}
++		}
++	}
++
++	set_thread_flag(TIF_USEDSIMD);
++
++	BUG_ON(!is_fp_enabled());
++	BUG_ON(!is_lsx_enabled());
++}
++
++static void init_restore_lasx(void)
++{
++	enable_lasx();
++
++	if (!thread_lasx_context_live()) {
++		/* First time LASX context user */
++		init_restore_lsx();
++		init_lasx_upper();
++		set_thread_flag(TIF_LASX_CTX_LIVE);
++	} else {
++		if (is_fpu_owner() || is_simd_owner()) {
++			init_restore_lsx();
++			restore_lasx_upper(current);
++		} else {
++			__own_fpu();
++			enable_lsx();
++			restore_lasx(current);
++		}
++	}
++
++	set_thread_flag(TIF_USEDSIMD);
++
++	BUG_ON(!is_fp_enabled());
++	BUG_ON(!is_lsx_enabled());
++	BUG_ON(!is_lasx_enabled());
++}
++
+ asmlinkage void noinstr do_fpu(struct pt_regs *regs)
+ {
+ 	irqentry_state_t state = irqentry_enter(regs);
+ 
+ 	local_irq_enable();
+ 	die_if_kernel("do_fpu invoked from kernel context!", regs);
++	BUG_ON(is_lsx_enabled());
++	BUG_ON(is_lasx_enabled());
+ 
+ 	preempt_disable();
+ 	init_restore_fp();
+@@ -872,9 +927,20 @@ asmlinkage void noinstr do_lsx(struct pt_regs *regs)
+ 	irqentry_state_t state = irqentry_enter(regs);
+ 
+ 	local_irq_enable();
+-	force_sig(SIGILL);
+-	local_irq_disable();
++	if (!cpu_has_lsx) {
++		force_sig(SIGILL);
++		goto out;
++	}
++
++	die_if_kernel("do_lsx invoked from kernel context!", regs);
++	BUG_ON(is_lasx_enabled());
+ 
++	preempt_disable();
++	init_restore_lsx();
++	preempt_enable();
++
++out:
++	local_irq_disable();
+ 	irqentry_exit(regs, state);
+ }
+ 
+@@ -883,9 +949,19 @@ asmlinkage void noinstr do_lasx(struct pt_regs *regs)
+ 	irqentry_state_t state = irqentry_enter(regs);
+ 
+ 	local_irq_enable();
+-	force_sig(SIGILL);
+-	local_irq_disable();
++	if (!cpu_has_lasx) {
++		force_sig(SIGILL);
++		goto out;
++	}
++
++	die_if_kernel("do_lasx invoked from kernel context!", regs);
+ 
++	preempt_disable();
++	init_restore_lasx();
++	preempt_enable();
++
++out:
++	local_irq_disable();
+ 	irqentry_exit(regs, state);
+ }
+ 
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0003-LoongArch-Add-SMT-Simultaneous-Multi-Threading-suppo.patch b/debian/patches/loongarch/0003-LoongArch-Add-SMT-Simultaneous-Multi-Threading-suppo.patch
--- a/debian/patches/loongarch/0003-LoongArch-Add-SMT-Simultaneous-Multi-Threading-suppo.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0003-LoongArch-Add-SMT-Simultaneous-Multi-Threading-suppo.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,248 @@
+From a2db0ca3dbb841afb020627c5f849d7158dece40 Mon Sep 17 00:00:00 2001
+From: Huacai Chen <chenhuacai@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:12 +0800
+Subject: [PATCH 03/19] LoongArch: Add SMT (Simultaneous Multi-Threading)
+ support
+
+Loongson-3A6000 has SMT (Simultaneous Multi-Threading) support, each
+physical core has two logical cores (threads). This patch add SMT probe
+and scheduler support via ACPI PPTT.
+
+If SCHED_SMT enabled, Loongson-3A6000 is treated as 4 cores, 8 threads;
+If SCHED_SMT disabled, Loongson-3A6000 is treated as 8 cores, 8 threads.
+
+Remove smp_num_siblings to support HMP (Heterogeneous Multi-Processing).
+
+Signed-off-by: Liupu Wang <wangliupu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/Kconfig                |  8 +++++++
+ arch/loongarch/include/asm/acpi.h     |  9 ++++++++
+ arch/loongarch/include/asm/cpu-info.h |  1 +
+ arch/loongarch/kernel/acpi.c          | 32 +++++++++++++++++++++++++++
+ arch/loongarch/kernel/proc.c          |  1 +
+ arch/loongarch/kernel/smp.c           | 24 +++++++++-----------
+ drivers/acpi/Kconfig                  |  2 +-
+ 7 files changed, 62 insertions(+), 15 deletions(-)
+
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index dc00aa4f5c5e..dda6475ea694 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -5,6 +5,7 @@ config LOONGARCH
+ 	select ACPI
+ 	select ACPI_GENERIC_GSI if ACPI
+ 	select ACPI_MCFG if ACPI
++	select ACPI_PPTT if ACPI
+ 	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
+ 	select ARCH_BINFMT_ELF_STATE
+ 	select ARCH_ENABLE_MEMORY_HOTPLUG
+@@ -371,6 +372,13 @@ config EFI_STUB
+ 	  This kernel feature allows the kernel to be loaded directly by
+ 	  EFI firmware without the use of a bootloader.
+ 
++config SCHED_SMT
++	bool "SMT scheduler support"
++	default y
++	help
++	  Improves scheduler's performance when there are multiple
++	  threads in one physical core.
++
+ config SMP
+ 	bool "Multi-Processing support"
+ 	help
+diff --git a/arch/loongarch/include/asm/acpi.h b/arch/loongarch/include/asm/acpi.h
+index 976a810352c6..5c78b5d2bfb7 100644
+--- a/arch/loongarch/include/asm/acpi.h
++++ b/arch/loongarch/include/asm/acpi.h
+@@ -13,6 +13,7 @@ extern int acpi_strict;
+ extern int acpi_disabled;
+ extern int acpi_pci_disabled;
+ extern int acpi_noirq;
++extern int pptt_enabled;
+ 
+ #define acpi_os_ioremap acpi_os_ioremap
+ void __iomem *acpi_os_ioremap(acpi_physical_address phys, acpi_size size);
+@@ -30,6 +31,14 @@ static inline bool acpi_has_cpu_in_madt(void)
+ }
+ 
+ extern struct list_head acpi_wakeup_device_list;
++extern struct acpi_madt_core_pic acpi_core_pic[NR_CPUS];
++
++extern int __init parse_acpi_topology(void);
++
++static inline u32 get_acpi_id_for_cpu(unsigned int cpu)
++{
++	return acpi_core_pic[cpu_logical_map(cpu)].processor_id;
++}
+ 
+ #endif /* !CONFIG_ACPI */
+ 
+diff --git a/arch/loongarch/include/asm/cpu-info.h b/arch/loongarch/include/asm/cpu-info.h
+index cd73a6f57fe3..900589cb159d 100644
+--- a/arch/loongarch/include/asm/cpu-info.h
++++ b/arch/loongarch/include/asm/cpu-info.h
+@@ -54,6 +54,7 @@ struct cpuinfo_loongarch {
+ 	struct cache_desc	cache_leaves[CACHE_LEAVES_MAX];
+ 	int			core;   /* physical core number in package */
+ 	int			package;/* physical package number */
++	int			global_id; /* physical global thread number */
+ 	int			vabits; /* Virtual Address size in bits */
+ 	int			pabits; /* Physical Address size in bits */
+ 	unsigned int		ksave_mask; /* Usable KSave mask. */
+diff --git a/arch/loongarch/kernel/acpi.c b/arch/loongarch/kernel/acpi.c
+index 98f431157e4c..9450e09073eb 100644
+--- a/arch/loongarch/kernel/acpi.c
++++ b/arch/loongarch/kernel/acpi.c
+@@ -33,6 +33,8 @@ u64 acpi_saved_sp;
+ 
+ #define PREFIX			"ACPI: "
+ 
++struct acpi_madt_core_pic acpi_core_pic[NR_CPUS];
++
+ void __init __iomem * __acpi_map_table(unsigned long phys, unsigned long size)
+ {
+ 
+@@ -99,6 +101,7 @@ acpi_parse_processor(union acpi_subtable_headers *header, const unsigned long en
+ 
+ 	acpi_table_print_madt_entry(&header->common);
+ #ifdef CONFIG_SMP
++	acpi_core_pic[processor->core_id] = *processor;
+ 	set_processor_mask(processor->core_id, processor->flags);
+ #endif
+ 
+@@ -140,6 +143,35 @@ static void __init acpi_process_madt(void)
+ 	loongson_sysconf.nr_cpus = num_processors;
+ }
+ 
++int pptt_enabled;
++
++int __init parse_acpi_topology(void)
++{
++	int cpu, topology_id;
++
++	for_each_possible_cpu(cpu) {
++		topology_id = find_acpi_cpu_topology(cpu, 0);
++		if (topology_id < 0) {
++			pr_warn("Invalid BIOS PPTT\n");
++			return -ENOENT;
++		}
++
++		if (acpi_pptt_cpu_is_thread(cpu) <= 0)
++			cpu_data[cpu].core = topology_id;
++		else {
++			topology_id = find_acpi_cpu_topology(cpu, 1);
++			if (topology_id < 0)
++				return -ENOENT;
++
++			cpu_data[cpu].core = topology_id;
++		}
++	}
++
++	pptt_enabled = 1;
++
++	return 0;
++}
++
+ #ifndef CONFIG_SUSPEND
+ int (*acpi_suspend_lowlevel)(void);
+ #else
+diff --git a/arch/loongarch/kernel/proc.c b/arch/loongarch/kernel/proc.c
+index 0d82907b5404..d4b270630bb5 100644
+--- a/arch/loongarch/kernel/proc.c
++++ b/arch/loongarch/kernel/proc.c
+@@ -49,6 +49,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
+ 	seq_printf(m, "processor\t\t: %ld\n", n);
+ 	seq_printf(m, "package\t\t\t: %d\n", cpu_data[n].package);
+ 	seq_printf(m, "core\t\t\t: %d\n", cpu_data[n].core);
++	seq_printf(m, "global_id\t\t: %d\n", cpu_data[n].global_id);
+ 	seq_printf(m, "CPU Family\t\t: %s\n", __cpu_family[n]);
+ 	seq_printf(m, "Model Name\t\t: %s\n", __cpu_full_name[n]);
+ 	seq_printf(m, "CPU Revision\t\t: 0x%02x\n", version);
+diff --git a/arch/loongarch/kernel/smp.c b/arch/loongarch/kernel/smp.c
+index ed167e244cda..062f3fe8df60 100644
+--- a/arch/loongarch/kernel/smp.c
++++ b/arch/loongarch/kernel/smp.c
+@@ -8,6 +8,7 @@
+  * Copyright (C) 2000, 2001 Silicon Graphics, Inc.
+  * Copyright (C) 2000, 2001, 2003 Broadcom Corporation
+  */
++#include <linux/acpi.h>
+ #include <linux/cpu.h>
+ #include <linux/cpumask.h>
+ #include <linux/init.h>
+@@ -37,10 +38,6 @@ EXPORT_SYMBOL(__cpu_number_map);
+ int __cpu_logical_map[NR_CPUS];		/* Map logical to physical */
+ EXPORT_SYMBOL(__cpu_logical_map);
+ 
+-/* Number of threads (siblings) per CPU core */
+-int smp_num_siblings = 1;
+-EXPORT_SYMBOL(smp_num_siblings);
+-
+ /* Representing the threads (siblings) of each logical CPU */
+ cpumask_t cpu_sibling_map[NR_CPUS] __read_mostly;
+ EXPORT_SYMBOL(cpu_sibling_map);
+@@ -228,9 +225,12 @@ void __init loongson_prepare_cpus(unsigned int max_cpus)
+ {
+ 	int i = 0;
+ 
++	parse_acpi_topology();
++
+ 	for (i = 0; i < loongson_sysconf.nr_cpus; i++) {
+ 		set_cpu_present(i, true);
+ 		csr_mail_send(0, __cpu_logical_map[i], 0);
++		cpu_data[i].global_id = __cpu_logical_map[i];
+ 	}
+ 
+ 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
+@@ -271,10 +271,10 @@ void loongson_init_secondary(void)
+ 	numa_add_cpu(cpu);
+ #endif
+ 	per_cpu(cpu_state, cpu) = CPU_ONLINE;
+-	cpu_data[cpu].core =
+-		     cpu_logical_map(cpu) % loongson_sysconf.cores_per_package;
+ 	cpu_data[cpu].package =
+ 		     cpu_logical_map(cpu) / loongson_sysconf.cores_per_package;
++	cpu_data[cpu].core = pptt_enabled ? cpu_data[cpu].core :
++		     cpu_logical_map(cpu) % loongson_sysconf.cores_per_package;
+ }
+ 
+ void loongson_smp_finish(void)
+@@ -380,14 +380,10 @@ static inline void set_cpu_sibling_map(int cpu)
+ 
+ 	cpumask_set_cpu(cpu, &cpu_sibling_setup_map);
+ 
+-	if (smp_num_siblings <= 1)
+-		cpumask_set_cpu(cpu, &cpu_sibling_map[cpu]);
+-	else {
+-		for_each_cpu(i, &cpu_sibling_setup_map) {
+-			if (cpus_are_siblings(cpu, i)) {
+-				cpumask_set_cpu(i, &cpu_sibling_map[cpu]);
+-				cpumask_set_cpu(cpu, &cpu_sibling_map[i]);
+-			}
++	for_each_cpu(i, &cpu_sibling_setup_map) {
++		if (cpus_are_siblings(cpu, i)) {
++			cpumask_set_cpu(i, &cpu_sibling_map[cpu]);
++			cpumask_set_cpu(cpu, &cpu_sibling_map[i]);
+ 		}
+ 	}
+ }
+diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
+index ccbeab9500ec..00dd309b6682 100644
+--- a/drivers/acpi/Kconfig
++++ b/drivers/acpi/Kconfig
+@@ -542,10 +542,10 @@ config ACPI_PFRUT
+ 
+ if ARM64
+ source "drivers/acpi/arm64/Kconfig"
++endif
+ 
+ config ACPI_PPTT
+ 	bool
+-endif
+ 
+ config ACPI_PCC
+ 	bool "ACPI PCC Address Space"
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0004-LoongArch-Support-dbar-with-different-hints.patch b/debian/patches/loongarch/0004-LoongArch-Support-dbar-with-different-hints.patch
--- a/debian/patches/loongarch/0004-LoongArch-Support-dbar-with-different-hints.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0004-LoongArch-Support-dbar-with-different-hints.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,295 @@
+From 3a9bd7fc651f328a39b16046fb47afe75e929881 Mon Sep 17 00:00:00 2001
+From: Huacai Chen <chenhuacai@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:12 +0800
+Subject: [PATCH 04/19] LoongArch: Support dbar with different hints
+
+Traditionally, LoongArch uses "dbar 0" (full completion barrier) for
+everything. But the full completion barrier is a performance killer, so
+Loongson-3A6000 and newer processors have made finer granularity hints
+available:
+
+Bit4: ordering or completion (0: completion, 1: ordering)
+Bit3: barrier for previous read (0: true, 1: false)
+Bit2: barrier for previous write (0: true, 1: false)
+Bit1: barrier for succeeding read (0: true, 1: false)
+Bit0: barrier for succeeding write (0: true, 1: false)
+
+Hint 0x700: barrier for "read after read" from the same address, which
+is needed by LL-SC loops on old models (dbar 0x700 behaves the same as
+nop if such reordering is disabled on new models).
+
+This patch makes use of the various new hints for different kinds of
+memory barriers. It brings performance improvements on Loongson-3A6000
+series, while not affecting the existing models because all variants are
+treated as 'dbar 0' there.
+
+Why override queued_spin_unlock()?
+After commit 01e3b958efe85a26d9b ("drivers: Remove explicit invocations
+of mmiowb()") we need a completion barrier in queued_spin_unlock(), but
+the generic implementation use smp_store_release() which only provide an
+ordering barrier.
+
+Signed-off-by: Jun Yi <yijun@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/Kbuild      |   1 -
+ arch/loongarch/include/asm/barrier.h   | 130 +++++++++++--------------
+ arch/loongarch/include/asm/io.h        |   2 +-
+ arch/loongarch/include/asm/qspinlock.h |  18 ++++
+ arch/loongarch/kernel/smp.c            |   2 +-
+ arch/loongarch/mm/tlbex.S              |   6 +-
+ 6 files changed, 78 insertions(+), 81 deletions(-)
+ create mode 100644 arch/loongarch/include/asm/qspinlock.h
+
+diff --git a/arch/loongarch/include/asm/Kbuild b/arch/loongarch/include/asm/Kbuild
+index 77ad8e6f0906..6b222f227342 100644
+--- a/arch/loongarch/include/asm/Kbuild
++++ b/arch/loongarch/include/asm/Kbuild
+@@ -5,7 +5,6 @@ generic-y += mcs_spinlock.h
+ generic-y += parport.h
+ generic-y += early_ioremap.h
+ generic-y += qrwlock.h
+-generic-y += qspinlock.h
+ generic-y += rwsem.h
+ generic-y += segment.h
+ generic-y += user.h
+diff --git a/arch/loongarch/include/asm/barrier.h b/arch/loongarch/include/asm/barrier.h
+index cda977675854..4b663f197706 100644
+--- a/arch/loongarch/include/asm/barrier.h
++++ b/arch/loongarch/include/asm/barrier.h
+@@ -5,27 +5,56 @@
+ #ifndef __ASM_BARRIER_H
+ #define __ASM_BARRIER_H
+ 
+-#define __sync()	__asm__ __volatile__("dbar 0" : : : "memory")
++/*
++ * Hint encoding:
++ *
++ * Bit4: ordering or completion (0: completion, 1: ordering)
++ * Bit3: barrier for previous read (0: true, 1: false)
++ * Bit2: barrier for previous write (0: true, 1: false)
++ * Bit1: barrier for succeeding read (0: true, 1: false)
++ * Bit0: barrier for succeeding write (0: true, 1: false)
++ *
++ * Hint 0x700: barrier for "read after read" from the same address
++ */
++
++#define DBAR(hint) __asm__ __volatile__("dbar %0 " : : "I"(hint) : "memory")
++
++#define crwrw		0b00000
++#define cr_r_		0b00101
++#define c_w_w		0b01010
+ 
+-#define fast_wmb()	__sync()
+-#define fast_rmb()	__sync()
+-#define fast_mb()	__sync()
+-#define fast_iob()	__sync()
+-#define wbflush()	__sync()
++#define orwrw		0b10000
++#define or_r_		0b10101
++#define o_w_w		0b11010
+ 
+-#define wmb()		fast_wmb()
+-#define rmb()		fast_rmb()
+-#define mb()		fast_mb()
+-#define iob()		fast_iob()
++#define orw_w		0b10010
++#define or_rw		0b10100
+ 
+-#define __smp_mb()	__asm__ __volatile__("dbar 0" : : : "memory")
+-#define __smp_rmb()	__asm__ __volatile__("dbar 0" : : : "memory")
+-#define __smp_wmb()	__asm__ __volatile__("dbar 0" : : : "memory")
++#define c_sync()	DBAR(crwrw)
++#define c_rsync()	DBAR(cr_r_)
++#define c_wsync()	DBAR(c_w_w)
++
++#define o_sync()	DBAR(orwrw)
++#define o_rsync()	DBAR(or_r_)
++#define o_wsync()	DBAR(o_w_w)
++
++#define ldacq_mb()	DBAR(or_rw)
++#define strel_mb()	DBAR(orw_w)
++
++#define mb()		c_sync()
++#define rmb()		c_rsync()
++#define wmb()		c_wsync()
++#define iob()		c_sync()
++#define wbflush()	c_sync()
++
++#define __smp_mb()	o_sync()
++#define __smp_rmb()	o_rsync()
++#define __smp_wmb()	o_wsync()
+ 
+ #ifdef CONFIG_SMP
+-#define __WEAK_LLSC_MB		"	dbar 0  \n"
++#define __WEAK_LLSC_MB		"	dbar 0x700	\n"
+ #else
+-#define __WEAK_LLSC_MB		"		\n"
++#define __WEAK_LLSC_MB		"			\n"
+ #endif
+ 
+ #define __smp_mb__before_atomic()	barrier()
+@@ -59,68 +88,19 @@ static inline unsigned long array_index_mask_nospec(unsigned long index,
+ 	return mask;
+ }
+ 
+-#define __smp_load_acquire(p)							\
+-({										\
+-	union { typeof(*p) __val; char __c[1]; } __u;				\
+-	unsigned long __tmp = 0;							\
+-	compiletime_assert_atomic_type(*p);					\
+-	switch (sizeof(*p)) {							\
+-	case 1:									\
+-		*(__u8 *)__u.__c = *(volatile __u8 *)p;				\
+-		__smp_mb();							\
+-		break;								\
+-	case 2:									\
+-		*(__u16 *)__u.__c = *(volatile __u16 *)p;			\
+-		__smp_mb();							\
+-		break;								\
+-	case 4:									\
+-		__asm__ __volatile__(						\
+-		"amor_db.w %[val], %[tmp], %[mem]	\n"				\
+-		: [val] "=&r" (*(__u32 *)__u.__c)				\
+-		: [mem] "ZB" (*(u32 *) p), [tmp] "r" (__tmp)			\
+-		: "memory");							\
+-		break;								\
+-	case 8:									\
+-		__asm__ __volatile__(						\
+-		"amor_db.d %[val], %[tmp], %[mem]	\n"				\
+-		: [val] "=&r" (*(__u64 *)__u.__c)				\
+-		: [mem] "ZB" (*(u64 *) p), [tmp] "r" (__tmp)			\
+-		: "memory");							\
+-		break;								\
+-	}									\
+-	(typeof(*p))__u.__val;								\
++#define __smp_load_acquire(p)				\
++({							\
++	typeof(*p) ___p1 = READ_ONCE(*p);		\
++	compiletime_assert_atomic_type(*p);		\
++	ldacq_mb();					\
++	___p1;						\
+ })
+ 
+-#define __smp_store_release(p, v)						\
+-do {										\
+-	union { typeof(*p) __val; char __c[1]; } __u =				\
+-		{ .__val = (__force typeof(*p)) (v) };				\
+-	unsigned long __tmp;							\
+-	compiletime_assert_atomic_type(*p);					\
+-	switch (sizeof(*p)) {							\
+-	case 1:									\
+-		__smp_mb();							\
+-		*(volatile __u8 *)p = *(__u8 *)__u.__c;				\
+-		break;								\
+-	case 2:									\
+-		__smp_mb();							\
+-		*(volatile __u16 *)p = *(__u16 *)__u.__c;			\
+-		break;								\
+-	case 4:									\
+-		__asm__ __volatile__(						\
+-		"amswap_db.w %[tmp], %[val], %[mem]	\n"			\
+-		: [mem] "+ZB" (*(u32 *)p), [tmp] "=&r" (__tmp)			\
+-		: [val] "r" (*(__u32 *)__u.__c)					\
+-		: );								\
+-		break;								\
+-	case 8:									\
+-		__asm__ __volatile__(						\
+-		"amswap_db.d %[tmp], %[val], %[mem]	\n"			\
+-		: [mem] "+ZB" (*(u64 *)p), [tmp] "=&r" (__tmp)			\
+-		: [val] "r" (*(__u64 *)__u.__c)					\
+-		: );								\
+-		break;								\
+-	}									\
++#define __smp_store_release(p, v)			\
++do {							\
++	compiletime_assert_atomic_type(*p);		\
++	strel_mb();					\
++	WRITE_ONCE(*p, v);				\
+ } while (0)
+ 
+ #define __smp_store_mb(p, v)							\
+diff --git a/arch/loongarch/include/asm/io.h b/arch/loongarch/include/asm/io.h
+index 545e2708fbf7..1c9410220040 100644
+--- a/arch/loongarch/include/asm/io.h
++++ b/arch/loongarch/include/asm/io.h
+@@ -62,7 +62,7 @@ extern pgprot_t pgprot_wc;
+ #define ioremap_cache(offset, size)	\
+ 	ioremap_prot((offset), (size), pgprot_val(PAGE_KERNEL))
+ 
+-#define mmiowb() asm volatile ("dbar 0" ::: "memory")
++#define mmiowb() wmb()
+ 
+ /*
+  * String version of I/O memory access operations.
+diff --git a/arch/loongarch/include/asm/qspinlock.h b/arch/loongarch/include/asm/qspinlock.h
+new file mode 100644
+index 000000000000..34f43f8ad591
+--- /dev/null
++++ b/arch/loongarch/include/asm/qspinlock.h
+@@ -0,0 +1,18 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++#ifndef _ASM_QSPINLOCK_H
++#define _ASM_QSPINLOCK_H
++
++#include <asm-generic/qspinlock_types.h>
++
++#define queued_spin_unlock queued_spin_unlock
++
++static inline void queued_spin_unlock(struct qspinlock *lock)
++{
++	compiletime_assert_atomic_type(lock->locked);
++	c_sync();
++	WRITE_ONCE(lock->locked, 0);
++}
++
++#include <asm-generic/qspinlock.h>
++
++#endif /* _ASM_QSPINLOCK_H */
+diff --git a/arch/loongarch/kernel/smp.c b/arch/loongarch/kernel/smp.c
+index 062f3fe8df60..ff98a0973ab3 100644
+--- a/arch/loongarch/kernel/smp.c
++++ b/arch/loongarch/kernel/smp.c
+@@ -115,7 +115,7 @@ static u32 ipi_read_clear(int cpu)
+ 	action = iocsr_read32(LOONGARCH_IOCSR_IPI_STATUS);
+ 	/* Clear the ipi register to clear the interrupt */
+ 	iocsr_write32(action, LOONGARCH_IOCSR_IPI_CLEAR);
+-	smp_mb();
++	wbflush();
+ 
+ 	return action;
+ }
+diff --git a/arch/loongarch/mm/tlbex.S b/arch/loongarch/mm/tlbex.S
+index 244e2f5aeee5..240ced55586e 100644
+--- a/arch/loongarch/mm/tlbex.S
++++ b/arch/loongarch/mm/tlbex.S
+@@ -184,7 +184,7 @@ tlb_huge_update_load:
+ 	ertn
+ 
+ nopage_tlb_load:
+-	dbar		0
++	dbar		0x700
+ 	csrrd		ra, EXCEPTION_KS2
+ 	la_abs		t0, tlb_do_page_fault_0
+ 	jr		t0
+@@ -333,7 +333,7 @@ tlb_huge_update_store:
+ 	ertn
+ 
+ nopage_tlb_store:
+-	dbar		0
++	dbar		0x700
+ 	csrrd		ra, EXCEPTION_KS2
+ 	la_abs		t0, tlb_do_page_fault_1
+ 	jr		t0
+@@ -480,7 +480,7 @@ tlb_huge_update_modify:
+ 	ertn
+ 
+ nopage_tlb_modify:
+-	dbar		0
++	dbar		0x700
+ 	csrrd		ra, EXCEPTION_KS2
+ 	la_abs		t0, tlb_do_page_fault_1
+ 	jr		t0
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0005-LoongArch-Introduce-hardware-page-table-walker.patch b/debian/patches/loongarch/0005-LoongArch-Introduce-hardware-page-table-walker.patch
--- a/debian/patches/loongarch/0005-LoongArch-Introduce-hardware-page-table-walker.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0005-LoongArch-Introduce-hardware-page-table-walker.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,252 @@
+From ba40d1853898cf45aa212eb133be367186f3282d Mon Sep 17 00:00:00 2001
+From: Huacai Chen <chenhuacai@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 05/19] LoongArch: Introduce hardware page table walker
+
+Loongson-3A6000 and newer processors have hardware page table walker
+(PTW) support. PTW can handle all fastpaths of TLBI/TLBL/TLBS/TLBM
+exceptions by hardware, software only need to handle slowpaths (page
+faults).
+
+BTW, PTW doesn't append _PAGE_MODIFIED for page table entries, so we
+change pmd_dirty() and pte_dirty() to also check _PAGE_DIRTY for the
+"dirty" attribute.
+
+Signed-off-by: Liang Gao <gaoliang@loongson.cn>
+Signed-off-by: Jun Yi <yijun@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/cpu-features.h |  2 +-
+ arch/loongarch/include/asm/cpu.h          |  2 ++
+ arch/loongarch/include/asm/loongarch.h    |  4 ++++
+ arch/loongarch/include/asm/pgtable.h      |  4 ++--
+ arch/loongarch/include/asm/tlb.h          |  3 +++
+ arch/loongarch/include/uapi/asm/hwcap.h   |  1 +
+ arch/loongarch/kernel/cpu-probe.c         |  4 ++++
+ arch/loongarch/kernel/proc.c              |  1 +
+ arch/loongarch/mm/tlb.c                   | 21 +++++++++++++++++----
+ arch/loongarch/mm/tlbex.S                 | 21 +++++++++++++++++++++
+ 10 files changed, 56 insertions(+), 7 deletions(-)
+
+diff --git a/arch/loongarch/include/asm/cpu-features.h b/arch/loongarch/include/asm/cpu-features.h
+index f6177f133477..2eafe6a6aca8 100644
+--- a/arch/loongarch/include/asm/cpu-features.h
++++ b/arch/loongarch/include/asm/cpu-features.h
+@@ -64,6 +64,6 @@
+ #define cpu_has_eiodecode	cpu_opt(LOONGARCH_CPU_EIODECODE)
+ #define cpu_has_guestid		cpu_opt(LOONGARCH_CPU_GUESTID)
+ #define cpu_has_hypervisor	cpu_opt(LOONGARCH_CPU_HYPERVISOR)
+-
++#define cpu_has_ptw		cpu_opt(LOONGARCH_CPU_PTW)
+ 
+ #endif /* __ASM_CPU_FEATURES_H */
+diff --git a/arch/loongarch/include/asm/cpu.h b/arch/loongarch/include/asm/cpu.h
+index 88773d849e33..48b9f7168bcc 100644
+--- a/arch/loongarch/include/asm/cpu.h
++++ b/arch/loongarch/include/asm/cpu.h
+@@ -98,6 +98,7 @@ enum cpu_type_enum {
+ #define CPU_FEATURE_EIODECODE		23	/* CPU has EXTIOI interrupt pin decode mode */
+ #define CPU_FEATURE_GUESTID		24	/* CPU has GuestID feature */
+ #define CPU_FEATURE_HYPERVISOR		25	/* CPU has hypervisor (running in VM) */
++#define CPU_FEATURE_PTW			26	/* CPU has hardware page table walker */
+ 
+ #define LOONGARCH_CPU_CPUCFG		BIT_ULL(CPU_FEATURE_CPUCFG)
+ #define LOONGARCH_CPU_LAM		BIT_ULL(CPU_FEATURE_LAM)
+@@ -125,5 +126,6 @@ enum cpu_type_enum {
+ #define LOONGARCH_CPU_EIODECODE		BIT_ULL(CPU_FEATURE_EIODECODE)
+ #define LOONGARCH_CPU_GUESTID		BIT_ULL(CPU_FEATURE_GUESTID)
+ #define LOONGARCH_CPU_HYPERVISOR	BIT_ULL(CPU_FEATURE_HYPERVISOR)
++#define LOONGARCH_CPU_PTW		BIT_ULL(CPU_FEATURE_PTW)
+ 
+ #endif /* _ASM_CPU_H */
+diff --git a/arch/loongarch/include/asm/loongarch.h b/arch/loongarch/include/asm/loongarch.h
+index 35e8a52fea11..d55d443b8785 100644
+--- a/arch/loongarch/include/asm/loongarch.h
++++ b/arch/loongarch/include/asm/loongarch.h
+@@ -138,6 +138,7 @@ static inline u32 read_cpucfg(u32 reg)
+ #define  CPUCFG2_MIPSBT			BIT(20)
+ #define  CPUCFG2_LSPW			BIT(21)
+ #define  CPUCFG2_LAM			BIT(22)
++#define  CPUCFG2_PTW			BIT(24)
+ 
+ #define LOONGARCH_CPUCFG3		0x3
+ #define  CPUCFG3_CCDMA			BIT(0)
+@@ -453,6 +454,9 @@ static __always_inline void iocsr_write64(u64 val, u32 reg)
+ #define  CSR_PWCTL0_PTBASE		(_ULCAST_(0x1f) << CSR_PWCTL0_PTBASE_SHIFT)
+ 
+ #define LOONGARCH_CSR_PWCTL1		0x1d	/* PWCtl1 */
++#define  CSR_PWCTL1_PTW_SHIFT		24
++#define  CSR_PWCTL1_PTW_WIDTH		1
++#define  CSR_PWCTL1_PTW			(_ULCAST_(0x1) << CSR_PWCTL1_PTW_SHIFT)
+ #define  CSR_PWCTL1_DIR3WIDTH_SHIFT	18
+ #define  CSR_PWCTL1_DIR3WIDTH_WIDTH	5
+ #define  CSR_PWCTL1_DIR3WIDTH		(_ULCAST_(0x1f) << CSR_PWCTL1_DIR3WIDTH_SHIFT)
+diff --git a/arch/loongarch/include/asm/pgtable.h b/arch/loongarch/include/asm/pgtable.h
+index 9a9f9ff9b709..38afeb7dd58b 100644
+--- a/arch/loongarch/include/asm/pgtable.h
++++ b/arch/loongarch/include/asm/pgtable.h
+@@ -362,7 +362,7 @@ extern pgd_t invalid_pg_dir[];
+  */
+ static inline int pte_write(pte_t pte)	{ return pte_val(pte) & _PAGE_WRITE; }
+ static inline int pte_young(pte_t pte)	{ return pte_val(pte) & _PAGE_ACCESSED; }
+-static inline int pte_dirty(pte_t pte)	{ return pte_val(pte) & _PAGE_MODIFIED; }
++static inline int pte_dirty(pte_t pte)	{ return pte_val(pte) & (_PAGE_DIRTY | _PAGE_MODIFIED); }
+ 
+ static inline pte_t pte_mkold(pte_t pte)
+ {
+@@ -506,7 +506,7 @@ static inline pmd_t pmd_wrprotect(pmd_t pmd)
+ 
+ static inline int pmd_dirty(pmd_t pmd)
+ {
+-	return !!(pmd_val(pmd) & _PAGE_MODIFIED);
++	return !!(pmd_val(pmd) & (_PAGE_DIRTY | _PAGE_MODIFIED));
+ }
+ 
+ static inline pmd_t pmd_mkclean(pmd_t pmd)
+diff --git a/arch/loongarch/include/asm/tlb.h b/arch/loongarch/include/asm/tlb.h
+index f5e4deb97402..0dc9ee2b05d2 100644
+--- a/arch/loongarch/include/asm/tlb.h
++++ b/arch/loongarch/include/asm/tlb.h
+@@ -163,6 +163,9 @@ extern void handle_tlb_store(void);
+ extern void handle_tlb_modify(void);
+ extern void handle_tlb_refill(void);
+ extern void handle_tlb_protect(void);
++extern void handle_tlb_load_ptw(void);
++extern void handle_tlb_store_ptw(void);
++extern void handle_tlb_modify_ptw(void);
+ 
+ extern void dump_tlb_all(void);
+ extern void dump_tlb_regs(void);
+diff --git a/arch/loongarch/include/uapi/asm/hwcap.h b/arch/loongarch/include/uapi/asm/hwcap.h
+index 8840b72fa8e8..6955a7cb2c65 100644
+--- a/arch/loongarch/include/uapi/asm/hwcap.h
++++ b/arch/loongarch/include/uapi/asm/hwcap.h
+@@ -16,5 +16,6 @@
+ #define HWCAP_LOONGARCH_LBT_X86		(1 << 10)
+ #define HWCAP_LOONGARCH_LBT_ARM		(1 << 11)
+ #define HWCAP_LOONGARCH_LBT_MIPS	(1 << 12)
++#define HWCAP_LOONGARCH_PTW		(1 << 13)
+ 
+ #endif /* _UAPI_ASM_HWCAP_H */
+diff --git a/arch/loongarch/kernel/cpu-probe.c b/arch/loongarch/kernel/cpu-probe.c
+index f42acc6c8df6..e925579c7a71 100644
+--- a/arch/loongarch/kernel/cpu-probe.c
++++ b/arch/loongarch/kernel/cpu-probe.c
+@@ -136,6 +136,10 @@ static void cpu_probe_common(struct cpuinfo_loongarch *c)
+ 		c->options |= LOONGARCH_CPU_CRYPTO;
+ 		elf_hwcap |= HWCAP_LOONGARCH_CRYPTO;
+ 	}
++	if (config & CPUCFG2_PTW) {
++		c->options |= LOONGARCH_CPU_PTW;
++		elf_hwcap |= HWCAP_LOONGARCH_PTW;
++	}
+ 	if (config & CPUCFG2_LVZP) {
+ 		c->options |= LOONGARCH_CPU_LVZ;
+ 		elf_hwcap |= HWCAP_LOONGARCH_LVZ;
+diff --git a/arch/loongarch/kernel/proc.c b/arch/loongarch/kernel/proc.c
+index d4b270630bb5..0d33cbc47e51 100644
+--- a/arch/loongarch/kernel/proc.c
++++ b/arch/loongarch/kernel/proc.c
+@@ -80,6 +80,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
+ 	if (cpu_has_crc32)	seq_printf(m, " crc32");
+ 	if (cpu_has_complex)	seq_printf(m, " complex");
+ 	if (cpu_has_crypto)	seq_printf(m, " crypto");
++	if (cpu_has_ptw)	seq_printf(m, " ptw");
+ 	if (cpu_has_lvz)	seq_printf(m, " lvz");
+ 	if (cpu_has_lbt_x86)	seq_printf(m, " lbt_x86");
+ 	if (cpu_has_lbt_arm)	seq_printf(m, " lbt_arm");
+diff --git a/arch/loongarch/mm/tlb.c b/arch/loongarch/mm/tlb.c
+index 8bad6b0cff59..00bb563e3c89 100644
+--- a/arch/loongarch/mm/tlb.c
++++ b/arch/loongarch/mm/tlb.c
+@@ -167,6 +167,9 @@ void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t *ptep
+ 	int idx;
+ 	unsigned long flags;
+ 
++	if (cpu_has_ptw)
++		return;
++
+ 	/*
+ 	 * Handle debugger faulting in for debugee.
+ 	 */
+@@ -222,6 +225,9 @@ static void setup_ptwalker(void)
+ 	pwctl0 = pte_i | pte_w << 5 | pmd_i << 10 | pmd_w << 15 | pud_i << 20 | pud_w << 25;
+ 	pwctl1 = pgd_i | pgd_w << 6;
+ 
++	if (cpu_has_ptw)
++		pwctl1 |= CSR_PWCTL1_PTW;
++
+ 	csr_write64(pwctl0, LOONGARCH_CSR_PWCTL0);
+ 	csr_write64(pwctl1, LOONGARCH_CSR_PWCTL1);
+ 	csr_write64((long)swapper_pg_dir, LOONGARCH_CSR_PGDH);
+@@ -264,10 +270,17 @@ void setup_tlb_handler(int cpu)
+ 	if (cpu == 0) {
+ 		memcpy((void *)tlbrentry, handle_tlb_refill, 0x80);
+ 		local_flush_icache_range(tlbrentry, tlbrentry + 0x80);
+-		set_handler(EXCCODE_TLBI * VECSIZE, handle_tlb_load, VECSIZE);
+-		set_handler(EXCCODE_TLBL * VECSIZE, handle_tlb_load, VECSIZE);
+-		set_handler(EXCCODE_TLBS * VECSIZE, handle_tlb_store, VECSIZE);
+-		set_handler(EXCCODE_TLBM * VECSIZE, handle_tlb_modify, VECSIZE);
++		if (!cpu_has_ptw) {
++			set_handler(EXCCODE_TLBI * VECSIZE, handle_tlb_load, VECSIZE);
++			set_handler(EXCCODE_TLBL * VECSIZE, handle_tlb_load, VECSIZE);
++			set_handler(EXCCODE_TLBS * VECSIZE, handle_tlb_store, VECSIZE);
++			set_handler(EXCCODE_TLBM * VECSIZE, handle_tlb_modify, VECSIZE);
++		} else {
++			set_handler(EXCCODE_TLBI * VECSIZE, handle_tlb_load_ptw, VECSIZE);
++			set_handler(EXCCODE_TLBL * VECSIZE, handle_tlb_load_ptw, VECSIZE);
++			set_handler(EXCCODE_TLBS * VECSIZE, handle_tlb_store_ptw, VECSIZE);
++			set_handler(EXCCODE_TLBM * VECSIZE, handle_tlb_modify_ptw, VECSIZE);
++		}
+ 		set_handler(EXCCODE_TLBNR * VECSIZE, handle_tlb_protect, VECSIZE);
+ 		set_handler(EXCCODE_TLBNX * VECSIZE, handle_tlb_protect, VECSIZE);
+ 		set_handler(EXCCODE_TLBPE * VECSIZE, handle_tlb_protect, VECSIZE);
+diff --git a/arch/loongarch/mm/tlbex.S b/arch/loongarch/mm/tlbex.S
+index 240ced55586e..4ad78703de6f 100644
+--- a/arch/loongarch/mm/tlbex.S
++++ b/arch/loongarch/mm/tlbex.S
+@@ -190,6 +190,13 @@ nopage_tlb_load:
+ 	jr		t0
+ SYM_FUNC_END(handle_tlb_load)
+ 
++SYM_FUNC_START(handle_tlb_load_ptw)
++	csrwr		t0, LOONGARCH_CSR_KS0
++	csrwr		t1, LOONGARCH_CSR_KS1
++	la_abs		t0, tlb_do_page_fault_0
++	jr		t0
++SYM_FUNC_END(handle_tlb_load_ptw)
++
+ SYM_FUNC_START(handle_tlb_store)
+ 	csrwr		t0, EXCEPTION_KS0
+ 	csrwr		t1, EXCEPTION_KS1
+@@ -339,6 +346,13 @@ nopage_tlb_store:
+ 	jr		t0
+ SYM_FUNC_END(handle_tlb_store)
+ 
++SYM_FUNC_START(handle_tlb_store_ptw)
++	csrwr		t0, LOONGARCH_CSR_KS0
++	csrwr		t1, LOONGARCH_CSR_KS1
++	la_abs		t0, tlb_do_page_fault_1
++	jr		t0
++SYM_FUNC_END(handle_tlb_store_ptw)
++
+ SYM_FUNC_START(handle_tlb_modify)
+ 	csrwr		t0, EXCEPTION_KS0
+ 	csrwr		t1, EXCEPTION_KS1
+@@ -486,6 +500,13 @@ nopage_tlb_modify:
+ 	jr		t0
+ SYM_FUNC_END(handle_tlb_modify)
+ 
++SYM_FUNC_START(handle_tlb_modify_ptw)
++	csrwr		t0, LOONGARCH_CSR_KS0
++	csrwr		t1, LOONGARCH_CSR_KS1
++	la_abs		t0, tlb_do_page_fault_1
++	jr		t0
++SYM_FUNC_END(handle_tlb_modify_ptw)
++
+ SYM_FUNC_START(handle_tlb_refill)
+ 	csrwr		t0, LOONGARCH_CSR_TLBRSAVE
+ 	csrrd		t0, LOONGARCH_CSR_PGD
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0006-LoongArch-Export-some-arch-specific-pm-interfaces.patch b/debian/patches/loongarch/0006-LoongArch-Export-some-arch-specific-pm-interfaces.patch
--- a/debian/patches/loongarch/0006-LoongArch-Export-some-arch-specific-pm-interfaces.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0006-LoongArch-Export-some-arch-specific-pm-interfaces.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,100 @@
+From 76569ab5c8c93400c2021b57ba6f4663b15607f0 Mon Sep 17 00:00:00 2001
+From: Yinbo Zhu <zhuyinbo@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 06/19] LoongArch: Export some arch-specific pm interfaces
+
+Some PMC (Power Management Controllers) need to support DTS and will use
+the suspend interfaces thus this patch was to export such interfaces for
+their use.
+
+Signed-off-by: Yinbo Zhu <zhuyinbo@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/acpi.h    |  4 ++--
+ arch/loongarch/include/asm/suspend.h | 10 ++++++++++
+ arch/loongarch/power/suspend.c       |  8 ++++----
+ 3 files changed, 16 insertions(+), 6 deletions(-)
+ create mode 100644 arch/loongarch/include/asm/suspend.h
+
+diff --git a/arch/loongarch/include/asm/acpi.h b/arch/loongarch/include/asm/acpi.h
+index 5c78b5d2bfb7..8de6c4b83a61 100644
+--- a/arch/loongarch/include/asm/acpi.h
++++ b/arch/loongarch/include/asm/acpi.h
+@@ -8,6 +8,8 @@
+ #ifndef _ASM_LOONGARCH_ACPI_H
+ #define _ASM_LOONGARCH_ACPI_H
+ 
++#include <asm/suspend.h>
++
+ #ifdef CONFIG_ACPI
+ extern int acpi_strict;
+ extern int acpi_disabled;
+@@ -46,12 +48,10 @@ static inline u32 get_acpi_id_for_cpu(unsigned int cpu)
+ 
+ extern int loongarch_acpi_suspend(void);
+ extern int (*acpi_suspend_lowlevel)(void);
+-extern void loongarch_suspend_enter(void);
+ 
+ static inline unsigned long acpi_get_wakeup_address(void)
+ {
+ #ifdef CONFIG_SUSPEND
+-	extern void loongarch_wakeup_start(void);
+ 	return (unsigned long)loongarch_wakeup_start;
+ #endif
+ 	return 0UL;
+diff --git a/arch/loongarch/include/asm/suspend.h b/arch/loongarch/include/asm/suspend.h
+new file mode 100644
+index 000000000000..4025c9d5d7cf
+--- /dev/null
++++ b/arch/loongarch/include/asm/suspend.h
+@@ -0,0 +1,10 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++#ifndef __ASM_SUSPEND_H
++#define __ASM_SUSPEND_H
++
++void loongarch_common_suspend(void);
++void loongarch_common_resume(void);
++void loongarch_suspend_enter(void);
++void loongarch_wakeup_start(void);
++
++#endif
+diff --git a/arch/loongarch/power/suspend.c b/arch/loongarch/power/suspend.c
+index 5e19733e5e05..166d9e06a64b 100644
+--- a/arch/loongarch/power/suspend.c
++++ b/arch/loongarch/power/suspend.c
+@@ -27,7 +27,7 @@ struct saved_registers {
+ };
+ static struct saved_registers saved_regs;
+ 
+-static void arch_common_suspend(void)
++void loongarch_common_suspend(void)
+ {
+ 	save_counter();
+ 	saved_regs.pgd = csr_read64(LOONGARCH_CSR_PGDL);
+@@ -40,7 +40,7 @@ static void arch_common_suspend(void)
+ 	loongarch_suspend_addr = loongson_sysconf.suspend_addr;
+ }
+ 
+-static void arch_common_resume(void)
++void loongarch_common_resume(void)
+ {
+ 	sync_counter();
+ 	local_flush_tlb_all();
+@@ -62,12 +62,12 @@ int loongarch_acpi_suspend(void)
+ 	enable_gpe_wakeup();
+ 	enable_pci_wakeup();
+ 
+-	arch_common_suspend();
++	loongarch_common_suspend();
+ 
+ 	/* processor specific suspend */
+ 	loongarch_suspend_enter();
+ 
+-	arch_common_resume();
++	loongarch_common_resume();
+ 
+ 	return 0;
+ }
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0007-LoongArch-Select-HAVE_DEBUG_KMEMLEAK-to-support-kmem.patch b/debian/patches/loongarch/0007-LoongArch-Select-HAVE_DEBUG_KMEMLEAK-to-support-kmem.patch
--- a/debian/patches/loongarch/0007-LoongArch-Select-HAVE_DEBUG_KMEMLEAK-to-support-kmem.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0007-LoongArch-Select-HAVE_DEBUG_KMEMLEAK-to-support-kmem.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,46 @@
+From 8fe2e0d96bda340174821cf2ac00b4d4ebc3239f Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 07/19] LoongArch: Select HAVE_DEBUG_KMEMLEAK to support
+ kmemleak
+
+We can see that DEBUG_KMEMLEAK depends on HAVE_DEBUG_KMEMLEAK after
+commit b69ec42b1b19 ("Kconfig: clean up the long arch list for the
+DEBUG_KMEMLEAK config option"), just select HAVE_DEBUG_KMEMLEAK to
+support kmemleak on LoongArch.
+
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ Documentation/features/debug/kmemleak/arch-support.txt | 2 +-
+ arch/loongarch/Kconfig                                 | 1 +
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/Documentation/features/debug/kmemleak/arch-support.txt b/Documentation/features/debug/kmemleak/arch-support.txt
+index 0cfa5f0e4db1..4e205ef70363 100644
+--- a/Documentation/features/debug/kmemleak/arch-support.txt
++++ b/Documentation/features/debug/kmemleak/arch-support.txt
+@@ -13,7 +13,7 @@
+     |        csky: |  ok  |
+     |     hexagon: | TODO |
+     |        ia64: | TODO |
+-    |   loongarch: | TODO |
++    |   loongarch: |  ok  |
+     |        m68k: | TODO |
+     |  microblaze: |  ok  |
+     |        mips: |  ok  |
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index dda6475ea694..e700790ffe33 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -92,6 +92,7 @@ config LOONGARCH
+ 	select HAVE_ASM_MODVERSIONS
+ 	select HAVE_CONTEXT_TRACKING_USER
+ 	select HAVE_C_RECORDMCOUNT
++	select HAVE_DEBUG_KMEMLEAK
+ 	select HAVE_DEBUG_STACKOVERFLOW
+ 	select HAVE_DMA_CONTIGUOUS
+ 	select HAVE_DYNAMIC_FTRACE
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0008-LoongArch-Add-jump-label-implementation.patch b/debian/patches/loongarch/0008-LoongArch-Add-jump-label-implementation.patch
--- a/debian/patches/loongarch/0008-LoongArch-Add-jump-label-implementation.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0008-LoongArch-Add-jump-label-implementation.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,144 @@
+From cd12ce3d02dcc6749a60e8798cdfa1a08dde0c8b Mon Sep 17 00:00:00 2001
+From: Youling Tang <tangyouling@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 08/19] LoongArch: Add jump-label implementation
+
+Add support for jump labels based on the ARM64 version.
+
+Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
+Signed-off-by: Youling Tang <tangyouling@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ .../core/jump-labels/arch-support.txt         |  2 +-
+ arch/loongarch/Kconfig                        |  2 +
+ arch/loongarch/include/asm/jump_label.h       | 50 +++++++++++++++++++
+ arch/loongarch/kernel/Makefile                |  2 +
+ arch/loongarch/kernel/jump_label.c            | 22 ++++++++
+ 5 files changed, 77 insertions(+), 1 deletion(-)
+ create mode 100644 arch/loongarch/include/asm/jump_label.h
+ create mode 100644 arch/loongarch/kernel/jump_label.c
+
+diff --git a/Documentation/features/core/jump-labels/arch-support.txt b/Documentation/features/core/jump-labels/arch-support.txt
+index 2328eada3a49..94d9dece580f 100644
+--- a/Documentation/features/core/jump-labels/arch-support.txt
++++ b/Documentation/features/core/jump-labels/arch-support.txt
+@@ -13,7 +13,7 @@
+     |        csky: |  ok  |
+     |     hexagon: | TODO |
+     |        ia64: | TODO |
+-    |   loongarch: | TODO |
++    |   loongarch: |  ok  |
+     |        m68k: | TODO |
+     |  microblaze: | TODO |
+     |        mips: |  ok  |
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index e700790ffe33..9b701b3df253 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -85,6 +85,8 @@ config LOONGARCH
+ 	select GPIOLIB
+ 	select HAS_IOPORT
+ 	select HAVE_ARCH_AUDITSYSCALL
++	select HAVE_ARCH_JUMP_LABEL
++	select HAVE_ARCH_JUMP_LABEL_RELATIVE
+ 	select HAVE_ARCH_MMAP_RND_BITS if MMU
+ 	select HAVE_ARCH_SECCOMP_FILTER
+ 	select HAVE_ARCH_TRACEHOOK
+diff --git a/arch/loongarch/include/asm/jump_label.h b/arch/loongarch/include/asm/jump_label.h
+new file mode 100644
+index 000000000000..3cea299a5ef5
+--- /dev/null
++++ b/arch/loongarch/include/asm/jump_label.h
+@@ -0,0 +1,50 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++/*
++ * Copyright (C) 2023 Loongson Technology Corporation Limited
++ *
++ * Based on arch/arm64/include/asm/jump_label.h
++ */
++#ifndef __ASM_JUMP_LABEL_H
++#define __ASM_JUMP_LABEL_H
++
++#ifndef __ASSEMBLY__
++
++#include <linux/types.h>
++
++#define JUMP_LABEL_NOP_SIZE	4
++
++#define JUMP_TABLE_ENTRY				\
++	 ".pushsection	__jump_table, \"aw\"	\n\t"	\
++	 ".align	3			\n\t"	\
++	 ".long		1b - ., %l[l_yes] - .	\n\t"	\
++	 ".quad		%0 - .			\n\t"	\
++	 ".popsection				\n\t"
++
++static __always_inline bool arch_static_branch(struct static_key * const key, const bool branch)
++{
++	asm_volatile_goto(
++		"1:	nop			\n\t"
++		JUMP_TABLE_ENTRY
++		:  :  "i"(&((char *)key)[branch]) :  : l_yes);
++
++	return false;
++
++l_yes:
++	return true;
++}
++
++static __always_inline bool arch_static_branch_jump(struct static_key * const key, const bool branch)
++{
++	asm_volatile_goto(
++		"1:	b	%l[l_yes]	\n\t"
++		JUMP_TABLE_ENTRY
++		:  :  "i"(&((char *)key)[branch]) :  : l_yes);
++
++	return false;
++
++l_yes:
++	return true;
++}
++
++#endif  /* __ASSEMBLY__ */
++#endif	/* __ASM_JUMP_LABEL_H */
+diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
+index 9a72d91cd104..64ea76f60e2c 100644
+--- a/arch/loongarch/kernel/Makefile
++++ b/arch/loongarch/kernel/Makefile
+@@ -54,4 +54,6 @@ obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
+ 
+ obj-$(CONFIG_KPROBES)		+= kprobes.o kprobes_trampoline.o
+ 
++obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o
++
+ CPPFLAGS_vmlinux.lds		:= $(KBUILD_CFLAGS)
+diff --git a/arch/loongarch/kernel/jump_label.c b/arch/loongarch/kernel/jump_label.c
+new file mode 100644
+index 000000000000..31891214b767
+--- /dev/null
++++ b/arch/loongarch/kernel/jump_label.c
+@@ -0,0 +1,22 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (C) 2023 Loongson Technology Corporation Limited
++ *
++ * Based on arch/arm64/kernel/jump_label.c
++ */
++#include <linux/kernel.h>
++#include <linux/jump_label.h>
++#include <asm/inst.h>
++
++void arch_jump_label_transform(struct jump_entry *entry, enum jump_label_type type)
++{
++	u32 insn;
++	void *addr = (void *)jump_entry_code(entry);
++
++	if (type == JUMP_LABEL_JMP)
++		insn = larch_insn_gen_b(jump_entry_code(entry), jump_entry_target(entry));
++	else
++		insn = larch_insn_gen_nop();
++
++	larch_insn_patch_text(addr, insn);
++}
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0009-LoongArch-Replace-kretprobe-with-rethook.patch b/debian/patches/loongarch/0009-LoongArch-Replace-kretprobe-with-rethook.patch
--- a/debian/patches/loongarch/0009-LoongArch-Replace-kretprobe-with-rethook.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0009-LoongArch-Replace-kretprobe-with-rethook.patch	2023-06-29 16:16:11.280252665 +0800
@@ -0,0 +1,192 @@
+From 3668453cfa85016c8755eaf0e7fa0e450cc7a1c1 Mon Sep 17 00:00:00 2001
+From: Haoran Jiang <jianghaoran@kylinos.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 09/19] LoongArch: Replace kretprobe with rethook
+
+This is an adaptation of commit f3a112c0c40d ("x86,rethook,kprobes:
+Replace kretprobe with rethook on x86") and commit b57c2f124098 ("riscv:
+add riscv rethook implementation") to LoongArch. Mainly refer to commit
+b57c2f124098 ("riscv: add riscv rethook implementation").
+
+Replaces the kretprobe code with rethook on LoongArch. With this patch,
+kretprobe on LoongArch uses the rethook instead of kretprobe specific
+trampoline code.
+
+Signed-off-by: Haoran Jiang <jianghaoran@kylinos.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/Kconfig                        |  1 +
+ arch/loongarch/include/asm/kprobes.h          |  3 --
+ arch/loongarch/kernel/Makefile                |  5 +++-
+ arch/loongarch/kernel/kprobes.c               | 21 --------------
+ arch/loongarch/kernel/rethook.c               | 28 +++++++++++++++++++
+ arch/loongarch/kernel/rethook.h               |  8 ++++++
+ ...obes_trampoline.S => rethook_trampoline.S} |  6 ++--
+ 7 files changed, 44 insertions(+), 28 deletions(-)
+ create mode 100644 arch/loongarch/kernel/rethook.c
+ create mode 100644 arch/loongarch/kernel/rethook.h
+ rename arch/loongarch/kernel/{kprobes_trampoline.S => rethook_trampoline.S} (93%)
+
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index 9b701b3df253..ba2a1ecb7ef0 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -125,6 +125,7 @@ config LOONGARCH
+ 	select HAVE_PERF_REGS
+ 	select HAVE_PERF_USER_STACK_DUMP
+ 	select HAVE_REGS_AND_STACK_ACCESS_API
++	select HAVE_RETHOOK
+ 	select HAVE_RSEQ
+ 	select HAVE_SAMPLE_FTRACE_DIRECT
+ 	select HAVE_SAMPLE_FTRACE_DIRECT_MULTI
+diff --git a/arch/loongarch/include/asm/kprobes.h b/arch/loongarch/include/asm/kprobes.h
+index 798020ae02c6..7b9fc3ed71c3 100644
+--- a/arch/loongarch/include/asm/kprobes.h
++++ b/arch/loongarch/include/asm/kprobes.h
+@@ -49,9 +49,6 @@ bool kprobe_fault_handler(struct pt_regs *regs, int trapnr);
+ bool kprobe_breakpoint_handler(struct pt_regs *regs);
+ bool kprobe_singlestep_handler(struct pt_regs *regs);
+ 
+-void __kretprobe_trampoline(void);
+-void *trampoline_probe_handler(struct pt_regs *regs);
+-
+ #else /* !CONFIG_KPROBES */
+ 
+ static inline bool kprobe_breakpoint_handler(struct pt_regs *regs) { return false; }
+diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
+index 64ea76f60e2c..1061c36f5ad5 100644
+--- a/arch/loongarch/kernel/Makefile
++++ b/arch/loongarch/kernel/Makefile
+@@ -28,6 +28,8 @@ ifdef CONFIG_FUNCTION_TRACER
+   CFLAGS_REMOVE_inst.o = $(CC_FLAGS_FTRACE)
+   CFLAGS_REMOVE_time.o = $(CC_FLAGS_FTRACE)
+   CFLAGS_REMOVE_perf_event.o = $(CC_FLAGS_FTRACE)
++  CFLAGS_REMOVE_rethook.o = $(CC_FLAGS_FTRACE)
++  CFLAGS_REMOVE_rethook_trampoline.o = $(CC_FLAGS_FTRACE)
+ endif
+ 
+ obj-$(CONFIG_MODULES)		+= module.o module-sections.o
+@@ -52,7 +54,8 @@ obj-$(CONFIG_UNWINDER_PROLOGUE) += unwind_prologue.o
+ obj-$(CONFIG_PERF_EVENTS)	+= perf_event.o perf_regs.o
+ obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
+ 
+-obj-$(CONFIG_KPROBES)		+= kprobes.o kprobes_trampoline.o
++obj-$(CONFIG_KPROBES)		+= kprobes.o
++obj-$(CONFIG_RETHOOK)		+= rethook.o rethook_trampoline.o
+ 
+ obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o
+ 
+diff --git a/arch/loongarch/kernel/kprobes.c b/arch/loongarch/kernel/kprobes.c
+index 56c8c4b09a42..83467232ca3c 100644
+--- a/arch/loongarch/kernel/kprobes.c
++++ b/arch/loongarch/kernel/kprobes.c
+@@ -378,27 +378,6 @@ int __init arch_init_kprobes(void)
+ 	return 0;
+ }
+ 
+-/* ASM function that handles the kretprobes must not be probed */
+-NOKPROBE_SYMBOL(__kretprobe_trampoline);
+-
+-/* Called from __kretprobe_trampoline */
+-void __used *trampoline_probe_handler(struct pt_regs *regs)
+-{
+-	return (void *)kretprobe_trampoline_handler(regs, NULL);
+-}
+-NOKPROBE_SYMBOL(trampoline_probe_handler);
+-
+-void arch_prepare_kretprobe(struct kretprobe_instance *ri,
+-			    struct pt_regs *regs)
+-{
+-	ri->ret_addr = (kprobe_opcode_t *)regs->regs[1];
+-	ri->fp = NULL;
+-
+-	/* Replace the return addr with trampoline addr */
+-	regs->regs[1] = (unsigned long)&__kretprobe_trampoline;
+-}
+-NOKPROBE_SYMBOL(arch_prepare_kretprobe);
+-
+ int arch_trampoline_kprobe(struct kprobe *p)
+ {
+ 	return 0;
+diff --git a/arch/loongarch/kernel/rethook.c b/arch/loongarch/kernel/rethook.c
+new file mode 100644
+index 000000000000..db1c5f5024fd
+--- /dev/null
++++ b/arch/loongarch/kernel/rethook.c
+@@ -0,0 +1,28 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Generic return hook for LoongArch.
++ */
++
++#include <linux/kprobes.h>
++#include <linux/rethook.h>
++#include "rethook.h"
++
++/* This is called from arch_rethook_trampoline() */
++unsigned long __used arch_rethook_trampoline_callback(struct pt_regs *regs)
++{
++	return rethook_trampoline_handler(regs, 0);
++}
++NOKPROBE_SYMBOL(arch_rethook_trampoline_callback);
++
++void arch_rethook_prepare(struct rethook_node *rhn, struct pt_regs *regs, bool mcount)
++{
++	rhn->frame = 0;
++	rhn->ret_addr = regs->regs[1];
++
++	/* replace return addr with trampoline */
++	regs->regs[1] = (unsigned long)arch_rethook_trampoline;
++}
++NOKPROBE_SYMBOL(arch_rethook_prepare);
++
++/* ASM function that handles the rethook must not be probed itself */
++NOKPROBE_SYMBOL(arch_rethook_trampoline);
+diff --git a/arch/loongarch/kernel/rethook.h b/arch/loongarch/kernel/rethook.h
+new file mode 100644
+index 000000000000..3f1c1edf0d0b
+--- /dev/null
++++ b/arch/loongarch/kernel/rethook.h
+@@ -0,0 +1,8 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++#ifndef __LOONGARCH_RETHOOK_H
++#define __LOONGARCH_RETHOOK_H
++
++unsigned long arch_rethook_trampoline_callback(struct pt_regs *regs);
++void arch_rethook_prepare(struct rethook_node *rhn, struct pt_regs *regs, bool mcount);
++
++#endif
+diff --git a/arch/loongarch/kernel/kprobes_trampoline.S b/arch/loongarch/kernel/rethook_trampoline.S
+similarity index 93%
+rename from arch/loongarch/kernel/kprobes_trampoline.S
+rename to arch/loongarch/kernel/rethook_trampoline.S
+index af94b0d213fa..bd5772c96338 100644
+--- a/arch/loongarch/kernel/kprobes_trampoline.S
++++ b/arch/loongarch/kernel/rethook_trampoline.S
+@@ -75,7 +75,7 @@
+ 	csrxchg t0, t1, LOONGARCH_CSR_CRMD
+ 	.endm
+ 
+-SYM_CODE_START(__kretprobe_trampoline)
++SYM_CODE_START(arch_rethook_trampoline)
+ 	addi.d	sp, sp, -PT_SIZE
+ 	save_all_base_regs
+ 
+@@ -84,7 +84,7 @@ SYM_CODE_START(__kretprobe_trampoline)
+ 
+ 	move a0, sp /* pt_regs */
+ 
+-	bl trampoline_probe_handler
++	bl arch_rethook_trampoline_callback
+ 
+ 	/* use the result as the return-address */
+ 	move ra, a0
+@@ -93,4 +93,4 @@ SYM_CODE_START(__kretprobe_trampoline)
+ 	addi.d	sp, sp, PT_SIZE
+ 
+ 	jr ra
+-SYM_CODE_END(__kretprobe_trampoline)
++SYM_CODE_END(arch_rethook_trampoline)
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0010-LoongArch-Move-three-functions-from-kprobes.c-to-ins.patch b/debian/patches/loongarch/0010-LoongArch-Move-three-functions-from-kprobes.c-to-ins.patch
--- a/debian/patches/loongarch/0010-LoongArch-Move-three-functions-from-kprobes.c-to-ins.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0010-LoongArch-Move-three-functions-from-kprobes.c-to-ins.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,158 @@
+From 7869fed474ea0714467ebf9cf2798365d7bbc019 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 10/19] LoongArch: Move three functions from kprobes.c to
+ inst.c
+
+The three functions insns_not_supported(), insns_need_simulation() and
+arch_simulate_insn() will be used for uprobes, move them from kprobes.c
+to inst.c, this is preparation for later patch, no functionality change.
+
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/inst.h |  4 +++
+ arch/loongarch/kernel/inst.c      | 39 ++++++++++++++++++++++++++
+ arch/loongarch/kernel/kprobes.c   | 46 ++-----------------------------
+ 3 files changed, 45 insertions(+), 44 deletions(-)
+
+diff --git a/arch/loongarch/include/asm/inst.h b/arch/loongarch/include/asm/inst.h
+index b09887ffcd15..c9e54351bfce 100644
+--- a/arch/loongarch/include/asm/inst.h
++++ b/arch/loongarch/include/asm/inst.h
+@@ -435,6 +435,10 @@ static inline bool is_self_loop_ins(union loongarch_instruction *ip, struct pt_r
+ void simu_pc(struct pt_regs *regs, union loongarch_instruction insn);
+ void simu_branch(struct pt_regs *regs, union loongarch_instruction insn);
+ 
++bool insns_not_supported(union loongarch_instruction insn);
++bool insns_need_simulation(union loongarch_instruction insn);
++void arch_simulate_insn(union loongarch_instruction insn, struct pt_regs *regs);
++
+ int larch_insn_read(void *addr, u32 *insnp);
+ int larch_insn_write(void *addr, u32 insn);
+ int larch_insn_patch_text(void *addr, u32 insn);
+diff --git a/arch/loongarch/kernel/inst.c b/arch/loongarch/kernel/inst.c
+index 258ef267cd30..6f61956972c1 100644
+--- a/arch/loongarch/kernel/inst.c
++++ b/arch/loongarch/kernel/inst.c
+@@ -133,6 +133,45 @@ void simu_branch(struct pt_regs *regs, union loongarch_instruction insn)
+ 	}
+ }
+ 
++bool insns_not_supported(union loongarch_instruction insn)
++{
++	switch (insn.reg2i14_format.opcode) {
++	case llw_op:
++	case lld_op:
++	case scw_op:
++	case scd_op:
++		pr_notice("ll and sc instructions are not supported\n");
++		return true;
++	}
++
++	switch (insn.reg1i21_format.opcode) {
++	case bceqz_op:
++		pr_notice("bceqz and bcnez instructions are not supported\n");
++		return true;
++	}
++
++	return false;
++}
++
++bool insns_need_simulation(union loongarch_instruction insn)
++{
++	if (is_pc_ins(&insn))
++		return true;
++
++	if (is_branch_ins(&insn))
++		return true;
++
++	return false;
++}
++
++void arch_simulate_insn(union loongarch_instruction insn, struct pt_regs *regs)
++{
++	if (is_pc_ins(&insn))
++		simu_pc(regs, insn);
++	else if (is_branch_ins(&insn))
++		simu_branch(regs, insn);
++}
++
+ int larch_insn_read(void *addr, u32 *insnp)
+ {
+ 	int ret;
+diff --git a/arch/loongarch/kernel/kprobes.c b/arch/loongarch/kernel/kprobes.c
+index 83467232ca3c..4c13c4431b67 100644
+--- a/arch/loongarch/kernel/kprobes.c
++++ b/arch/loongarch/kernel/kprobes.c
+@@ -21,48 +21,6 @@ static const union loongarch_instruction singlestep_insn = {
+ DEFINE_PER_CPU(struct kprobe *, current_kprobe);
+ DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
+ 
+-static bool insns_not_supported(union loongarch_instruction insn)
+-{
+-	switch (insn.reg2i14_format.opcode) {
+-	case llw_op:
+-	case lld_op:
+-	case scw_op:
+-	case scd_op:
+-		pr_notice("kprobe: ll and sc instructions are not supported\n");
+-		return true;
+-	}
+-
+-	switch (insn.reg1i21_format.opcode) {
+-	case bceqz_op:
+-		pr_notice("kprobe: bceqz and bcnez instructions are not supported\n");
+-		return true;
+-	}
+-
+-	return false;
+-}
+-NOKPROBE_SYMBOL(insns_not_supported);
+-
+-static bool insns_need_simulation(struct kprobe *p)
+-{
+-	if (is_pc_ins(&p->opcode))
+-		return true;
+-
+-	if (is_branch_ins(&p->opcode))
+-		return true;
+-
+-	return false;
+-}
+-NOKPROBE_SYMBOL(insns_need_simulation);
+-
+-static void arch_simulate_insn(struct kprobe *p, struct pt_regs *regs)
+-{
+-	if (is_pc_ins(&p->opcode))
+-		simu_pc(regs, p->opcode);
+-	else if (is_branch_ins(&p->opcode))
+-		simu_branch(regs, p->opcode);
+-}
+-NOKPROBE_SYMBOL(arch_simulate_insn);
+-
+ static void arch_prepare_ss_slot(struct kprobe *p)
+ {
+ 	p->ainsn.insn[0] = *p->addr;
+@@ -89,7 +47,7 @@ int arch_prepare_kprobe(struct kprobe *p)
+ 	if (insns_not_supported(p->opcode))
+ 		return -EINVAL;
+ 
+-	if (insns_need_simulation(p)) {
++	if (insns_need_simulation(p->opcode)) {
+ 		p->ainsn.insn = NULL;
+ 	} else {
+ 		p->ainsn.insn = get_insn_slot();
+@@ -220,7 +178,7 @@ static void setup_singlestep(struct kprobe *p, struct pt_regs *regs,
+ 		regs->csr_era = (unsigned long)p->ainsn.insn;
+ 	} else {
+ 		/* simulate single steping */
+-		arch_simulate_insn(p, regs);
++		arch_simulate_insn(p->opcode, regs);
+ 		/* now go for post processing */
+ 		post_kprobe_handler(p, kcb, regs);
+ 	}
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0011-LoongArch-Check-AMO-instructions-in-insns_not_suppor.patch b/debian/patches/loongarch/0011-LoongArch-Check-AMO-instructions-in-insns_not_suppor.patch
--- a/debian/patches/loongarch/0011-LoongArch-Check-AMO-instructions-in-insns_not_suppor.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0011-LoongArch-Check-AMO-instructions-in-insns_not_suppor.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,76 @@
+From 61324417655f0ceb5cf249e14b2399554572e0a1 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 11/19] LoongArch: Check AMO instructions in
+ insns_not_supported()
+
+Like llsc instructions, the atomic memory access instructions shouldn't
+be supported for probing, so check them in insns_not_supported().
+
+Closes: https://lore.kernel.org/all/SY4P282MB351877A70A0333C790FE85A5C09C9@SY4P282MB3518.AUSP282.PROD.OUTLOOK.COM/
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Reported-by: Hengqi Chen <hengqi.chen@gmail.com>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/inst.h | 26 ++++++++++++++++++++++++++
+ arch/loongarch/kernel/inst.c      |  6 ++++++
+ 2 files changed, 32 insertions(+)
+
+diff --git a/arch/loongarch/include/asm/inst.h b/arch/loongarch/include/asm/inst.h
+index c9e54351bfce..1ed6cd60ebca 100644
+--- a/arch/loongarch/include/asm/inst.h
++++ b/arch/loongarch/include/asm/inst.h
+@@ -178,6 +178,32 @@ enum reg3_op {
+ 	amord_op	= 0x70c7,
+ 	amxorw_op	= 0x70c8,
+ 	amxord_op	= 0x70c9,
++	ammaxw_op	= 0x70ca,
++	ammaxd_op	= 0x70cb,
++	amminw_op	= 0x70cc,
++	ammind_op	= 0x70cd,
++	ammaxwu_op	= 0x70ce,
++	ammaxdu_op	= 0x70cf,
++	amminwu_op	= 0x70d0,
++	ammindu_op	= 0x70d1,
++	amswapdbw_op	= 0x70d2,
++	amswapdbd_op	= 0x70d3,
++	amadddbw_op	= 0x70d4,
++	amadddbd_op	= 0x70d5,
++	amanddbw_op	= 0x70d6,
++	amanddbd_op	= 0x70d7,
++	amordbw_op	= 0x70d8,
++	amordbd_op	= 0x70d9,
++	amxordbw_op	= 0x70da,
++	amxordbd_op	= 0x70db,
++	ammaxdbw_op	= 0x70dc,
++	ammaxdbd_op	= 0x70dd,
++	ammindbw_op	= 0x70de,
++	ammindbd_op	= 0x70df,
++	ammaxdbwu_op	= 0x70e0,
++	ammaxdbdu_op	= 0x70e1,
++	ammindbwu_op	= 0x70e2,
++	ammindbdu_op	= 0x70e3,
+ 	fldgts_op	= 0x70e8,
+ 	fldgtd_op	= 0x70e9,
+ 	fldles_op	= 0x70ea,
+diff --git a/arch/loongarch/kernel/inst.c b/arch/loongarch/kernel/inst.c
+index 6f61956972c1..aa1514b11964 100644
+--- a/arch/loongarch/kernel/inst.c
++++ b/arch/loongarch/kernel/inst.c
+@@ -135,6 +135,12 @@ void simu_branch(struct pt_regs *regs, union loongarch_instruction insn)
+ 
+ bool insns_not_supported(union loongarch_instruction insn)
+ {
++	switch (insn.reg3_format.opcode) {
++	case amswapw_op ... ammindbdu_op:
++		pr_notice("atomic memory access instructions are not supported\n");
++		return true;
++	}
++
+ 	switch (insn.reg2i14_format.opcode) {
+ 	case llw_op:
+ 	case lld_op:
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0012-LoongArch-Add-larch_insn_gen_break-to-generate-break.patch b/debian/patches/loongarch/0012-LoongArch-Add-larch_insn_gen_break-to-generate-break.patch
--- a/debian/patches/loongarch/0012-LoongArch-Add-larch_insn_gen_break-to-generate-break.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0012-LoongArch-Add-larch_insn_gen_break-to-generate-break.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,71 @@
+From eb7225fbd222b8508c394489465188aa08c349e3 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 12/19] LoongArch: Add larch_insn_gen_break() to generate break
+ insns
+
+There exist various break insns such as BRK_KPROBE_BP, BRK_KPROBE_SSTEPBP,
+BRK_UPROBE_BP and BRK_UPROBE_XOLBP, add larch_insn_gen_break() to generate
+break insns simpler, this is preparation for later patch.
+
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/inst.h | 12 ++++++++++++
+ arch/loongarch/kernel/inst.c      |  9 +++++++++
+ 2 files changed, 21 insertions(+)
+
+diff --git a/arch/loongarch/include/asm/inst.h b/arch/loongarch/include/asm/inst.h
+index 1ed6cd60ebca..ea625c41f4d3 100644
+--- a/arch/loongarch/include/asm/inst.h
++++ b/arch/loongarch/include/asm/inst.h
+@@ -473,6 +473,8 @@ u32 larch_insn_gen_nop(void);
+ u32 larch_insn_gen_b(unsigned long pc, unsigned long dest);
+ u32 larch_insn_gen_bl(unsigned long pc, unsigned long dest);
+ 
++u32 larch_insn_gen_break(int imm);
++
+ u32 larch_insn_gen_or(enum loongarch_gpr rd, enum loongarch_gpr rj, enum loongarch_gpr rk);
+ u32 larch_insn_gen_move(enum loongarch_gpr rd, enum loongarch_gpr rj);
+ 
+@@ -491,6 +493,16 @@ static inline bool unsigned_imm_check(unsigned long val, unsigned int bit)
+ 	return val < (1UL << bit);
+ }
+ 
++#define DEF_EMIT_REG0I15_FORMAT(NAME, OP)				\
++static inline void emit_##NAME(union loongarch_instruction *insn,	\
++			       int imm)					\
++{									\
++	insn->reg0i15_format.opcode = OP;				\
++	insn->reg0i15_format.immediate = imm;				\
++}
++
++DEF_EMIT_REG0I15_FORMAT(break, break_op)
++
+ #define DEF_EMIT_REG0I26_FORMAT(NAME, OP)				\
+ static inline void emit_##NAME(union loongarch_instruction *insn,	\
+ 			       int offset)				\
+diff --git a/arch/loongarch/kernel/inst.c b/arch/loongarch/kernel/inst.c
+index aa1514b11964..ce25a63b7339 100644
+--- a/arch/loongarch/kernel/inst.c
++++ b/arch/loongarch/kernel/inst.c
+@@ -253,6 +253,15 @@ u32 larch_insn_gen_bl(unsigned long pc, unsigned long dest)
+ 	return insn.word;
+ }
+ 
++u32 larch_insn_gen_break(int imm)
++{
++	union loongarch_instruction insn;
++
++	emit_break(&insn, imm);
++
++	return insn.word;
++}
++
+ u32 larch_insn_gen_or(enum loongarch_gpr rd, enum loongarch_gpr rj, enum loongarch_gpr rk)
+ {
+ 	union loongarch_instruction insn;
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0013-LoongArch-Use-larch_insn_gen_break-for-kprobes.patch b/debian/patches/loongarch/0013-LoongArch-Use-larch_insn_gen_break-for-kprobes.patch
--- a/debian/patches/loongarch/0013-LoongArch-Use-larch_insn_gen_break-for-kprobes.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0013-LoongArch-Use-larch_insn_gen_break-for-kprobes.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,129 @@
+From cef3ed79ab388b0663917760db84bd83c1ecfa27 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 13/19] LoongArch: Use larch_insn_gen_break() for kprobes
+
+For now, we can use larch_insn_gen_break() to define KPROBE_BP_INSN and
+KPROBE_SSTEPBP_INSN. Because larch_insn_gen_break() returns instruction
+word, define kprobe_opcode_t as u32, then do some small changes related
+with type conversion, no functional change intended.
+
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/kprobes.h |  2 +-
+ arch/loongarch/kernel/kprobes.c      | 33 ++++++++++++----------------
+ 2 files changed, 15 insertions(+), 20 deletions(-)
+
+diff --git a/arch/loongarch/include/asm/kprobes.h b/arch/loongarch/include/asm/kprobes.h
+index 7b9fc3ed71c3..60fa753a010d 100644
+--- a/arch/loongarch/include/asm/kprobes.h
++++ b/arch/loongarch/include/asm/kprobes.h
+@@ -22,7 +22,7 @@ do {									\
+ 
+ #define kretprobe_blacklist_size	0
+ 
+-typedef union loongarch_instruction kprobe_opcode_t;
++typedef u32 kprobe_opcode_t;
+ 
+ /* Architecture specific copy of original instruction */
+ struct arch_specific_insn {
+diff --git a/arch/loongarch/kernel/kprobes.c b/arch/loongarch/kernel/kprobes.c
+index 4c13c4431b67..17b040bd6067 100644
+--- a/arch/loongarch/kernel/kprobes.c
++++ b/arch/loongarch/kernel/kprobes.c
+@@ -4,19 +4,8 @@
+ #include <linux/preempt.h>
+ #include <asm/break.h>
+ 
+-static const union loongarch_instruction breakpoint_insn = {
+-	.reg0i15_format = {
+-		.opcode = break_op,
+-		.immediate = BRK_KPROBE_BP,
+-	}
+-};
+-
+-static const union loongarch_instruction singlestep_insn = {
+-	.reg0i15_format = {
+-		.opcode = break_op,
+-		.immediate = BRK_KPROBE_SSTEPBP,
+-	}
+-};
++#define KPROBE_BP_INSN		larch_insn_gen_break(BRK_KPROBE_BP)
++#define KPROBE_SSTEPBP_INSN	larch_insn_gen_break(BRK_KPROBE_SSTEPBP)
+ 
+ DEFINE_PER_CPU(struct kprobe *, current_kprobe);
+ DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
+@@ -24,7 +13,7 @@ DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
+ static void arch_prepare_ss_slot(struct kprobe *p)
+ {
+ 	p->ainsn.insn[0] = *p->addr;
+-	p->ainsn.insn[1] = singlestep_insn;
++	p->ainsn.insn[1] = KPROBE_SSTEPBP_INSN;
+ 	p->ainsn.restore = (unsigned long)p->addr + LOONGARCH_INSN_SIZE;
+ }
+ NOKPROBE_SYMBOL(arch_prepare_ss_slot);
+@@ -37,17 +26,20 @@ NOKPROBE_SYMBOL(arch_prepare_simulate);
+ 
+ int arch_prepare_kprobe(struct kprobe *p)
+ {
++	union loongarch_instruction insn;
++
+ 	if ((unsigned long)p->addr & 0x3)
+ 		return -EILSEQ;
+ 
+ 	/* copy instruction */
+ 	p->opcode = *p->addr;
++	insn.word = p->opcode;
+ 
+ 	/* decode instruction */
+-	if (insns_not_supported(p->opcode))
++	if (insns_not_supported(insn))
+ 		return -EINVAL;
+ 
+-	if (insns_need_simulation(p->opcode)) {
++	if (insns_need_simulation(insn)) {
+ 		p->ainsn.insn = NULL;
+ 	} else {
+ 		p->ainsn.insn = get_insn_slot();
+@@ -68,7 +60,7 @@ NOKPROBE_SYMBOL(arch_prepare_kprobe);
+ /* Install breakpoint in text */
+ void arch_arm_kprobe(struct kprobe *p)
+ {
+-	*p->addr = breakpoint_insn;
++	*p->addr = KPROBE_BP_INSN;
+ 	flush_insn_slot(p);
+ }
+ NOKPROBE_SYMBOL(arch_arm_kprobe);
+@@ -163,6 +155,8 @@ NOKPROBE_SYMBOL(post_kprobe_handler);
+ static void setup_singlestep(struct kprobe *p, struct pt_regs *regs,
+ 			     struct kprobe_ctlblk *kcb, int reenter)
+ {
++	union loongarch_instruction insn;
++
+ 	if (reenter) {
+ 		save_previous_kprobe(kcb);
+ 		set_current_kprobe(p);
+@@ -178,7 +172,8 @@ static void setup_singlestep(struct kprobe *p, struct pt_regs *regs,
+ 		regs->csr_era = (unsigned long)p->ainsn.insn;
+ 	} else {
+ 		/* simulate single steping */
+-		arch_simulate_insn(p->opcode, regs);
++		insn.word = p->opcode;
++		arch_simulate_insn(insn, regs);
+ 		/* now go for post processing */
+ 		post_kprobe_handler(p, kcb, regs);
+ 	}
+@@ -253,7 +248,7 @@ bool kprobe_breakpoint_handler(struct pt_regs *regs)
+ 		}
+ 	}
+ 
+-	if (addr->word != breakpoint_insn.word) {
++	if (*addr != KPROBE_BP_INSN) {
+ 		/*
+ 		 * The breakpoint instruction was removed right
+ 		 * after we hit it.  Another cpu has removed
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0014-LoongArch-Add-uprobes-support.patch b/debian/patches/loongarch/0014-LoongArch-Add-uprobes-support.patch
--- a/debian/patches/loongarch/0014-LoongArch-Add-uprobes-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0014-LoongArch-Add-uprobes-support.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,324 @@
+From 727cc8810245977ce31694f81bccec6ee2a718e9 Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:19 +0800
+Subject: [PATCH 14/19] LoongArch: Add uprobes support
+
+Uprobes is the user-space counterpart to kprobes, this patch adds
+uprobes support for LoongArch.
+
+Here is a simple example with CONFIG_UPROBE_EVENTS=y:
+
+  # cat test.c
+  #include <stdio.h>
+
+  int add(int a, int b)
+  {
+  	  return a + b;
+  }
+
+  int main()
+  {
+	  return add(2, 7);
+  }
+  # gcc test.c -o /tmp/test
+  # nm /tmp/test | grep add
+  0000000120004194 T add
+  # cd /sys/kernel/debug/tracing
+  # echo > uprobe_events
+  # echo "p:myuprobe /tmp/test:0x4194 %r4 %r5" > uprobe_events
+  # echo "r:myuretprobe /tmp/test:0x4194 %r4" >> uprobe_events
+  # echo 1 > events/uprobes/enable
+  # echo 1 > tracing_on
+  # /tmp/test
+  # cat trace
+  ...
+  #           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
+  #              | |         |   |||||     |         |
+              test-1060    [001] DNZff  1015.770620: myuprobe: (0x120004194) arg1=0x2 arg2=0x7
+              test-1060    [001] DNZff  1015.770930: myuretprobe: (0x1200041f0 <- 0x120004194) arg1=0x9
+
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/Kconfig               |   3 +
+ arch/loongarch/include/asm/uprobes.h |  36 +++++++
+ arch/loongarch/kernel/Makefile       |   1 +
+ arch/loongarch/kernel/traps.c        |   9 +-
+ arch/loongarch/kernel/uprobes.c      | 153 +++++++++++++++++++++++++++
+ 5 files changed, 197 insertions(+), 5 deletions(-)
+ create mode 100644 arch/loongarch/include/asm/uprobes.h
+ create mode 100644 arch/loongarch/kernel/uprobes.c
+
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index ba2a1ecb7ef0..2e9e0ecb4708 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -638,6 +638,9 @@ config ARCH_MMAP_RND_BITS_MIN
+ config ARCH_MMAP_RND_BITS_MAX
+ 	default 18
+ 
++config ARCH_SUPPORTS_UPROBES
++	def_bool y
++
+ menu "Power management options"
+ 
+ config ARCH_SUSPEND_POSSIBLE
+diff --git a/arch/loongarch/include/asm/uprobes.h b/arch/loongarch/include/asm/uprobes.h
+new file mode 100644
+index 000000000000..c8f59983f702
+--- /dev/null
++++ b/arch/loongarch/include/asm/uprobes.h
+@@ -0,0 +1,36 @@
++/* SPDX-License-Identifier: GPL-2.0-only */
++#ifndef __ASM_LOONGARCH_UPROBES_H
++#define __ASM_LOONGARCH_UPROBES_H
++
++#include <asm/inst.h>
++
++typedef u32 uprobe_opcode_t;
++
++#define MAX_UINSN_BYTES		8
++#define UPROBE_XOL_SLOT_BYTES	MAX_UINSN_BYTES
++
++#define UPROBE_SWBP_INSN	larch_insn_gen_break(BRK_UPROBE_BP)
++#define UPROBE_SWBP_INSN_SIZE	LOONGARCH_INSN_SIZE
++
++#define UPROBE_XOLBP_INSN	larch_insn_gen_break(BRK_UPROBE_XOLBP)
++
++struct arch_uprobe {
++	unsigned long	resume_era;
++	u32	insn[2];
++	u32	ixol[2];
++	bool	simulate;
++};
++
++struct arch_uprobe_task {
++	unsigned long saved_trap_nr;
++};
++
++#ifdef CONFIG_UPROBES
++bool uprobe_breakpoint_handler(struct pt_regs *regs);
++bool uprobe_singlestep_handler(struct pt_regs *regs);
++#else /* !CONFIG_UPROBES */
++static inline bool uprobe_breakpoint_handler(struct pt_regs *regs) { return false; }
++static inline bool uprobe_singlestep_handler(struct pt_regs *regs) { return false; }
++#endif /* CONFIG_UPROBES */
++
++#endif /* __ASM_LOONGARCH_UPROBES_H */
+diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
+index 1061c36f5ad5..8e279f04f9e7 100644
+--- a/arch/loongarch/kernel/Makefile
++++ b/arch/loongarch/kernel/Makefile
+@@ -56,6 +56,7 @@ obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
+ 
+ obj-$(CONFIG_KPROBES)		+= kprobes.o
+ obj-$(CONFIG_RETHOOK)		+= rethook.o rethook_trampoline.o
++obj-$(CONFIG_UPROBES)		+= uprobes.o
+ 
+ obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o
+ 
+diff --git a/arch/loongarch/kernel/traps.c b/arch/loongarch/kernel/traps.c
+index 417cec119638..22179cf6f33c 100644
+--- a/arch/loongarch/kernel/traps.c
++++ b/arch/loongarch/kernel/traps.c
+@@ -47,6 +47,7 @@
+ #include <asm/tlb.h>
+ #include <asm/types.h>
+ #include <asm/unwind.h>
++#include <asm/uprobes.h>
+ 
+ #include "access-helper.h"
+ 
+@@ -689,7 +690,6 @@ asmlinkage void noinstr do_bp(struct pt_regs *regs)
+ 	if (regs->csr_prmd & CSR_PRMD_PIE)
+ 		local_irq_enable();
+ 
+-	current->thread.trap_nr = read_csr_excode();
+ 	if (__get_inst(&opcode, (u32 *)era, user))
+ 		goto out_sigsegv;
+ 
+@@ -711,18 +711,17 @@ asmlinkage void noinstr do_bp(struct pt_regs *regs)
+ 		else
+ 			break;
+ 	case BRK_UPROBE_BP:
+-		if (notify_die(DIE_UPROBE, "Uprobe", regs, bcode,
+-			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
++		if (uprobe_breakpoint_handler(regs))
+ 			goto out;
+ 		else
+ 			break;
+ 	case BRK_UPROBE_XOLBP:
+-		if (notify_die(DIE_UPROBE_XOL, "Uprobe_XOL", regs, bcode,
+-			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
++		if (uprobe_singlestep_handler(regs))
+ 			goto out;
+ 		else
+ 			break;
+ 	default:
++		current->thread.trap_nr = read_csr_excode();
+ 		if (notify_die(DIE_TRAP, "Break", regs, bcode,
+ 			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
+ 			goto out;
+diff --git a/arch/loongarch/kernel/uprobes.c b/arch/loongarch/kernel/uprobes.c
+new file mode 100644
+index 000000000000..87abc7137b73
+--- /dev/null
++++ b/arch/loongarch/kernel/uprobes.c
+@@ -0,0 +1,153 @@
++// SPDX-License-Identifier: GPL-2.0-only
++#include <linux/highmem.h>
++#include <linux/ptrace.h>
++#include <linux/sched.h>
++#include <linux/uprobes.h>
++#include <asm/cacheflush.h>
++
++#define UPROBE_TRAP_NR	UINT_MAX
++
++int arch_uprobe_analyze_insn(struct arch_uprobe *auprobe,
++			     struct mm_struct *mm, unsigned long addr)
++{
++	int idx;
++	union loongarch_instruction insn;
++
++	if (addr & 0x3)
++		return -EILSEQ;
++
++	for (idx = ARRAY_SIZE(auprobe->insn) - 1; idx >= 0; idx--) {
++		insn.word = auprobe->insn[idx];
++		if (insns_not_supported(insn))
++			return -EINVAL;
++	}
++
++	if (insns_need_simulation(insn)) {
++		auprobe->ixol[0] = larch_insn_gen_nop();
++		auprobe->simulate = true;
++	} else {
++		auprobe->ixol[0] = auprobe->insn[0];
++		auprobe->simulate = false;
++	}
++
++	auprobe->ixol[1] = UPROBE_XOLBP_INSN;
++
++	return 0;
++}
++
++int arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
++{
++	struct uprobe_task *utask = current->utask;
++
++	utask->autask.saved_trap_nr = current->thread.trap_nr;
++	current->thread.trap_nr = UPROBE_TRAP_NR;
++	instruction_pointer_set(regs, utask->xol_vaddr);
++	user_enable_single_step(current);
++
++	return 0;
++}
++
++int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
++{
++	struct uprobe_task *utask = current->utask;
++
++	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
++	current->thread.trap_nr = utask->autask.saved_trap_nr;
++
++	if (auprobe->simulate)
++		instruction_pointer_set(regs, auprobe->resume_era);
++	else
++		instruction_pointer_set(regs, utask->vaddr + LOONGARCH_INSN_SIZE);
++
++	user_disable_single_step(current);
++
++	return 0;
++}
++
++void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
++{
++	struct uprobe_task *utask = current->utask;
++
++	current->thread.trap_nr = utask->autask.saved_trap_nr;
++	instruction_pointer_set(regs, utask->vaddr);
++	user_disable_single_step(current);
++}
++
++bool arch_uprobe_xol_was_trapped(struct task_struct *t)
++{
++	if (t->thread.trap_nr != UPROBE_TRAP_NR)
++		return true;
++
++	return false;
++}
++
++bool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)
++{
++	union loongarch_instruction insn;
++
++	if (!auprobe->simulate)
++		return false;
++
++	insn.word = auprobe->insn[0];
++	arch_simulate_insn(insn, regs);
++	auprobe->resume_era = regs->csr_era;
++
++	return true;
++}
++
++unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr,
++						struct pt_regs *regs)
++{
++	unsigned long ra = regs->regs[1];
++
++	regs->regs[1] = trampoline_vaddr;
++
++	return ra;
++}
++
++bool arch_uretprobe_is_alive(struct return_instance *ret,
++			     enum rp_check ctx, struct pt_regs *regs)
++{
++	if (ctx == RP_CHECK_CHAIN_CALL)
++		return regs->regs[3] <= ret->stack;
++	else
++		return regs->regs[3] < ret->stack;
++}
++
++int arch_uprobe_exception_notify(struct notifier_block *self,
++				 unsigned long val, void *data)
++{
++	return NOTIFY_DONE;
++}
++
++bool uprobe_breakpoint_handler(struct pt_regs *regs)
++{
++	if (uprobe_pre_sstep_notifier(regs))
++		return true;
++
++	return false;
++}
++
++bool uprobe_singlestep_handler(struct pt_regs *regs)
++{
++	if (uprobe_post_sstep_notifier(regs))
++		return true;
++
++	return false;
++}
++
++unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)
++{
++	return instruction_pointer(regs);
++}
++
++void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
++			   void *src, unsigned long len)
++{
++	void *kaddr = kmap_local_page(page);
++	void *dst = kaddr + (vaddr & ~PAGE_MASK);
++
++	memcpy(dst, src, len);
++	flush_icache_range((unsigned long)dst, (unsigned long)dst + len);
++	kunmap_local(kaddr);
++}
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0015-LoongArch-Remove-five-DIE_-definitions-in-kdebug.h.patch b/debian/patches/loongarch/0015-LoongArch-Remove-five-DIE_-definitions-in-kdebug.h.patch
--- a/debian/patches/loongarch/0015-LoongArch-Remove-five-DIE_-definitions-in-kdebug.h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0015-LoongArch-Remove-five-DIE_-definitions-in-kdebug.h.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,35 @@
+From dab7613f0d76dcfde6888323bd63bd63995c200b Mon Sep 17 00:00:00 2001
+From: Tiezhu Yang <yangtiezhu@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:29 +0800
+Subject: [PATCH 15/19] LoongArch: Remove five DIE_* definitions in kdebug.h
+
+For now, DIE_PAGE_FAULT, DIE_BREAK, DIE_SSTEPBP, DIE_UPROBE and
+DIE_UPROBE_XOL are not used by any code, remove them.
+
+Tested-by: Jeff Xie <xiehuan09@gmail.com>
+Suggested-by: Youling Tang <tangyouling@loongson.cn>
+Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/kdebug.h | 5 -----
+ 1 file changed, 5 deletions(-)
+
+diff --git a/arch/loongarch/include/asm/kdebug.h b/arch/loongarch/include/asm/kdebug.h
+index d721b4b82fae..c00ed874bf06 100644
+--- a/arch/loongarch/include/asm/kdebug.h
++++ b/arch/loongarch/include/asm/kdebug.h
+@@ -13,11 +13,6 @@ enum die_val {
+ 	DIE_FP,
+ 	DIE_SIMD,
+ 	DIE_TRAP,
+-	DIE_PAGE_FAULT,
+-	DIE_BREAK,
+-	DIE_SSTEPBP,
+-	DIE_UPROBE,
+-	DIE_UPROBE_XOL,
+ };
+ 
+ #endif /* _ASM_LOONGARCH_KDEBUG_H */
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0016-kasan-Add-__HAVE_ARCH_SHADOW_MAP-to-support-arch-spe.patch b/debian/patches/loongarch/0016-kasan-Add-__HAVE_ARCH_SHADOW_MAP-to-support-arch-spe.patch
--- a/debian/patches/loongarch/0016-kasan-Add-__HAVE_ARCH_SHADOW_MAP-to-support-arch-spe.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0016-kasan-Add-__HAVE_ARCH_SHADOW_MAP-to-support-arch-spe.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,73 @@
+From 06f1137248f0a5d355610044e8b1d01bdf0a22c6 Mon Sep 17 00:00:00 2001
+From: Qing Zhang <zhangqing@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:29 +0800
+Subject: [PATCH 16/19] kasan: Add __HAVE_ARCH_SHADOW_MAP to support arch
+ specific mapping
+
+MIPS, LoongArch and some other architectures have many holes between
+different segments and the valid address space (256T available) is
+insufficient to map all these segments to kasan shadow memory with the
+common formula provided by kasan core. So we need architecture specific
+mapping formulas to ensure different segments are mapped individually,
+and only limited space lengths of those specific segments are mapped to
+shadow.
+
+Therefore, when the incoming address is converted to a shadow, we need
+to add a condition to determine whether it is valid.
+
+Reviewed-by: Andrey Konovalov <andreyknvl@gmail.com>
+Signed-off-by: Qing Zhang <zhangqing@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ include/linux/kasan.h | 2 ++
+ mm/kasan/kasan.h      | 6 ++++++
+ 2 files changed, 8 insertions(+)
+
+diff --git a/include/linux/kasan.h b/include/linux/kasan.h
+index f7ef70661ce2..3b91b941873d 100644
+--- a/include/linux/kasan.h
++++ b/include/linux/kasan.h
+@@ -54,11 +54,13 @@ extern p4d_t kasan_early_shadow_p4d[MAX_PTRS_PER_P4D];
+ int kasan_populate_early_shadow(const void *shadow_start,
+ 				const void *shadow_end);
+ 
++#ifndef __HAVE_ARCH_SHADOW_MAP
+ static inline void *kasan_mem_to_shadow(const void *addr)
+ {
+ 	return (void *)((unsigned long)addr >> KASAN_SHADOW_SCALE_SHIFT)
+ 		+ KASAN_SHADOW_OFFSET;
+ }
++#endif
+ 
+ int kasan_add_zero_shadow(void *start, unsigned long size);
+ void kasan_remove_zero_shadow(void *start, unsigned long size);
+diff --git a/mm/kasan/kasan.h b/mm/kasan/kasan.h
+index f5e4f5f2ba20..63ce60b45836 100644
+--- a/mm/kasan/kasan.h
++++ b/mm/kasan/kasan.h
+@@ -291,16 +291,22 @@ struct kasan_stack_ring {
+ 
+ #if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
+ 
++#ifndef __HAVE_ARCH_SHADOW_MAP
+ static inline const void *kasan_shadow_to_mem(const void *shadow_addr)
+ {
+ 	return (void *)(((unsigned long)shadow_addr - KASAN_SHADOW_OFFSET)
+ 		<< KASAN_SHADOW_SCALE_SHIFT);
+ }
++#endif
+ 
+ static __always_inline bool addr_has_metadata(const void *addr)
+ {
++#ifdef __HAVE_ARCH_SHADOW_MAP
++	return (kasan_mem_to_shadow((void *)addr) != NULL);
++#else
+ 	return (kasan_reset_tag(addr) >=
+ 		kasan_shadow_to_mem((void *)KASAN_SHADOW_START));
++#endif
+ }
+ 
+ /**
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0017-kasan-Add-pmd-pud-_init-for-LoongArch-zero_-pud-p4d-.patch b/debian/patches/loongarch/0017-kasan-Add-pmd-pud-_init-for-LoongArch-zero_-pud-p4d-.patch
--- a/debian/patches/loongarch/0017-kasan-Add-pmd-pud-_init-for-LoongArch-zero_-pud-p4d-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0017-kasan-Add-pmd-pud-_init-for-LoongArch-zero_-pud-p4d-.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,70 @@
+From 90c74ff7d358438095bcec0c9f89205497e3202c Mon Sep 17 00:00:00 2001
+From: Qing Zhang <zhangqing@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:29 +0800
+Subject: [PATCH 17/19] kasan: Add (pmd|pud)_init for LoongArch
+ zero_(pud|p4d)_populate process
+
+LoongArch populates pmd/pud with invalid_pmd_table/invalid_pud_table in
+pagetable_init, So pmd_init/pud_init(p) is required, define them as __weak
+in mm/kasan/init.c, like mm/sparse-vmemmap.c.
+
+Reviewed-by: Andrey Konovalov <andreyknvl@gmail.com>
+Signed-off-by: Qing Zhang <zhangqing@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ mm/kasan/init.c | 18 ++++++++++++++----
+ 1 file changed, 14 insertions(+), 4 deletions(-)
+
+diff --git a/mm/kasan/init.c b/mm/kasan/init.c
+index cc64ed6858c6..a7fa223b96e4 100644
+--- a/mm/kasan/init.c
++++ b/mm/kasan/init.c
+@@ -139,6 +139,10 @@ static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,
+ 	return 0;
+ }
+ 
++void __weak __meminit pmd_init(void *addr)
++{
++}
++
+ static int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,
+ 				unsigned long end)
+ {
+@@ -166,8 +170,9 @@ static int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,
+ 				if (!p)
+ 					return -ENOMEM;
+ 			} else {
+-				pud_populate(&init_mm, pud,
+-					early_alloc(PAGE_SIZE, NUMA_NO_NODE));
++				p = early_alloc(PAGE_SIZE, NUMA_NO_NODE);
++				pmd_init(p);
++				pud_populate(&init_mm, pud, p);
+ 			}
+ 		}
+ 		zero_pmd_populate(pud, addr, next);
+@@ -176,6 +181,10 @@ static int __ref zero_pud_populate(p4d_t *p4d, unsigned long addr,
+ 	return 0;
+ }
+ 
++void __weak __meminit pud_init(void *addr)
++{
++}
++
+ static int __ref zero_p4d_populate(pgd_t *pgd, unsigned long addr,
+ 				unsigned long end)
+ {
+@@ -207,8 +216,9 @@ static int __ref zero_p4d_populate(pgd_t *pgd, unsigned long addr,
+ 				if (!p)
+ 					return -ENOMEM;
+ 			} else {
+-				p4d_populate(&init_mm, p4d,
+-					early_alloc(PAGE_SIZE, NUMA_NO_NODE));
++				p = early_alloc(PAGE_SIZE, NUMA_NO_NODE);
++				pud_init(p);
++				p4d_populate(&init_mm, p4d, p);
+ 			}
+ 		}
+ 		zero_pud_populate(p4d, addr, next);
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0018-LoongArch-Simplify-the-processing-of-jumping-new-ker.patch b/debian/patches/loongarch/0018-LoongArch-Simplify-the-processing-of-jumping-new-ker.patch
--- a/debian/patches/loongarch/0018-LoongArch-Simplify-the-processing-of-jumping-new-ker.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0018-LoongArch-Simplify-the-processing-of-jumping-new-ker.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,97 @@
+From fb28aee26c52a481b9899fdd902d46f0b3a4c5e0 Mon Sep 17 00:00:00 2001
+From: Qing Zhang <zhangqing@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:29 +0800
+Subject: [PATCH 18/19] LoongArch: Simplify the processing of jumping new
+ kernel for KASLR
+
+Modified relocate_kernel() doesn't return new kernel's entry point but
+the random_offset. In this way we share the start_kernel() processing
+with the normal kernel, which avoids calling 'jr a0' directly and allows
+some other operations (e.g, kasan_early_init) before start_kernel() when
+KASLR (CONFIG_RANDOMIZE_BASE) is turned on.
+
+Signed-off-by: Qing Zhang <zhangqing@loongson.cn>
+Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
+---
+ arch/loongarch/include/asm/setup.h |  2 +-
+ arch/loongarch/kernel/head.S       | 11 ++++++-----
+ arch/loongarch/kernel/relocate.c   |  8 ++------
+ 3 files changed, 9 insertions(+), 12 deletions(-)
+
+diff --git a/arch/loongarch/include/asm/setup.h b/arch/loongarch/include/asm/setup.h
+index be05c0e706a2..2dca0d1dd90a 100644
+--- a/arch/loongarch/include/asm/setup.h
++++ b/arch/loongarch/include/asm/setup.h
+@@ -33,7 +33,7 @@ extern long __la_abs_end;
+ extern long __rela_dyn_begin;
+ extern long __rela_dyn_end;
+ 
+-extern void * __init relocate_kernel(void);
++extern unsigned long __init relocate_kernel(void);
+ 
+ #endif
+ 
+diff --git a/arch/loongarch/kernel/head.S b/arch/loongarch/kernel/head.S
+index aa64b179744f..aace7a300cd3 100644
+--- a/arch/loongarch/kernel/head.S
++++ b/arch/loongarch/kernel/head.S
+@@ -95,13 +95,14 @@ SYM_CODE_START(kernel_entry)			# kernel entry point
+ 	PTR_LI		sp, (_THREAD_SIZE - PT_SIZE)
+ 	PTR_ADD		sp, sp, tp
+ 	set_saved_sp	sp, t0, t1
+-#endif
+ 
+-	/* relocate_kernel() returns the new kernel entry point */
+-	jr		a0
+-	ASM_BUG()
++	/* Jump to the new kernel: new_pc = current_pc + random_offset */
++	pcaddi		t0, 0
++	add.d		t0, t0, a0
++	jirl		zero, t0, 0xc
++#endif /* CONFIG_RANDOMIZE_BASE */
+ 
+-#endif
++#endif /* CONFIG_RELOCATABLE */
+ 
+ 	bl		start_kernel
+ 	ASM_BUG()
+diff --git a/arch/loongarch/kernel/relocate.c b/arch/loongarch/kernel/relocate.c
+index 01f94d1e3edf..6c3eff9af9fb 100644
+--- a/arch/loongarch/kernel/relocate.c
++++ b/arch/loongarch/kernel/relocate.c
+@@ -157,12 +157,11 @@ static inline void __init update_reloc_offset(unsigned long *addr, long random_o
+ 	*new_addr = (unsigned long)reloc_offset;
+ }
+ 
+-void * __init relocate_kernel(void)
++unsigned long __init relocate_kernel(void)
+ {
+ 	unsigned long kernel_length;
+ 	unsigned long random_offset = 0;
+ 	void *location_new = _text; /* Default to original kernel start */
+-	void *kernel_entry = start_kernel; /* Default to original kernel entry point */
+ 	char *cmdline = early_ioremap(fw_arg1, COMMAND_LINE_SIZE); /* Boot command line is passed in fw_arg1 */
+ 
+ 	strscpy(boot_command_line, cmdline, COMMAND_LINE_SIZE);
+@@ -190,9 +189,6 @@ void * __init relocate_kernel(void)
+ 
+ 		reloc_offset += random_offset;
+ 
+-		/* Return the new kernel's entry point */
+-		kernel_entry = RELOCATED_KASLR(start_kernel);
+-
+ 		/* The current thread is now within the relocated kernel */
+ 		__current_thread_info = RELOCATED_KASLR(__current_thread_info);
+ 
+@@ -204,7 +200,7 @@ void * __init relocate_kernel(void)
+ 
+ 	relocate_absolute(random_offset);
+ 
+-	return kernel_entry;
++	return random_offset;
+ }
+ 
+ /*
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/0019-LoongArch-Add-kernel-address-sanitizer-support.patch b/debian/patches/loongarch/0019-LoongArch-Add-kernel-address-sanitizer-support.patch
--- a/debian/patches/loongarch/0019-LoongArch-Add-kernel-address-sanitizer-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/0019-LoongArch-Add-kernel-address-sanitizer-support.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,723 @@
+From c976fff79c12fbc08f4b6735eae250e5145bec23 Mon Sep 17 00:00:00 2001
+From: Qing Zhang <zhangqing@loongson.cn>
+Date: Tue, 20 Jun 2023 20:50:29 +0800
+Subject: [PATCH 19/19] LoongArch: Add kernel address sanitizer support
+
+1/8 of kernel addresses reserved for shadow memory. But for LoongArch,
+There are a lot of holes between different segments and valid address
+space (256T available) is insufficient to map all these segments to kasan
+shadow memory with the common formula provided by kasan core, saying
+(addr >> KASAN_SHADOW_SCALE_SHIFT) + KASAN_SHADOW_OFFSET
+
+So LoongArch has a arch-specific mapping formula, different segments are
+mapped individually, and only limited space lengths of these specific
+segments are mapped to shadow.
+
+At early boot stage the whole shadow region populated with just one
+physical page (kasan_early_shadow_page). Later, this page is reused as
+readonly zero shadow for some memory that kasan currently don't track.
+After mapping the physical memory, pages for shadow memory are allocated
+and mapped.
+
+Functions like memset()/memcpy()/memmove() do a lot of memory accesses.
+If bad pointer passed to one of these function it is important to be
+caught. Compiler's instrumentation cannot do this since these functions
+are written in assembly.
+
+KASan replaces memory functions with manually instrumented variants.
+Original functions declared as weak symbols so strong definitions in
+mm/kasan/kasan.c could replace them. Original functions have aliases
+with '__' prefix in names, so we could call non-instrumented variant
+if needed.
+
+Signed-off-by: Qing Zhang <zhangqing@loongson.cn>
+---
+ Documentation/dev-tools/kasan.rst             |   4 +-
+ .../features/debug/KASAN/arch-support.txt     |   2 +-
+ .../translations/zh_CN/dev-tools/kasan.rst    |   2 +-
+ arch/loongarch/Kconfig                        |   7 +
+ arch/loongarch/include/asm/kasan.h            | 120 +++++++++
+ arch/loongarch/include/asm/pgtable.h          |   7 +
+ arch/loongarch/include/asm/string.h           |  20 ++
+ arch/loongarch/kernel/Makefile                |   6 +
+ arch/loongarch/kernel/head.S                  |   4 +
+ arch/loongarch/kernel/setup.c                 |   4 +
+ arch/loongarch/lib/memcpy.S                   |   8 +-
+ arch/loongarch/lib/memmove.S                  |  20 +-
+ arch/loongarch/lib/memset.S                   |   8 +-
+ arch/loongarch/mm/Makefile                    |   3 +
+ arch/loongarch/mm/kasan_init.c                | 239 ++++++++++++++++++
+ arch/loongarch/vdso/Makefile                  |   4 +
+ 16 files changed, 442 insertions(+), 16 deletions(-)
+ create mode 100644 arch/loongarch/include/asm/kasan.h
+ create mode 100644 arch/loongarch/mm/kasan_init.c
+
+diff --git a/Documentation/dev-tools/kasan.rst b/Documentation/dev-tools/kasan.rst
+index e66916a483cd..ee91f2872767 100644
+--- a/Documentation/dev-tools/kasan.rst
++++ b/Documentation/dev-tools/kasan.rst
+@@ -41,8 +41,8 @@ Support
+ Architectures
+ ~~~~~~~~~~~~~
+ 
+-Generic KASAN is supported on x86_64, arm, arm64, powerpc, riscv, s390, and
+-xtensa, and the tag-based KASAN modes are supported only on arm64.
++Generic KASAN is supported on x86_64, arm, arm64, powerpc, riscv, s390, xtensa,
++and loongarch, and the tag-based KASAN modes are supported only on arm64.
+ 
+ Compilers
+ ~~~~~~~~~
+diff --git a/Documentation/features/debug/KASAN/arch-support.txt b/Documentation/features/debug/KASAN/arch-support.txt
+index bf0124fae643..c4581c2edb28 100644
+--- a/Documentation/features/debug/KASAN/arch-support.txt
++++ b/Documentation/features/debug/KASAN/arch-support.txt
+@@ -13,7 +13,7 @@
+     |        csky: | TODO |
+     |     hexagon: | TODO |
+     |        ia64: | TODO |
+-    |   loongarch: | TODO |
++    |   loongarch: |  ok  |
+     |        m68k: | TODO |
+     |  microblaze: | TODO |
+     |        mips: | TODO |
+diff --git a/Documentation/translations/zh_CN/dev-tools/kasan.rst b/Documentation/translations/zh_CN/dev-tools/kasan.rst
+index 05ef904dbcfb..8fdb20c9665b 100644
+--- a/Documentation/translations/zh_CN/dev-tools/kasan.rst
++++ b/Documentation/translations/zh_CN/dev-tools/kasan.rst
+@@ -42,7 +42,7 @@ KASAN:
+ 
+ ~~~~~~~~
+ 
+-x86_64armarm64powerpcriscvs390xtensaKASAN
++x86_64armarm64powerpcriscvs390xtensaloongarchKASAN
+ KASANarm64
+ 
+ 
+diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
+index 2e9e0ecb4708..5cf96b6b4bb7 100644
+--- a/arch/loongarch/Kconfig
++++ b/arch/loongarch/Kconfig
+@@ -8,6 +8,7 @@ config LOONGARCH
+ 	select ACPI_PPTT if ACPI
+ 	select ACPI_SYSTEM_POWER_STATES_SUPPORT	if ACPI
+ 	select ARCH_BINFMT_ELF_STATE
++	select ARCH_DISABLE_KASAN_INLINE
+ 	select ARCH_ENABLE_MEMORY_HOTPLUG
+ 	select ARCH_ENABLE_MEMORY_HOTREMOVE
+ 	select ARCH_HAS_ACPI_TABLE_UPGRADE	if ACPI
+@@ -87,6 +88,7 @@ config LOONGARCH
+ 	select HAVE_ARCH_AUDITSYSCALL
+ 	select HAVE_ARCH_JUMP_LABEL
+ 	select HAVE_ARCH_JUMP_LABEL_RELATIVE
++	select HAVE_ARCH_KASAN
+ 	select HAVE_ARCH_MMAP_RND_BITS if MMU
+ 	select HAVE_ARCH_SECCOMP_FILTER
+ 	select HAVE_ARCH_TRACEHOOK
+@@ -641,6 +643,11 @@ config ARCH_MMAP_RND_BITS_MAX
+ config ARCH_SUPPORTS_UPROBES
+ 	def_bool y
+ 
++config KASAN_SHADOW_OFFSET
++	hex
++	default 0x0
++	depends on KASAN
++
+ menu "Power management options"
+ 
+ config ARCH_SUSPEND_POSSIBLE
+diff --git a/arch/loongarch/include/asm/kasan.h b/arch/loongarch/include/asm/kasan.h
+new file mode 100644
+index 000000000000..c631e9ded892
+--- /dev/null
++++ b/arch/loongarch/include/asm/kasan.h
+@@ -0,0 +1,120 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++#ifndef __ASM_KASAN_H
++#define __ASM_KASAN_H
++
++#ifndef __ASSEMBLY__
++
++#include <linux/linkage.h>
++#include <linux/mmzone.h>
++#include <asm/addrspace.h>
++#include <asm/io.h>
++#include <asm/pgtable.h>
++
++#define __HAVE_ARCH_SHADOW_MAP
++
++#define KASAN_SHADOW_SCALE_SHIFT 3
++#define KASAN_SHADOW_OFFSET	_AC(CONFIG_KASAN_SHADOW_OFFSET, UL)
++
++#define XRANGE_SHIFT (48)
++
++/* Valid address length */
++#define XRANGE_SHADOW_SHIFT	(PGDIR_SHIFT + PAGE_SHIFT - 3)
++/* Used for taking out the valid address */
++#define XRANGE_SHADOW_MASK	GENMASK_ULL(XRANGE_SHADOW_SHIFT - 1, 0)
++/* One segment whole address space size */
++#define XRANGE_SIZE		(XRANGE_SHADOW_MASK + 1)
++
++/* 64-bit segment value. */
++#define XKPRANGE_UC_SEG		(0x8000)
++#define XKPRANGE_CC_SEG		(0x9000)
++#define XKVRANGE_VC_SEG		(0xffff)
++
++/* Cached */
++#define XKPRANGE_CC_START		CACHE_BASE
++#define XKPRANGE_CC_SIZE		XRANGE_SIZE
++#define XKPRANGE_CC_KASAN_OFFSET	(0)
++#define XKPRANGE_CC_SHADOW_SIZE		(XKPRANGE_CC_SIZE >> KASAN_SHADOW_SCALE_SHIFT)
++#define XKPRANGE_CC_SHADOW_END		(XKPRANGE_CC_KASAN_OFFSET + XKPRANGE_CC_SHADOW_SIZE)
++
++/* UnCached */
++#define XKPRANGE_UC_START		UNCACHE_BASE
++#define XKPRANGE_UC_SIZE		XRANGE_SIZE
++#define XKPRANGE_UC_KASAN_OFFSET	XKPRANGE_CC_SHADOW_END
++#define XKPRANGE_UC_SHADOW_SIZE		(XKPRANGE_UC_SIZE >> KASAN_SHADOW_SCALE_SHIFT)
++#define XKPRANGE_UC_SHADOW_END		(XKPRANGE_UC_KASAN_OFFSET + XKPRANGE_UC_SHADOW_SIZE)
++
++/* VMALLOC (Cached or UnCached)  */
++#define XKVRANGE_VC_START		MODULES_VADDR
++#define XKVRANGE_VC_SIZE		round_up(VMEMMAP_END - MODULES_VADDR + 1, PGDIR_SIZE)
++#define XKVRANGE_VC_KASAN_OFFSET	XKPRANGE_UC_SHADOW_END
++#define XKVRANGE_VC_SHADOW_SIZE		(XKVRANGE_VC_SIZE >> KASAN_SHADOW_SCALE_SHIFT)
++#define XKVRANGE_VC_SHADOW_END		(XKVRANGE_VC_KASAN_OFFSET + XKVRANGE_VC_SHADOW_SIZE)
++
++/* Kasan shadow memory start right after vmalloc. */
++#define KASAN_SHADOW_START		round_up(VMEMMAP_END, PGDIR_SIZE)
++#define KASAN_SHADOW_SIZE		(XKVRANGE_VC_SHADOW_END - XKPRANGE_CC_KASAN_OFFSET)
++#define KASAN_SHADOW_END		round_up(KASAN_SHADOW_START + KASAN_SHADOW_SIZE, PGDIR_SIZE)
++
++#define XKPRANGE_CC_SHADOW_OFFSET	(KASAN_SHADOW_START + XKPRANGE_CC_KASAN_OFFSET)
++#define XKPRANGE_UC_SHADOW_OFFSET	(KASAN_SHADOW_START + XKPRANGE_UC_KASAN_OFFSET)
++#define XKVRANGE_VC_SHADOW_OFFSET	(KASAN_SHADOW_START + XKVRANGE_VC_KASAN_OFFSET)
++
++extern bool kasan_early_stage;
++extern unsigned char kasan_early_shadow_page[PAGE_SIZE];
++
++static inline void *kasan_mem_to_shadow(const void *addr)
++{
++	if (kasan_early_stage) {
++		return (void *)(kasan_early_shadow_page);
++	} else {
++		unsigned long maddr = (unsigned long)addr;
++		unsigned long xrange = (maddr >> XRANGE_SHIFT) & 0xffff;
++		unsigned long offset = 0;
++
++		maddr &= XRANGE_SHADOW_MASK;
++		switch (xrange) {
++		case XKPRANGE_CC_SEG:
++			offset = XKPRANGE_CC_SHADOW_OFFSET;
++			break;
++		case XKPRANGE_UC_SEG:
++			offset = XKPRANGE_UC_SHADOW_OFFSET;
++			break;
++		case XKVRANGE_VC_SEG:
++			offset = XKVRANGE_VC_SHADOW_OFFSET;
++			break;
++		default:
++			WARN_ON(1);
++			return NULL;
++		}
++
++		return (void *)((maddr >> KASAN_SHADOW_SCALE_SHIFT) + offset);
++	}
++}
++
++static inline const void *kasan_shadow_to_mem(const void *shadow_addr)
++{
++	unsigned long addr = (unsigned long)shadow_addr;
++
++	if (unlikely(addr > KASAN_SHADOW_END) ||
++		unlikely(addr < KASAN_SHADOW_START)) {
++		WARN_ON(1);
++		return NULL;
++	}
++
++	if (addr >= XKVRANGE_VC_SHADOW_OFFSET)
++		return (void *)(((addr - XKVRANGE_VC_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT) + XKVRANGE_VC_START);
++	else if (addr >= XKPRANGE_UC_SHADOW_OFFSET)
++		return (void *)(((addr - XKPRANGE_UC_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT) + XKPRANGE_UC_START);
++	else if (addr >= XKPRANGE_CC_SHADOW_OFFSET)
++		return (void *)(((addr - XKPRANGE_CC_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT) + XKPRANGE_CC_START);
++	else {
++		WARN_ON(1);
++		return NULL;
++	}
++}
++
++void kasan_init(void);
++asmlinkage void kasan_early_init(void);
++
++#endif
++#endif
+diff --git a/arch/loongarch/include/asm/pgtable.h b/arch/loongarch/include/asm/pgtable.h
+index 38afeb7dd58b..ed6a37bb55b5 100644
+--- a/arch/loongarch/include/asm/pgtable.h
++++ b/arch/loongarch/include/asm/pgtable.h
+@@ -86,9 +86,16 @@ extern unsigned long zero_page_mask;
+ #define MODULES_END	(MODULES_VADDR + SZ_256M)
+ 
+ #define VMALLOC_START	MODULES_END
++
++#ifndef CONFIG_KASAN
+ #define VMALLOC_END	\
+ 	(vm_map_base +	\
+ 	 min(PTRS_PER_PGD * PTRS_PER_PUD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE, (1UL << cpu_vabits)) - PMD_SIZE - VMEMMAP_SIZE)
++#else
++#define VMALLOC_END	\
++	(vm_map_base +	\
++	 min(PTRS_PER_PGD * PTRS_PER_PUD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE, (1UL << cpu_vabits) / 2) - PMD_SIZE - VMEMMAP_SIZE)
++#endif
+ 
+ #define vmemmap		((struct page *)((VMALLOC_END + PMD_SIZE) & PMD_MASK))
+ #define VMEMMAP_END	((unsigned long)vmemmap + VMEMMAP_SIZE - 1)
+diff --git a/arch/loongarch/include/asm/string.h b/arch/loongarch/include/asm/string.h
+index 7b29cc9c70aa..5bb5a90d2681 100644
+--- a/arch/loongarch/include/asm/string.h
++++ b/arch/loongarch/include/asm/string.h
+@@ -7,11 +7,31 @@
+ 
+ #define __HAVE_ARCH_MEMSET
+ extern void *memset(void *__s, int __c, size_t __count);
++extern void *__memset(void *__s, int __c, size_t __count);
+ 
+ #define __HAVE_ARCH_MEMCPY
+ extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
++extern void *__memcpy(void *__to, __const__ void *__from, size_t __n);
+ 
+ #define __HAVE_ARCH_MEMMOVE
+ extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
++extern void *__memmove(void *__dest, __const__ void *__src, size_t __n);
++
++#if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
++
++/*
++ * For files that are not instrumented (e.g. mm/slub.c) we
++ * should use not instrumented version of mem* functions.
++ */
++
++#define memset(s, c, n) __memset(s, c, n)
++#define memcpy(dst, src, len) __memcpy(dst, src, len)
++#define memmove(dst, src, len) __memmove(dst, src, len)
++
++#ifndef __NO_FORTIFY
++#define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
++#endif
++
++#endif
+ 
+ #endif /* _ASM_STRING_H */
+diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
+index 8e279f04f9e7..9048ab4e5d40 100644
+--- a/arch/loongarch/kernel/Makefile
++++ b/arch/loongarch/kernel/Makefile
+@@ -32,6 +32,12 @@ ifdef CONFIG_FUNCTION_TRACER
+   CFLAGS_REMOVE_rethook_trampoline.o = $(CC_FLAGS_FTRACE)
+ endif
+ 
++KASAN_SANITIZE_efi.o := n
++KASAN_SANITIZE_cpu-probe.o := n
++KASAN_SANITIZE_traps.o := n
++KASAN_SANITIZE_smp.o := n
++KASAN_SANITIZE_vdso.o := n
++
+ obj-$(CONFIG_MODULES)		+= module.o module-sections.o
+ obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
+ 
+diff --git a/arch/loongarch/kernel/head.S b/arch/loongarch/kernel/head.S
+index aace7a300cd3..0d8180153ec0 100644
+--- a/arch/loongarch/kernel/head.S
++++ b/arch/loongarch/kernel/head.S
+@@ -104,6 +104,10 @@ SYM_CODE_START(kernel_entry)			# kernel entry point
+ 
+ #endif /* CONFIG_RELOCATABLE */
+ 
++#ifdef CONFIG_KASAN
++	bl		kasan_early_init
++#endif
++
+ 	bl		start_kernel
+ 	ASM_BUG()
+ 
+diff --git a/arch/loongarch/kernel/setup.c b/arch/loongarch/kernel/setup.c
+index 4444b13418f0..9e94bf60c900 100644
+--- a/arch/loongarch/kernel/setup.c
++++ b/arch/loongarch/kernel/setup.c
+@@ -610,4 +610,8 @@ void __init setup_arch(char **cmdline_p)
+ #endif
+ 
+ 	paging_init();
++
++#ifdef CONFIG_KASAN
++	kasan_init();
++#endif
+ }
+diff --git a/arch/loongarch/lib/memcpy.S b/arch/loongarch/lib/memcpy.S
+index 39ce6621c704..0bc61e23c596 100644
+--- a/arch/loongarch/lib/memcpy.S
++++ b/arch/loongarch/lib/memcpy.S
+@@ -10,16 +10,20 @@
+ #include <asm/export.h>
+ #include <asm/regdef.h>
+ 
+-SYM_FUNC_START(memcpy)
++SYM_FUNC_START_WEAK(memcpy)
+ 	/*
+ 	 * Some CPUs support hardware unaligned access
+ 	 */
+ 	ALTERNATIVE	"b __memcpy_generic", \
+ 			"b __memcpy_fast", CPU_FEATURE_UAL
+ SYM_FUNC_END(memcpy)
+-_ASM_NOKPROBE(memcpy)
++SYM_FUNC_ALIAS(__memcpy, memcpy)
+ 
+ EXPORT_SYMBOL(memcpy)
++EXPORT_SYMBOL(__memcpy)
++
++_ASM_NOKPROBE(memcpy)
++_ASM_NOKPROBE(__memcpy)
+ 
+ /*
+  * void *__memcpy_generic(void *dst, const void *src, size_t n)
+diff --git a/arch/loongarch/lib/memmove.S b/arch/loongarch/lib/memmove.S
+index 45b725ba7867..d9ebd6da09bc 100644
+--- a/arch/loongarch/lib/memmove.S
++++ b/arch/loongarch/lib/memmove.S
+@@ -10,23 +10,27 @@
+ #include <asm/export.h>
+ #include <asm/regdef.h>
+ 
+-SYM_FUNC_START(memmove)
+-	blt	a0, a1, memcpy	/* dst < src, memcpy */
+-	blt	a1, a0, rmemcpy	/* src < dst, rmemcpy */
+-	jr	ra		/* dst == src, return */
++SYM_FUNC_START_WEAK(memmove)
++	blt	a0, a1, __memcpy	/* dst < src, memcpy */
++	blt	a1, a0, __rmemcpy	/* src < dst, rmemcpy */
++	jr	ra			/* dst == src, return */
+ SYM_FUNC_END(memmove)
+-_ASM_NOKPROBE(memmove)
++SYM_FUNC_ALIAS(__memmove, memmove)
+ 
+ EXPORT_SYMBOL(memmove)
++EXPORT_SYMBOL(__memmove)
++
++_ASM_NOKPROBE(memmove)
++_ASM_NOKPROBE(__memmove)
+ 
+-SYM_FUNC_START(rmemcpy)
++SYM_FUNC_START(__rmemcpy)
+ 	/*
+ 	 * Some CPUs support hardware unaligned access
+ 	 */
+ 	ALTERNATIVE	"b __rmemcpy_generic", \
+ 			"b __rmemcpy_fast", CPU_FEATURE_UAL
+-SYM_FUNC_END(rmemcpy)
+-_ASM_NOKPROBE(rmemcpy)
++SYM_FUNC_END(__rmemcpy)
++_ASM_NOKPROBE(__rmemcpy)
+ 
+ /*
+  * void *__rmemcpy_generic(void *dst, const void *src, size_t n)
+diff --git a/arch/loongarch/lib/memset.S b/arch/loongarch/lib/memset.S
+index b39c6194e3ae..35fca34234c0 100644
+--- a/arch/loongarch/lib/memset.S
++++ b/arch/loongarch/lib/memset.S
+@@ -16,16 +16,20 @@
+ 	bstrins.d \r0, \r0, 63, 32
+ .endm
+ 
+-SYM_FUNC_START(memset)
++SYM_FUNC_START_WEAK(memset)
+ 	/*
+ 	 * Some CPUs support hardware unaligned access
+ 	 */
+ 	ALTERNATIVE	"b __memset_generic", \
+ 			"b __memset_fast", CPU_FEATURE_UAL
+ SYM_FUNC_END(memset)
+-_ASM_NOKPROBE(memset)
++SYM_FUNC_ALIAS(__memset, memset)
+ 
+ EXPORT_SYMBOL(memset)
++EXPORT_SYMBOL(__memset)
++
++_ASM_NOKPROBE(memset)
++_ASM_NOKPROBE(__memset)
+ 
+ /*
+  * void *__memset_generic(void *s, int c, size_t n)
+diff --git a/arch/loongarch/mm/Makefile b/arch/loongarch/mm/Makefile
+index 8ffc6383f836..e4d1e581dbae 100644
+--- a/arch/loongarch/mm/Makefile
++++ b/arch/loongarch/mm/Makefile
+@@ -7,3 +7,6 @@ obj-y				+= init.o cache.o tlb.o tlbex.o extable.o \
+ 				   fault.o ioremap.o maccess.o mmap.o pgtable.o page.o
+ 
+ obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
++obj-$(CONFIG_KASAN)		+= kasan_init.o
++
++KASAN_SANITIZE_kasan_init.o     := n
+diff --git a/arch/loongarch/mm/kasan_init.c b/arch/loongarch/mm/kasan_init.c
+new file mode 100644
+index 000000000000..d58da0ca6a92
+--- /dev/null
++++ b/arch/loongarch/mm/kasan_init.c
+@@ -0,0 +1,239 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (C) 2023 Loongson Technology Corporation Limited
++ */
++#define pr_fmt(fmt) "kasan: " fmt
++#include <linux/kasan.h>
++#include <linux/memblock.h>
++#include <linux/sched/task.h>
++
++#include <asm/tlbflush.h>
++#include <asm/pgalloc.h>
++#include <asm-generic/sections.h>
++
++static pgd_t kasan_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);
++
++#ifdef __PAGETABLE_PUD_FOLDED
++#define __p4d_none(early, p4d) (0)
++#else
++#define __p4d_none(early, p4d) (early ? (p4d_val(p4d) == 0) : \
++(__pa(p4d_val(p4d)) == (unsigned long)__pa(kasan_early_shadow_pud)))
++#endif
++
++#define __pud_none(early, pud) (early ? (pud_val(pud) == 0) : \
++(__pa(pud_val(pud)) == (unsigned long)__pa(kasan_early_shadow_pmd)))
++
++#define __pmd_none(early, pmd) (early ? (pmd_val(pmd) == 0) : \
++(__pa(pmd_val(pmd)) == (unsigned long)__pa(kasan_early_shadow_pte)))
++
++#define __pte_none(early, pte) (early ? pte_none(pte) : \
++((pte_val(pte) & _PFN_MASK) == (unsigned long)__pa(kasan_early_shadow_page)))
++
++bool kasan_early_stage = true;
++
++/*
++ * Alloc memory for shadow memory page table.
++ */
++static phys_addr_t __init kasan_alloc_zeroed_page(int node)
++{
++	void *p = memblock_alloc_try_nid(PAGE_SIZE, PAGE_SIZE,
++					__pa(MAX_DMA_ADDRESS), MEMBLOCK_ALLOC_ACCESSIBLE, node);
++	if (!p)
++		panic("%s: Failed to allocate %lu bytes align=0x%lx nid=%d from=%llx\n",
++			__func__, PAGE_SIZE, PAGE_SIZE, node, __pa(MAX_DMA_ADDRESS));
++
++	return __pa(p);
++}
++
++static pte_t *__init kasan_pte_offset(pmd_t *pmdp, unsigned long addr, int node, bool early)
++{
++	if (__pmd_none(early, READ_ONCE(*pmdp))) {
++		phys_addr_t pte_phys = early ?
++				__pa_symbol(kasan_early_shadow_pte) : kasan_alloc_zeroed_page(node);
++		if (!early)
++			memcpy(__va(pte_phys), kasan_early_shadow_pte, sizeof(kasan_early_shadow_pte));
++		pmd_populate_kernel(NULL, pmdp, (pte_t *)__va(pte_phys));
++	}
++
++	return pte_offset_kernel(pmdp, addr);
++}
++
++static pmd_t *__init kasan_pmd_offset(pud_t *pudp, unsigned long addr, int node, bool early)
++{
++	if (__pud_none(early, READ_ONCE(*pudp))) {
++		phys_addr_t pmd_phys = early ?
++				__pa_symbol(kasan_early_shadow_pmd) : kasan_alloc_zeroed_page(node);
++		if (!early)
++			memcpy(__va(pmd_phys), kasan_early_shadow_pmd, sizeof(kasan_early_shadow_pmd));
++		pud_populate(&init_mm, pudp, (pmd_t *)__va(pmd_phys));
++	}
++
++	return pmd_offset(pudp, addr);
++}
++
++static pud_t *__init kasan_pud_offset(p4d_t *p4dp, unsigned long addr, int node, bool early)
++{
++	if (__p4d_none(early, READ_ONCE(*p4dp))) {
++		phys_addr_t pud_phys = early ?
++			__pa_symbol(kasan_early_shadow_pud) : kasan_alloc_zeroed_page(node);
++		if (!early)
++			memcpy(__va(pud_phys), kasan_early_shadow_pud, sizeof(kasan_early_shadow_pud));
++		p4d_populate(&init_mm, p4dp, (pud_t *)__va(pud_phys));
++	}
++
++	return pud_offset(p4dp, addr);
++}
++
++static void __init kasan_pte_populate(pmd_t *pmdp, unsigned long addr,
++				      unsigned long end, int node, bool early)
++{
++	unsigned long next;
++	pte_t *ptep = kasan_pte_offset(pmdp, addr, node, early);
++
++	do {
++		phys_addr_t page_phys = early ?
++					__pa_symbol(kasan_early_shadow_page)
++					      : kasan_alloc_zeroed_page(node);
++		next = addr + PAGE_SIZE;
++		set_pte(ptep, pfn_pte(__phys_to_pfn(page_phys), PAGE_KERNEL));
++	} while (ptep++, addr = next, addr != end && __pte_none(early, READ_ONCE(*ptep)));
++}
++
++static void __init kasan_pmd_populate(pud_t *pudp, unsigned long addr,
++				      unsigned long end, int node, bool early)
++{
++	unsigned long next;
++	pmd_t *pmdp = kasan_pmd_offset(pudp, addr, node, early);
++
++	do {
++		next = pmd_addr_end(addr, end);
++		kasan_pte_populate(pmdp, addr, next, node, early);
++	} while (pmdp++, addr = next, addr != end && __pmd_none(early, READ_ONCE(*pmdp)));
++}
++
++static void __init kasan_pud_populate(p4d_t *p4dp, unsigned long addr,
++					    unsigned long end, int node, bool early)
++{
++	unsigned long next;
++	pud_t *pudp = kasan_pud_offset(p4dp, addr, node, early);
++
++	do {
++		next = pud_addr_end(addr, end);
++		kasan_pmd_populate(pudp, addr, next, node, early);
++	} while (pudp++, addr = next, addr != end);
++}
++
++static void __init kasan_p4d_populate(pgd_t *pgdp, unsigned long addr,
++					    unsigned long end, int node, bool early)
++{
++	unsigned long next;
++	p4d_t *p4dp = p4d_offset(pgdp, addr);
++
++	do {
++		next = p4d_addr_end(addr, end);
++		kasan_pud_populate(p4dp, addr, next, node, early);
++	} while (p4dp++, addr = next, addr != end);
++}
++
++static void __init kasan_pgd_populate(unsigned long addr, unsigned long end,
++				      int node, bool early)
++{
++	unsigned long next;
++	pgd_t *pgdp;
++
++	pgdp = pgd_offset_k(addr);
++
++	do {
++		next = pgd_addr_end(addr, end);
++		kasan_p4d_populate(pgdp, addr, next, node, early);
++	} while (pgdp++, addr = next, addr != end);
++
++}
++
++/* Set up full kasan mappings, ensuring that the mapped pages are zeroed */
++static void __init kasan_map_populate(unsigned long start, unsigned long end,
++				      int node)
++{
++	kasan_pgd_populate(start & PAGE_MASK, PAGE_ALIGN(end), node, false);
++}
++
++asmlinkage void __init kasan_early_init(void)
++{
++	BUILD_BUG_ON(!IS_ALIGNED(KASAN_SHADOW_START, PGDIR_SIZE));
++	BUILD_BUG_ON(!IS_ALIGNED(KASAN_SHADOW_END, PGDIR_SIZE));
++}
++
++static inline void kasan_set_pgd(pgd_t *pgdp, pgd_t pgdval)
++{
++	WRITE_ONCE(*pgdp, pgdval);
++}
++
++static void __init clear_pgds(unsigned long start, unsigned long end)
++{
++	/*
++	 * Remove references to kasan page tables from
++	 * swapper_pg_dir. pgd_clear() can't be used
++	 * here because it's nop on 2,3-level pagetable setups
++	 */
++	for (; start < end; start += PGDIR_SIZE)
++		kasan_set_pgd((pgd_t *)pgd_offset_k(start), __pgd(0));
++}
++
++void __init kasan_init(void)
++{
++	u64 i;
++	phys_addr_t pa_start, pa_end;
++
++	/*
++	 * PGD was populated as invalid_pmd_table or invalid_pud_table
++	 * in pagetable_init() which depends on how many levels of page
++	 * table you are using, but we had to clean the gpd of kasan
++	 * shadow memory, as the pgd value is none-zero.
++	 * The assertion pgd_none is going to be false and the formal populate
++	 * afterwards is not going to create any new pgd at all.
++	 */
++	memcpy(kasan_pg_dir, swapper_pg_dir, sizeof(kasan_pg_dir));
++	csr_write64(__pa_symbol(kasan_pg_dir), LOONGARCH_CSR_PGDH);
++	local_flush_tlb_all();
++
++	clear_pgds(KASAN_SHADOW_START, KASAN_SHADOW_END);
++
++	/* Maps everything to a single page of zeroes */
++	kasan_pgd_populate(KASAN_SHADOW_START, KASAN_SHADOW_END, NUMA_NO_NODE, true);
++
++	kasan_populate_early_shadow(kasan_mem_to_shadow((void *)VMALLOC_START),
++					kasan_mem_to_shadow((void *)VMEMMAP_END));
++
++	kasan_early_stage = false;
++
++	/* Populate the linear mapping */
++	for_each_mem_range(i, &pa_start, &pa_end) {
++		void *start = (void *)phys_to_virt(pa_start);
++		void *end   = (void *)phys_to_virt(pa_end);
++
++		if (start >= end)
++			break;
++
++		kasan_map_populate((unsigned long)kasan_mem_to_shadow(start),
++			(unsigned long)kasan_mem_to_shadow(end), NUMA_NO_NODE);
++	}
++
++	/* Populate modules mapping */
++	kasan_map_populate((unsigned long)kasan_mem_to_shadow((void *)MODULES_VADDR),
++		(unsigned long)kasan_mem_to_shadow((void *)MODULES_END), NUMA_NO_NODE);
++	/*
++	 * Kasan may reuse the contents of kasan_early_shadow_pte directly, so we
++	 * should make sure that it maps the zero page read-only.
++	 */
++	for (i = 0; i < PTRS_PER_PTE; i++)
++		set_pte(&kasan_early_shadow_pte[i],
++			pfn_pte(__phys_to_pfn(__pa_symbol(kasan_early_shadow_page)), PAGE_KERNEL_RO));
++
++	memset(kasan_early_shadow_page, 0, PAGE_SIZE);
++	csr_write64(__pa_symbol(swapper_pg_dir), LOONGARCH_CSR_PGDH);
++	local_flush_tlb_all();
++
++	/* At this point kasan is fully initialized. Enable error messages */
++	init_task.kasan_depth = 0;
++	pr_info("KernelAddressSanitizer initialized.\n");
++}
+diff --git a/arch/loongarch/vdso/Makefile b/arch/loongarch/vdso/Makefile
+index 461240ab4436..4c859a0e4754 100644
+--- a/arch/loongarch/vdso/Makefile
++++ b/arch/loongarch/vdso/Makefile
+@@ -1,6 +1,10 @@
+ # SPDX-License-Identifier: GPL-2.0
+ # Objects to go into the VDSO.
+ 
++ifdef CONFIG_KASAN
++KASAN_SANITIZE := n
++endif
++
+ # Include the generic Makefile to check the built vdso.
+ include $(srctree)/lib/vdso/Makefile
+ 
+-- 
+2.40.1
+
diff -uNr a/debian/patches/loongarch/9001-LoongArch-Add-loongson7A1000-DC-support.patch b/debian/patches/loongarch/9001-LoongArch-Add-loongson7A1000-DC-support.patch
--- a/debian/patches/loongarch/9001-LoongArch-Add-loongson7A1000-DC-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9001-LoongArch-Add-loongson7A1000-DC-support.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,3608 @@
+Index: linux-6.4~rc7/arch/loongarch/configs/loongson3_defconfig
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/configs/loongson3_defconfig
++++ linux-6.4~rc7/arch/loongarch/configs/loongson3_defconfig
+@@ -641,6 +641,7 @@ CONFIG_DRM_AMDGPU_SI=y
+ CONFIG_DRM_AMDGPU_CIK=y
+ CONFIG_DRM_AMDGPU_USERPTR=y
+ CONFIG_DRM_AST=y
++CONFIG_DRM_LOONGSON=y
+ CONFIG_DRM_QXL=m
+ CONFIG_DRM_VIRTIO_GPU=m
+ CONFIG_FB=y
+Index: linux-6.4~rc7/arch/loongarch/include/uapi/asm/unistd.h
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/include/uapi/asm/unistd.h
++++ linux-6.4~rc7/arch/loongarch/include/uapi/asm/unistd.h
+@@ -1,4 +1,5 @@
+ /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
++#define __ARCH_WANT_NEW_STAT
+ #define __ARCH_WANT_SYS_CLONE
+ #define __ARCH_WANT_SYS_CLONE3
+ 
+Index: linux-6.4~rc7/drivers/firmware/sysfb.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/firmware/sysfb.c
++++ linux-6.4~rc7/drivers/firmware/sysfb.c
+@@ -128,4 +128,4 @@ unlock_mutex:
+ }
+ 
+ /* must execute after PCI subsystem for EFI quirks */
+-device_initcall(sysfb_init);
++subsys_initcall_sync(sysfb_init);
+Index: linux-6.4~rc7/drivers/gpio/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpio/Kconfig
++++ linux-6.4~rc7/drivers/gpio/Kconfig
+@@ -377,7 +377,7 @@ config GPIO_LOGICVC
+ 
+ config GPIO_LOONGSON
+ 	bool "Loongson-2/3 GPIO support"
+-	depends on CPU_LOONGSON2EF || CPU_LOONGSON64
++	depends on CPU_LOONGSON2EF || CPU_LOONGSON64 || LOONGARCH
+ 	help
+ 	  Driver for GPIO functionality on Loongson-2F/3A/3B processors.
+ 
+Index: linux-6.4~rc7/drivers/gpio/gpio-loongson.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpio/gpio-loongson.c
++++ linux-6.4~rc7/drivers/gpio/gpio-loongson.c
+@@ -17,15 +17,15 @@
+ #include <linux/platform_device.h>
+ #include <linux/bitops.h>
+ #include <asm/types.h>
+-#include <loongson.h>
++#include <asm/loongson.h>
+ 
+ #define STLS2F_N_GPIO		4
+ #define STLS3A_N_GPIO		16
+ 
+-#ifdef CONFIG_CPU_LOONGSON64
+-#define LOONGSON_N_GPIO	STLS3A_N_GPIO
+-#else
++#ifdef CONFIG_CPU_LOONGSON2EF
+ #define LOONGSON_N_GPIO	STLS2F_N_GPIO
++#else
++#define LOONGSON_N_GPIO	STLS3A_N_GPIO
+ #endif
+ 
+ /*
+Index: linux-6.4~rc7/drivers/gpu/drm/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/Kconfig
++++ linux-6.4~rc7/drivers/gpu/drm/Kconfig
+@@ -289,6 +289,8 @@ source "drivers/gpu/drm/udl/Kconfig"
+ 
+ source "drivers/gpu/drm/ast/Kconfig"
+ 
++source "drivers/gpu/drm/loongson/Kconfig"
++
+ source "drivers/gpu/drm/mgag200/Kconfig"
+ 
+ source "drivers/gpu/drm/armada/Kconfig"
+Index: linux-6.4~rc7/drivers/gpu/drm/Makefile
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/Makefile
++++ linux-6.4~rc7/drivers/gpu/drm/Makefile
+@@ -154,6 +154,7 @@ obj-$(CONFIG_DRM_ROCKCHIP) +=rockchip/
+ obj-$(CONFIG_DRM_GMA500) += gma500/
+ obj-$(CONFIG_DRM_UDL) += udl/
+ obj-$(CONFIG_DRM_AST) += ast/
++obj-$(CONFIG_DRM_LOONGSON) +=loongson/
+ obj-$(CONFIG_DRM_ARMADA) += armada/
+ obj-$(CONFIG_DRM_ATMEL_HLCDC)	+= atmel-hlcdc/
+ obj-y			+= rcar-du/
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/Kconfig
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/Kconfig
+@@ -0,0 +1,18 @@
++
++config DRM_LOONGSON
++	tristate "DRM support for LS7A Display Controller"
++	depends on DRM && PCI
++	select FB_CFB_FILLRECT
++	select FB_CFB_COPYAREA
++	select FB_CFB_IMAGEBLIT
++	select DRM_KMS_HELPER
++	select DRM_KMS_FB_HELPER
++	select DRM_GEM_DMA_HELPER
++	default n
++	help
++	  Support the display controllers found on the Loongson's LS7A
++	  bridge.
++
++	  This driver provides no built-in acceleration; acceleration is
++	  performed by Vivante GC1000. This driver provides kernel mode
++	  setting and buffer management to userspace.
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/Makefile
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/Makefile
+@@ -0,0 +1,16 @@
++#
++# Makefile for the drm device driver.  This driver provides support for the
++# Direct Rendering Infrastructure (DRI)
++#
++
++ccflags-y := -Iinclude/drm
++loongson-y := loongson_drv.o \
++	loongson_i2c.o \
++	loongson_irq.o \
++	loongson_crtc.o \
++	loongson_encoder.o \
++	loongson_connector.o \
++	loongson_cursor.o \
++	loongson_vbios.o
++
++obj-$(CONFIG_DRM_LOONGSON)	+= loongson.o
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_connector.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_connector.c
+@@ -0,0 +1,241 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include <linux/export.h>
++#include <linux/i2c.h>
++#include <linux/i2c-algo-bit.h>
++#include <linux/pm_runtime.h>
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_probe_helper.h>
++#include <drm/drm_edid.h>
++
++#include "loongson_drv.h"
++
++/**
++ * loongson_connector_best_encoder
++ *
++ * @connector: point to the drm_connector structure
++ *
++ * Select the best encoder for the given connector. Used by both the helpers in
++ * drm_atomic_helper_check_modeset() and legacy CRTC helpers
++ */
++static struct drm_encoder *loongson_connector_best_encoder(struct drm_connector
++						  *connector)
++{
++	struct drm_encoder *encoder;
++
++	/* There is only one encoder per connector */
++	drm_connector_for_each_possible_encoder(connector, encoder)
++		return encoder;
++
++	return NULL;
++}
++
++/**
++ * loongson_get_modes
++ *
++ * @connetcor: central DRM connector control structure
++ *
++ * Fill in all modes currently valid for the sink into the connector->probed_modes list.
++ * It should also update the EDID property by calling drm_connector_update_edid_property().
++ */
++static int loongson_get_modes(struct drm_connector *connector)
++{
++	int id, ret = 0;
++	enum loongson_edid_method ledid_method;
++	struct edid *edid = NULL;
++	struct loongson_connector *lconnector = to_loongson_connector(connector);
++	struct i2c_adapter *adapter = lconnector->i2c->adapter;
++
++	id = drm_connector_index(connector);
++
++	ledid_method = lconnector->edid_method;
++	switch (ledid_method) {
++	case via_i2c:
++	case via_encoder:
++	default:
++		edid = drm_get_edid(connector, adapter);
++		break;
++	case via_vbios:
++		edid = kmalloc(EDID_LENGTH * 2, GFP_KERNEL);
++		memcpy(edid, lconnector->vbios_edid, EDID_LENGTH * 2);
++	}
++
++	if (edid) {
++		drm_connector_update_edid_property(connector, edid);
++		ret = drm_add_edid_modes(connector, edid);
++		kfree(edid);
++	} else {
++		ret += drm_add_modes_noedid(connector, 1920, 1080);
++		drm_set_preferred_mode(connector, 1024, 768);
++	}
++
++	return ret;
++}
++
++static bool is_connected(struct loongson_connector *lconnector)
++{
++	unsigned char start = 0x0;
++	struct i2c_adapter *adapter;
++	struct i2c_msg msgs = {
++		.addr = DDC_ADDR,
++		.len = 1,
++		.flags = 0,
++		.buf = &start,
++	};
++
++	if (!lconnector->i2c)
++		return false;
++
++	adapter = lconnector->i2c->adapter;
++	if (i2c_transfer(adapter, &msgs, 1) < 1) {
++		DRM_DEBUG_KMS("display-%d not connect\n", lconnector->id);
++		return false;
++	}
++
++	return true;
++}
++
++/**
++ * loongson_connector_detect
++ *
++ * @connector: point to drm_connector
++ * @force: bool
++ *
++ * Check to see if anything is attached to the connector.
++ * The parameter force is set to false whilst polling,
++ * true when checking the connector due to a user request
++ */
++static enum drm_connector_status loongson_connector_detect(struct drm_connector
++						   *connector, bool force)
++{
++	int r;
++	enum drm_connector_status ret = connector_status_connected;
++	struct loongson_connector *lconnector = to_loongson_connector(connector);
++
++	DRM_DEBUG("loongson_connector_detect connector_id=%d, ledid_method=%d\n",
++			drm_connector_index(connector), lconnector->edid_method);
++
++	if (lconnector->edid_method != via_vbios) {
++		r = pm_runtime_get_sync(connector->dev->dev);
++		if (r < 0)
++			return connector_status_disconnected;
++
++		if (is_connected(lconnector))
++			ret = connector_status_connected;
++		else
++			ret = connector_status_disconnected;
++
++		pm_runtime_mark_last_busy(connector->dev->dev);
++		pm_runtime_put_autosuspend(connector->dev->dev);
++	}
++
++	return ret;
++}
++
++/**
++ * These provide the minimum set of functions required to handle a connector
++ *
++ * Helper operations for connectors.These functions are used
++ * by the atomic and legacy modeset helpers and by the probe helpers.
++ */
++static const struct drm_connector_helper_funcs loongson_connector_helper_funcs = {
++        .get_modes = loongson_get_modes,
++        .best_encoder = loongson_connector_best_encoder,
++};
++
++/**
++ * These provide the minimum set of functions required to handle a connector
++ *
++ * Control connectors on a given device.
++ * The functions below allow the core DRM code to control connectors,
++ * enumerate available modes and so on.
++ */
++static const struct drm_connector_funcs loongson_connector_funcs = {
++	.dpms = drm_helper_connector_dpms,
++	.detect = loongson_connector_detect,
++	.fill_modes = drm_helper_probe_single_connector_modes,
++	.destroy = drm_connector_cleanup,
++	.reset = drm_atomic_helper_connector_reset,
++	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
++};
++
++static const unsigned short normal_i2c[] = { 0x50, I2C_CLIENT_END };
++
++
++/**
++ * loongson_connector_init
++ *
++ * @dev: drm device
++ * @connector_id:
++ *
++ * Vga is the interface between host and monitor
++ * This function is to init vga
++ */
++struct drm_connector *loongson_connector_init(struct drm_device *dev, unsigned int index)
++{
++	struct i2c_adapter *adapter;
++	struct i2c_client *ddc_client;
++	struct drm_connector *connector;
++	struct loongson_encoder *loongson_encoder;
++	struct loongson_connector *loongson_connector;
++	struct loongson_drm_device *ldev = (struct loongson_drm_device*)dev->dev_private;
++
++	const struct i2c_board_info ddc_info = {
++		.type = "ddc-dev",
++		.addr = DDC_ADDR,
++		.flags = I2C_CLASS_DDC,
++	};
++
++	loongson_encoder = ldev->mode_info[index].encoder; 
++	adapter = loongson_encoder->i2c->adapter;
++	ddc_client = i2c_new_client_device(adapter, &ddc_info);
++	if (IS_ERR(ddc_client)) {
++		i2c_del_adapter(adapter);
++		DRM_ERROR("Failed to create standard ddc client\n");
++		return NULL;
++	}
++
++	loongson_connector = kzalloc(sizeof(struct loongson_connector), GFP_KERNEL);
++	if (!loongson_connector)
++		return NULL;
++
++	ldev->connector_active0 = 0;
++	ldev->connector_active1 = 0;
++	loongson_connector->id = index;
++	loongson_connector->ldev = ldev;
++	loongson_connector->type = get_connector_type(ldev, index);
++	loongson_connector->i2c_id = get_connector_i2cid(ldev, index);
++	loongson_connector->hotplug = get_hotplug_mode(ldev, index);
++	loongson_connector->edid_method = get_edid_method(ldev, index);
++	if (loongson_connector->edid_method == via_vbios)
++		loongson_connector->vbios_edid = get_vbios_edid(ldev, index);
++
++	loongson_connector->i2c = &ldev->i2c_bus[index];
++	if (!loongson_connector->i2c)
++		DRM_INFO("connector-%d match i2c-%d err\n", index,
++			 loongson_connector->i2c_id);
++
++	connector = &loongson_connector->base;
++
++	drm_connector_helper_add(connector, &loongson_connector_helper_funcs);
++
++	drm_connector_init(dev, connector,
++			   &loongson_connector_funcs, loongson_connector->type);
++
++	drm_connector_register(connector);
++
++	return connector;
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_crtc.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_crtc.c
+@@ -0,0 +1,510 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ *	Jiaxun Yang <jiaxun.yang@flygoat.com>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include <linux/delay.h>
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_plane.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_plane_helper.h>
++#include <drm/drm_fb_dma_helper.h>
++#include <drm/drm_fourcc.h>
++#include <drm/drm_framebuffer.h>
++#include <drm/drm_gem_dma_helper.h>
++#include "loongson_drv.h"
++
++/**
++ * This file contains setup code for the CRTC
++ */
++
++DEFINE_SPINLOCK(loongson_crtc_lock);
++
++static int loongson_crtc_enable_vblank(struct drm_crtc *crtc)
++{
++	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
++	struct loongson_drm_device *ldev = lcrtc->ldev;
++
++	if(lcrtc->crtc_id == 0) {
++		ldev->int_reg |= (BIT(INT_DVO0_FB_END) << 16);
++	} else {
++		ldev->int_reg |= (BIT(INT_DVO1_FB_END) << 16);
++	}
++
++	spin_lock(&loongson_reglock);
++	writel(ldev->int_reg, ldev->mmio + FB_INT_REG);
++	spin_unlock(&loongson_reglock);
++
++	return 0;
++}
++
++static void loongson_crtc_disable_vblank(struct drm_crtc *crtc)
++{
++	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
++	struct loongson_drm_device *ldev = lcrtc->ldev;
++
++
++	if(lcrtc->crtc_id == 0) {
++		ldev->int_reg &= (~BIT(INT_DVO0_FB_END) << 16);
++	} else {
++		ldev->int_reg &= (~BIT(INT_DVO1_FB_END) << 16);
++	}
++
++	spin_lock(&loongson_reglock);
++	writel(ldev->int_reg, ldev->mmio + FB_INT_REG);
++	spin_unlock(&loongson_reglock);
++}
++
++#define PLL_REF_CLK_MHZ    100
++#define PCLK_PRECISION_INDICATOR 10000
++
++/**
++ * cal_freq
++ *
++ * @pixclock: unsigned int
++ * @pll_config: point to the pix_pll structure
++ *
++ * Calculate frequency
++ */
++static unsigned int cal_freq(unsigned int pixclock, struct pix_pll *pll_config)
++{
++	int i, j, loopc_offset;
++	unsigned int refc_set[] = {4, 5, 3};
++	unsigned int prec_set[] = {1, 5, 10, 50, 100};   /*in 1/PCLK_PRECISION_INDICATOR*/
++	unsigned int pstdiv, loopc, refc;
++	unsigned int precision_req, precision;
++	unsigned int loopc_min, loopc_max, loopc_mid;
++	unsigned long long real_dvo, req_dvo;
++
++	/*try precision from high to low*/
++	for (j = 0; j < sizeof(prec_set)/sizeof(int); j++){
++		precision_req = prec_set[j];
++
++		/*try each refc*/
++		for (i = 0; i < sizeof(refc_set)/sizeof(int); i++) {
++			refc = refc_set[i];
++			loopc_min = (1200 / PLL_REF_CLK_MHZ) * refc;  /*1200 / (PLL_REF_CLK_MHZ / refc)*/
++			loopc_max = (3200 / PLL_REF_CLK_MHZ) * refc;  /*3200 / (PLL_REF_CLK_MHZ / refc)*/
++			loopc_mid = (2200 / PLL_REF_CLK_MHZ) * refc;  /*(loopc_min + loopc_max) / 2;*/
++			loopc_offset = -1;
++
++			/*try each loopc*/
++			for (loopc = loopc_mid; (loopc <= loopc_max) && (loopc >= loopc_min); loopc += loopc_offset) {
++				if(loopc_offset < 0)
++					loopc_offset = -loopc_offset;
++				else
++					loopc_offset = -(loopc_offset+1);
++
++				pstdiv = loopc * PLL_REF_CLK_MHZ * 1000 / refc / pixclock;
++				if((pstdiv > 127) || (pstdiv < 1))
++					continue;
++
++				/*real_freq is float type which is not available, but read_freq * pstdiv is available.*/
++				req_dvo  = (pixclock * pstdiv);
++				real_dvo = (loopc * PLL_REF_CLK_MHZ * 1000 / refc);
++				precision = abs(real_dvo * PCLK_PRECISION_INDICATOR / req_dvo - PCLK_PRECISION_INDICATOR);
++
++				if(precision < precision_req){
++					pll_config->l2_div = pstdiv;
++					pll_config->l1_loopc = loopc;
++					pll_config->l1_frefc = refc;
++					if(j > 1)
++						printk("Warning: PIX clock precision degraded to %d / %d\n", precision_req, PCLK_PRECISION_INDICATOR);
++					return 1;
++				}
++			}
++		}
++	}
++	return 0;
++}
++
++/**
++ * config_pll
++ *
++ * @pll_base: represent a long type
++ * @pll_cfg: point to the pix_pll srtucture
++ *
++ * Config pll apply to ls7a
++ */
++static void config_pll(void *pll_base, struct pix_pll *pll_cfg)
++{
++	unsigned long val;
++
++	/* clear sel_pll_out0 */
++	val = readl(pll_base + 0x4);
++	val &= ~(1UL << 8);
++	writel(val, pll_base + 0x4);
++	/* set pll_pd */
++	val = readl(pll_base + 0x4);
++	val |= (1UL << 13);
++	writel(val, pll_base + 0x4);
++	/* clear set_pll_param */
++	val = readl(pll_base + 0x4);
++	val &= ~(1UL << 11);
++	writel(val, pll_base + 0x4);
++	/* clear old value & config new value */
++	val = readl(pll_base + 0x4);
++	val &= ~(0x7fUL << 0);
++	val |= (pll_cfg->l1_frefc << 0); /* refc */
++	writel(val, pll_base + 0x4);
++	val = readl(pll_base + 0x0);
++	val &= ~(0x7fUL << 0);
++	val |= (pll_cfg->l2_div << 0);   /* div */
++	val &= ~(0x1ffUL << 21);
++	val |= (pll_cfg->l1_loopc << 21);/* loopc */
++	writel(val, pll_base + 0x0);
++	/* set set_pll_param */
++	val = readl(pll_base + 0x4);
++	val |= (1UL << 11);
++	writel(val, pll_base + 0x4);
++	/* clear pll_pd */
++	val = readl(pll_base + 0x4);
++	val &= ~(1UL << 13);
++	writel(val, pll_base + 0x4);
++	/* wait pll lock */
++	while(!(readl(pll_base + 0x4) & 0x80))
++		cpu_relax();
++	/* set sel_pll_out0 */
++	val = readl(pll_base + 0x4);
++	val |= (1UL << 8);
++	writel(val, pll_base + 0x4);
++}
++
++static void loongson_config_pll(int id, unsigned int pix_freq)
++{
++	unsigned int out;
++	struct pix_pll pll_cfg;
++
++	out = cal_freq(pix_freq, &pll_cfg);
++	if (id == 0)
++		config_pll(LS7A_PIX0_PLL, &pll_cfg);
++	else
++		config_pll(LS7A_PIX1_PLL, &pll_cfg);
++}
++
++/**
++ * These provide the minimum set of functions required to handle a CRTC
++ * Each driver is responsible for filling out this structure at startup time
++ *
++ * The drm_crtc_funcs structure is the central CRTC management structure
++ * in the DRM. Each CRTC controls one or more connectors
++ */
++static const struct drm_crtc_funcs loongson_swcursor_crtc_funcs = {
++	.destroy = drm_crtc_cleanup,
++	.set_config = drm_atomic_helper_set_config,
++	.page_flip = drm_atomic_helper_page_flip,
++	.reset = drm_atomic_helper_crtc_reset,
++	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
++	.enable_vblank = loongson_crtc_enable_vblank,
++	.disable_vblank = loongson_crtc_disable_vblank,
++};
++
++static const struct drm_crtc_funcs loongson_hwcursor_crtc_funcs = {
++	.cursor_set2 = loongson_crtc_cursor_set2,
++	.cursor_move = loongson_crtc_cursor_move,
++	.destroy = drm_crtc_cleanup,
++	.set_config = drm_atomic_helper_set_config,
++	.page_flip = drm_atomic_helper_page_flip,
++	.reset = drm_atomic_helper_crtc_reset,
++	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
++	.enable_vblank = loongson_crtc_enable_vblank,
++	.disable_vblank = loongson_crtc_disable_vblank,
++};
++
++static const uint32_t loongson_formats[] = {
++	DRM_FORMAT_RGB565,
++	DRM_FORMAT_RGB888,
++	DRM_FORMAT_XRGB8888,
++	DRM_FORMAT_ARGB8888,
++};
++
++static const uint64_t loongson_format_modifiers[] = {
++	DRM_FORMAT_MOD_LINEAR,
++	DRM_FORMAT_MOD_INVALID
++};
++
++static enum drm_mode_status loongson_crtc_mode_valid(struct drm_crtc *crtc,
++						    const struct drm_display_mode *mode)
++{
++	int id = crtc->index;
++	struct drm_device *dev = crtc->dev;
++	struct loongson_drm_device *ldev = (struct loongson_drm_device*)dev->dev_private;
++
++	if (mode->hdisplay > get_crtc_max_width(ldev, id))
++		return MODE_BAD;
++	if (mode->vdisplay > get_crtc_max_height(ldev, id))
++		return MODE_BAD;
++	if (ldev->num_crtc == 1) {
++		if (mode->hdisplay % 16)
++			return MODE_BAD;
++	} else {
++		if (mode->hdisplay % 64)
++			return MODE_BAD;
++	}
++
++	return MODE_OK;
++}
++
++u32 crtc_read(struct loongson_crtc *lcrtc, u32 offset)
++{
++	struct loongson_drm_device *ldev = lcrtc->ldev;
++	return readl(ldev->mmio + offset + (lcrtc->crtc_id * CRTC_REG_OFFSET));
++}
++
++void crtc_write(struct loongson_crtc *lcrtc, u32 offset, u32 val)
++{
++	struct loongson_drm_device *ldev = lcrtc->ldev;
++	writel(val, ldev->mmio + offset + (lcrtc->crtc_id * CRTC_REG_OFFSET));
++}
++
++static void loongson_crtc_mode_set_nofb(struct drm_crtc *crtc)
++{
++	unsigned int hr, hss, hse, hfl;
++	unsigned int vr, vss, vse, vfl;
++	unsigned int pix_freq;
++	unsigned long flags;
++	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
++	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
++
++	hr	= mode->hdisplay;
++	hss	= mode->hsync_start;
++	hse	= mode->hsync_end;
++	hfl	= mode->htotal;
++
++	vr	= mode->vdisplay;
++	vss	= mode->vsync_start;
++	vse	= mode->vsync_end;
++	vfl	= mode->vtotal;
++
++	pix_freq = mode->clock;
++
++	DRM_DEBUG("crtc_id = %d, hr = %d, hss = %d, hse = %d, hfl = %d, vr = %d, vss = %d, vse = %d, vfl = %d, pix_freq = %d,\n",
++			lcrtc->crtc_id, hr, hss, hse, hfl, vr, vss, vse, vfl, pix_freq);
++
++	spin_lock_irqsave(&loongson_reglock, flags);
++	crtc_write(lcrtc, FB_DITCFG_DVO_REG, 0);
++	crtc_write(lcrtc, FB_DITTAB_LO_DVO_REG, 0);
++	crtc_write(lcrtc, FB_DITTAB_HI_DVO_REG, 0);
++	crtc_write(lcrtc, FB_PANCFG_DVO_REG, 0x80001311);
++	crtc_write(lcrtc, FB_PANTIM_DVO_REG, 0);
++
++	crtc_write(lcrtc, FB_HDISPLAY_DVO_REG, (mode->crtc_htotal << 16) | mode->crtc_hdisplay);
++	crtc_write(lcrtc, FB_HSYNC_DVO_REG, 0x40000000 | (mode->crtc_hsync_end << 16) | mode->crtc_hsync_start);
++
++	crtc_write(lcrtc, FB_VDISPLAY_DVO_REG, (mode->crtc_vtotal << 16) | mode->crtc_vdisplay);
++	crtc_write(lcrtc, FB_VSYNC_DVO_REG, 0x40000000 | (mode->crtc_vsync_end << 16) | mode->crtc_vsync_start);
++
++	crtc_write(lcrtc, FB_STRI_DVO_REG, (crtc->primary->state->fb->pitches[0] + 255) & ~255);
++
++	DRM_DEBUG("Stride: %x\n",(crtc->primary->state->fb->pitches[0] + 255) & ~255);
++
++	switch (crtc->primary->state->fb->format->format) {
++	case DRM_FORMAT_RGB565:
++		lcrtc->cfg_reg |= 0x3;
++		crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
++		break;
++	case DRM_FORMAT_RGB888:
++	default:
++		lcrtc->cfg_reg |= 0x4;
++		crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
++		break;
++	}
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++
++	loongson_config_pll(lcrtc->crtc_id, mode->clock);
++}
++
++static void loongson_crtc_atomic_enable(struct drm_crtc *crtc,
++				       struct drm_atomic_state *state)
++{
++	unsigned long flags;
++	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
++
++	if (lcrtc->cfg_reg & CFG_ENABLE)
++		goto vblank_on;
++
++	lcrtc->cfg_reg |= CFG_ENABLE;
++	spin_lock_irqsave(&loongson_reglock, flags);
++	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++
++vblank_on:
++	drm_crtc_vblank_on(crtc);
++}
++
++static void loongson_crtc_atomic_disable(struct drm_crtc *crtc,
++					struct drm_atomic_state *state)
++{
++	unsigned long flags;
++	struct loongson_crtc *lcrtc = to_loongson_crtc(crtc);
++
++	lcrtc->cfg_reg &= ~CFG_ENABLE;
++	spin_lock_irqsave(&loongson_reglock, flags);
++	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++
++	spin_lock_irq(&crtc->dev->event_lock);
++	if (crtc->state->event) {
++		drm_crtc_send_vblank_event(crtc, crtc->state->event);
++		crtc->state->event = NULL;
++	}
++	spin_unlock_irq(&crtc->dev->event_lock);
++
++	drm_crtc_vblank_off(crtc);
++}
++
++static void loongson_crtc_atomic_flush(struct drm_crtc *crtc,
++				  struct drm_atomic_state *state)
++{
++	struct drm_pending_vblank_event *event = crtc->state->event;
++
++	if (event) {
++		crtc->state->event = NULL;
++
++		spin_lock_irq(&crtc->dev->event_lock);
++		if (drm_crtc_vblank_get(crtc) == 0)
++			drm_crtc_arm_vblank_event(crtc, event);
++		else
++			drm_crtc_send_vblank_event(crtc, event);
++		spin_unlock_irq(&crtc->dev->event_lock);
++	}
++}
++
++static void loongson_plane_atomic_update(struct drm_plane *plane,
++					 struct drm_atomic_state *state)
++{
++	int id, clonemode;
++	unsigned int pitch;
++	unsigned long flags;
++	struct loongson_crtc *lcrtc;
++	struct loongson_drm_device *ldev;
++	struct drm_plane_state *pstate = plane->state;
++
++	if (!pstate->crtc || !pstate->fb)
++		return;
++
++	pitch = pstate->fb->pitches[0];
++	lcrtc = to_loongson_crtc(pstate->crtc);
++	ldev = lcrtc->ldev;
++	id = lcrtc->crtc_id;
++	clonemode = clone_mode(ldev);
++
++	/* CRTC1 cloned from CRTC0 in clone mode */
++	if (clonemode)
++		ldev->lcrtc[1].cfg_reg |= CFG_PANELSWITCH;
++	else
++		ldev->lcrtc[1].cfg_reg &= ~CFG_PANELSWITCH;
++
++	spin_lock_irqsave(&loongson_reglock, flags);
++	crtc_write(lcrtc, FB_STRI_DVO_REG, (pitch + 255) & ~255);
++	if (crtc_read(lcrtc, FB_CFG_DVO_REG) & CFG_FBNUM)
++		crtc_write(lcrtc, FB_ADDR0_DVO_REG, drm_fb_dma_get_gem_addr(pstate->fb, pstate, 0));
++	else
++		crtc_write(lcrtc, FB_ADDR1_DVO_REG, drm_fb_dma_get_gem_addr(pstate->fb, pstate, 0));
++
++	lcrtc->cfg_reg |= CFG_ENABLE;
++	crtc_write(lcrtc, FB_CFG_DVO_REG, lcrtc->cfg_reg | CFG_FBSWITCH);
++	if (clonemode) {
++		if (id)
++			crtc_write(&ldev->lcrtc[0], FB_CFG_DVO_REG, ldev->lcrtc[0].cfg_reg | CFG_ENABLE);
++		else
++			crtc_write(&ldev->lcrtc[1], FB_CFG_DVO_REG, ldev->lcrtc[1].cfg_reg | CFG_ENABLE);
++	}
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++
++	udelay(2500);
++}
++
++/**
++ * These provide the minimum set of functions required to handle a CRTC
++ *
++ * The drm_crtc_helper_funcs is a helper operations for CRTC
++ */
++static const struct drm_crtc_helper_funcs loongson_crtc_helper_funcs = {
++	.mode_valid = loongson_crtc_mode_valid,
++	.mode_set_nofb	= loongson_crtc_mode_set_nofb,
++	.atomic_enable	= loongson_crtc_atomic_enable,
++	.atomic_disable	= loongson_crtc_atomic_disable,
++	.atomic_flush	= loongson_crtc_atomic_flush,
++};
++
++static void loongson_plane_destroy(struct drm_plane *plane)
++{
++	drm_plane_cleanup(plane);
++}
++
++static bool loongson_format_mod_supported(struct drm_plane *plane,
++					   uint32_t format, uint64_t modifier)
++{
++	return (modifier == DRM_FORMAT_MOD_LINEAR);
++}
++
++static const struct drm_plane_funcs loongson_plane_funcs = {
++	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
++	.destroy = loongson_plane_destroy,
++	.disable_plane = drm_atomic_helper_disable_plane,
++	.reset = drm_atomic_helper_plane_reset,
++	.update_plane = drm_atomic_helper_update_plane,
++	.format_mod_supported = loongson_format_mod_supported,
++};
++
++static const struct drm_plane_helper_funcs loongson_plane_helper_funcs = {
++	.atomic_update = loongson_plane_atomic_update,
++};
++
++/**
++ * loongosn_crtc_init
++ *
++ * @ldev: point to the loongson_drm_device structure
++ *
++ * Init CRTC
++ */
++int loongson_crtc_init(struct loongson_drm_device *ldev)
++{
++	int i, ret;
++	extern bool hw_cursor;
++
++	for(i=0;i<ldev->num_crtc;i++){
++		ldev->lcrtc[i].ldev = ldev;
++		ldev->lcrtc[i].crtc_id = i;
++
++		ldev->lcrtc[i].cfg_reg = CFG_RESET;
++		ldev->lcrtc[i].primary = devm_kzalloc(ldev->dev->dev, sizeof(*ldev->lcrtc[i].primary), GFP_KERNEL);
++		if (!ldev->lcrtc[i].primary)
++			return -ENOMEM;
++
++		ret = drm_universal_plane_init(ldev->dev, ldev->lcrtc[i].primary, BIT(i), &loongson_plane_funcs,
++				       loongson_formats, ARRAY_SIZE(loongson_formats),
++				       loongson_format_modifiers, DRM_PLANE_TYPE_PRIMARY, NULL);
++		if (ret)
++			return ret;
++
++		drm_plane_helper_add(ldev->lcrtc[i].primary, &loongson_plane_helper_funcs);
++
++		if (hw_cursor)
++			ret = drm_crtc_init_with_planes(ldev->dev, &ldev->lcrtc[i].base,ldev->lcrtc[i].primary,
++					NULL, &loongson_hwcursor_crtc_funcs, NULL);
++		else
++			ret = drm_crtc_init_with_planes(ldev->dev, &ldev->lcrtc[i].base,ldev->lcrtc[i].primary,
++					NULL, &loongson_swcursor_crtc_funcs, NULL);
++		if (ret) {
++			loongson_plane_destroy(ldev->lcrtc[i].primary);
++			return ret;
++		}
++		drm_crtc_helper_add(&ldev->lcrtc[i].base, &loongson_crtc_helper_funcs);
++	}
++
++	return 0;
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_cursor.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_cursor.c
+@@ -0,0 +1,188 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include <drm/drm_gem_dma_helper.h>
++#include "loongson_drv.h"
++
++/*
++  Hide the cursor off screen. We can't disable the cursor hardware because it
++  takes too long to re-activate and causes momentary corruption
++*/
++static void loongson_hide_cursor(struct drm_crtc *crtc)
++{
++	unsigned long flags;
++	volatile void __iomem *base;
++	struct drm_device *dev = crtc->dev;
++	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
++	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
++	unsigned int tmp, crtc_id = loongson_crtc->crtc_id;
++
++	base = ldev->mmio;
++	tmp = readl(base + FB_CUR_CFG_REG);
++	tmp &= ~0xff;
++	if (clone_mode(ldev)) {
++		spin_lock_irqsave(&loongson_reglock, flags);
++		writel(tmp | 0x00, base + FB_CUR_CFG_REG);
++		spin_unlock_irqrestore(&loongson_reglock, flags);
++		ldev->cursor_showed = false;
++	} else {
++		if (ldev->cursor_crtc_id != crtc_id)
++			return;
++
++		spin_lock_irqsave(&loongson_reglock, flags);
++		if (crtc_id) {
++			writel(tmp | 0x10, base + FB_CUR_CFG_REG);
++		} else {
++			writel(tmp | 0x00, base + FB_CUR_CFG_REG);
++		}
++		spin_unlock_irqrestore(&loongson_reglock, flags);
++		ldev->cursor_showed = false;
++	}
++}
++
++static void loongson_show_cursor(struct drm_crtc *crtc)
++{
++	unsigned long flags;
++	volatile void __iomem *base;
++	struct drm_device *dev = crtc->dev;
++	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
++	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
++	unsigned int crtc_id = loongson_crtc->crtc_id;
++
++	base = ldev->mmio;
++	if (clone_mode(ldev)) {
++		spin_lock_irqsave(&loongson_reglock, flags);
++		writel(0x00050202, base + FB_CUR_CFG_REG);
++		spin_unlock_irqrestore(&loongson_reglock, flags);
++		ldev->cursor_crtc_id = 0;
++		ldev->cursor_showed = true;
++	} else {
++		if (ldev->cursor_crtc_id == crtc_id) {
++			spin_lock_irqsave(&loongson_reglock, flags);
++			if(crtc_id == 0){
++				writel(0x00050202, base + FB_CUR_CFG_REG);
++		        }else{
++				writel(0x00050212, base + FB_CUR_CFG_REG);
++			}
++			spin_unlock_irqrestore(&loongson_reglock, flags);
++
++			ldev->cursor_showed = true;
++			ldev->cursor_crtc_id = crtc_id;
++		}
++	}
++}
++
++int loongson_crtc_cursor_set2(struct drm_crtc *crtc,
++			struct drm_file *file_priv,
++			uint32_t handle,
++			uint32_t width,
++			uint32_t height,
++			int32_t hot_x, int32_t hot_y)
++{
++	u32 gpu_addr;
++	unsigned long flags;
++	unsigned int crtc_id;
++	volatile void __iomem *base;
++	struct drm_gem_object *obj;
++	struct drm_device *dev = crtc->dev;
++	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
++	struct loongson_drm_device *ldev = (struct loongson_drm_device *)dev->dev_private;
++	struct drm_gem_dma_object *cma, *cursor = ldev->cursor;
++
++	base = ldev->mmio;
++        crtc_id = loongson_crtc->crtc_id;
++
++	if ((width != 32 || height != 32) && handle) {
++		return -EINVAL;
++	}
++
++	if (!handle || !file_priv) {
++		loongson_hide_cursor(crtc);
++		return 0;
++	}
++
++	obj = drm_gem_object_lookup(file_priv, handle);
++	if (!obj)
++		return -ENOENT;
++
++	cma = to_drm_gem_dma_obj(obj);
++
++	memcpy(cursor->vaddr, cma->vaddr, 32*32*4);
++
++	/* Program gpu address of cursor buffer */
++	gpu_addr = ldev->cursor->dma_addr;
++	spin_lock_irqsave(&loongson_reglock, flags);
++	writel(gpu_addr, base + FB_CUR_ADDR_REG);
++	writel(0x00eeeeee, base + FB_CUR_BACK_REG);
++	writel(0x00aaaaaa, base + FB_CUR_FORE_REG);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++
++	loongson_show_cursor(crtc);
++
++	drm_gem_object_put(obj);
++
++	return 0;
++}
++
++int loongson_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
++{
++	unsigned long flags;
++	unsigned int tmp, crtc_id;
++	int xorign = 0, yorign = 0;
++	volatile void __iomem *base;
++	struct loongson_crtc *loongson_crtc = to_loongson_crtc(crtc);
++	struct loongson_drm_device *ldev = (struct loongson_drm_device *)crtc->dev->dev_private;
++
++	base = ldev->mmio;
++        crtc_id = loongson_crtc->crtc_id;
++
++	/* upper edge condition */
++	yorign = y + crtc->y;
++	if (yorign < 0)
++		y = 0;
++
++	/* left edge conditon */
++	xorign = x + crtc->x;
++	if (xorign < 0)
++		x = 0;
++
++	/* move from one crtc to another, check which crtc should he shown
++	 * the x or y < 0, it means the cursor it out of current review,
++	 * && xorign/ yorign > 0, it means the cursor is in the framebuffer
++	 * but not in curren review */
++	if ((x < 0 && xorign > 0) || (y < 0 && yorign > 0)) {
++		if(ldev->cursor_crtc_id == crtc_id && !clone_mode(ldev))
++		 /*the cursor is not show, so hide if the (x,y) is in active crtc*/
++			loongson_hide_cursor(crtc);
++		return 0;
++	}
++
++	if (x < 0)
++		x = 0;
++	if (y < 0)
++		y = 0;
++
++	tmp = x & 0xffff;
++	tmp |= y << 16;
++	spin_lock_irqsave(&loongson_reglock, flags);
++	writel(tmp, base + FB_CUR_LOC_ADDR_REG);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++	if (ldev->cursor_crtc_id != crtc_id && !clone_mode(ldev)) {
++		ldev->cursor_crtc_id = crtc_id;
++		ldev->cursor_showed = false;
++	}
++	if (!ldev->cursor_showed)
++		loongson_show_cursor(crtc);
++
++	return 0;
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_drv.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_drv.c
+@@ -0,0 +1,641 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhuacai@loongson.cn>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include <asm/addrspace.h>
++#include <linux/init.h>
++#include <linux/kernel.h>
++#include <linux/dma-mapping.h>
++#include <linux/console.h>
++#include <linux/device.h>
++#include <linux/slab.h>
++#include <linux/pci.h>
++#include <linux/pci_ids.h>
++#include <linux/module.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/vgaarb.h>
++#include <linux/vga_switcheroo.h>
++
++#include <drm/drm_aperture.h>
++#include <drm/drm_atomic_helper.h>
++#include <drm/drm_crtc_helper.h>
++#include <drm/drm_probe_helper.h>
++#include <drm/drm_gem_dma_helper.h>
++#include <drm/drm_gem_framebuffer_helper.h>
++#include "loongson_drv.h"
++
++#define DEVICE_NAME	"loongson-drm"
++#define DRIVER_NAME	"loongson-drm"
++#define DRIVER_DESC	"Loongson DRM Driver"
++#define DRIVER_DATE	"20201201"
++#define DRIVER_MAJOR	1
++#define DRIVER_MINOR	0
++#define DRIVER_PATCHLEVEL	1
++
++#define PCI_DEVICE_ID_LOONGSON_DC1	0x7a06
++#define PCI_DEVICE_ID_LOONGSON_DC2	0x7a36
++
++bool hw_cursor = false;
++module_param_named(cursor, hw_cursor, bool, 0600);
++
++bool poll_connector = false;
++module_param_named(poll, poll_connector, bool, 0600);
++
++DEFINE_SPINLOCK(loongson_reglock);
++
++static struct drm_driver loongson_drm_driver;
++
++/**
++ * loongson_mode_funcs---basic driver provided mode setting functions
++ *
++ * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
++ * involve drivers.
++ */
++static const struct drm_mode_config_funcs loongson_mode_funcs = {
++	.fb_create = drm_gem_fb_create,
++	.atomic_check = drm_atomic_helper_check,
++	.atomic_commit = drm_atomic_helper_commit,
++	.output_poll_changed = drm_fb_helper_output_poll_changed
++};
++
++/**
++ *  loongson_drm_device_init  ----init drm device
++ *
++ * @dev   pointer to drm_device structure
++ * @flags start up flag
++ *
++ * RETURN
++ *   drm device init result
++ */
++static int loongson_drm_device_init(struct drm_device *dev, uint32_t flags)
++{
++	int ret = 0;
++	struct loongson_drm_device *ldev = dev->dev_private;
++
++	ldev->num_crtc = 2;
++	loongson_vbios_init(ldev);
++
++	/*BAR 0 contains registers */
++	ldev->mmio_base = pci_resource_start(to_pci_dev(dev->dev), 0);
++	ldev->mmio_size = pci_resource_len(to_pci_dev(dev->dev), 0);
++
++	ldev->mmio = pcim_iomap(to_pci_dev(dev->dev), 0, 0);
++	if (ldev->mmio == NULL)
++		return -ENOMEM;
++
++	DRM_INFO("ldev->mmio_base = 0x%llx, ldev->mmio_size = 0x%llx\n",
++			ldev->mmio_base, ldev->mmio_size);
++
++	if (!devm_request_mem_region(ldev->dev->dev, ldev->mmio_base, ldev->mmio_size,
++			"loongson_drmfb_mmio")) {
++		DRM_ERROR("Can't reserve mmio registers\n");
++		return -ENOMEM;
++	}
++
++	ret = loongson_gpio_init(ldev);
++	if (ret < 0)
++		DRM_ERROR("Failed to initialize dc gpios\n");
++
++	return ret;
++}
++
++/**
++ * loongson_modeset_init --- init kernel mode setting
++ *
++ * @ldev: pointer to loongson_drm_device structure
++ *
++ * RETURN
++ *  return init result
++ */
++int loongson_modeset_init(struct loongson_drm_device *ldev)
++{
++	int i, ret;
++	struct drm_encoder *encoder;
++	struct drm_connector *connector;
++
++	ldev->mode_info[0].mode_config_initialized = true;
++	ldev->mode_info[1].mode_config_initialized = true;
++
++	ldev->dev->mode_config.max_width = LOONGSON_MAX_FB_WIDTH;
++	ldev->dev->mode_config.max_height = LOONGSON_MAX_FB_HEIGHT;
++
++	ldev->dev->mode_config.cursor_width = 32;
++	ldev->dev->mode_config.cursor_height = 32;
++
++	ret = loongson_i2c_init(ldev);
++	if (ret < 0) {
++		DRM_ERROR("Failed to initialize i2c\n");
++		return ret;
++	}
++
++	loongson_crtc_init(ldev);
++
++	for (i=0; i<ldev->num_crtc; i++) {
++		DRM_DEBUG("loongson drm encoder init\n");
++		ldev->mode_info[i].crtc = &ldev->lcrtc[i];
++		encoder = loongson_encoder_init(ldev->dev, i);
++		if (!encoder) {
++			DRM_ERROR("loongson_encoder_init failed\n");
++			return -1;
++		}
++		ldev->mode_info[i].encoder = to_loongson_encoder(encoder);
++
++		DRM_DEBUG("loongson drm connector init\n");
++		connector = loongson_connector_init(ldev->dev, i);
++		if (!connector) {
++			DRM_ERROR("loongson_connector_init failed\n");
++			return -1;
++		}
++		ldev->mode_info[i].connector = to_loongson_connector(connector);
++
++		drm_connector_attach_encoder(connector, encoder);
++		if (poll_connector)
++			connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;
++	}
++
++	return 0;
++}
++
++/**
++ * loongson_modeset_fini --- deinit kernel mode setting
++ *
++ * @ldev: pointer to loongson_drm_device structure
++ *
++ * RETURN
++ */
++void loongson_modeset_fini(struct loongson_drm_device *ldev)
++{
++}
++
++static int loongson_detect_chip(struct loongson_drm_device *ldev)
++{
++	struct pci_dev *pdev;
++
++	pdev = pci_get_device(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC1, NULL);
++	if (pdev) {
++		ldev->chip = dc_7a1000;
++		DRM_INFO("Set LS7A1000 DC device\n");
++		return 0;
++	}
++
++	pdev = pci_get_device(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC2, NULL);
++	if (pdev) {
++		ldev->chip = dc_7a2000;
++		DRM_INFO("Set LS7A2000 DC device\n");
++		return 0;
++	}
++
++	return -1;
++}
++
++/**
++ * loongson_vga_load - setup chip and create an initial config
++ * @dev: DRM device
++ * @flags: startup flags
++ *
++ * The driver load routine has to do several things:
++ *   - initialize the memory manager
++ *   - allocate initial config memory
++ *   - setup the DRM framebuffer with the allocated memory
++ */
++static int loongson_drm_load(struct drm_device *dev, unsigned long flags)
++{
++	int r, ret, irq;
++	struct pci_dev *pdev;
++	struct loongson_drm_device *ldev;
++
++	dma_set_mask_and_coherent(dev->dev, DMA_BIT_MASK(32));
++
++	ldev = devm_kzalloc(dev->dev, sizeof(struct loongson_drm_device), GFP_KERNEL);
++	if (ldev == NULL)
++		return -ENOMEM;
++	dev->dev_private = (void *)ldev;
++	ldev->dev = dev;
++	pdev = to_pci_dev(dev->dev);
++
++	ret = loongson_detect_chip(ldev);
++	if (ret)
++		dev_err(dev->dev, "Fatal error during detect chip: %d\n", ret);
++
++	ret = loongson_drm_device_init(dev, flags);
++	DRM_DEBUG("end loongson drm device init.\n");
++
++	drm_mode_config_init(dev);
++	dev->mode_config.funcs = (void *)&loongson_mode_funcs;
++	dev->mode_config.preferred_depth = 24;
++	dev->mode_config.prefer_shadow = 1;
++
++	irq = pdev->irq;
++	pci_set_drvdata(pdev, dev);
++	dev_set_drvdata(dev->dev, dev);
++
++	r = loongson_modeset_init(ldev);
++	if (r)
++		dev_err(dev->dev, "Fatal error during modeset init: %d\n", r);
++
++	r = loongson_irq_install(dev, irq);
++	if (r)
++		dev_err(dev->dev, "Fatal error during irq install: %d\n", r);
++
++	ldev->inited = true;
++	drm_mode_config_reset(dev);
++
++	r = drm_vblank_init(dev, ldev->num_crtc);
++	if (r)
++		dev_err(dev->dev, "Fatal error during vblank init: %d\n", r);
++
++	/* Make small buffers to store a hardware cursor (double buffered icon updates) */
++	ldev->cursor = drm_gem_dma_create(dev, roundup(32*32*4, PAGE_SIZE));
++
++	drm_kms_helper_poll_init(dev);
++
++	drm_aperture_remove_framebuffers(false, &loongson_drm_driver);
++
++	return 0;
++}
++
++/**
++ * loongson_drm_unload--release drm resource
++ *
++ * @dev: pointer to drm_device
++ *
++ */
++static void loongson_drm_unload(struct drm_device *dev)
++{
++        struct loongson_drm_device *ldev = dev->dev_private;
++
++	if (ldev == NULL)
++		return;
++
++	loongson_modeset_fini(ldev);
++	drm_mode_config_cleanup(dev);
++	dev->dev_private = NULL;
++	dev_set_drvdata(dev->dev, NULL);
++	ldev->inited = false;
++
++	return;
++}
++
++/**
++ * loongson_drm_open -Driver callback when a new struct drm_file is opened.
++ * Useful for setting up driver-private data structures like buffer allocators,
++ *  execution contexts or similar things.
++ *
++ * @dev DRM device
++ * @file DRM file private date
++ *
++ * RETURN
++ * 0 on success, a negative error code on failure, which will be promoted to
++ *  userspace as the result of the open() system call.
++ */
++static int loongson_drm_open(struct drm_device *dev, struct drm_file *file)
++{
++	file->driver_priv = NULL;
++
++	DRM_DEBUG("open: dev=%p, file=%p", dev, file);
++
++	return 0;
++}
++
++DEFINE_DRM_GEM_DMA_FOPS(fops);
++
++/**
++ * loongson_drm_driver - DRM device structure
++ *
++ * .load: driver callback to complete initialization steps after the driver is registered
++ * .unload:Reverse the effects of the driver load callback
++ * .open:Driver callback when a new struct drm_file is opened
++ * .fops:File operations for the DRM device node.
++ * .gem_free_object:deconstructor for drm_gem_objects
++ * .dumb_create:This creates a new dumb buffer in the drivers backing storage manager
++ *  (GEM, TTM or something else entirely) and returns the resulting buffer handle.
++ *  This handle can then be wrapped up into a framebuffer modeset object
++ * .dumb_map_offset:Allocate an offset in the drm device nodes address space
++ *  to be able to memory map a dumb buffer
++ * .dump_destory:This destroys the userspace handle for the given dumb backing storage buffer
++ */
++static struct drm_driver loongson_drm_driver = {
++	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_HAVE_IRQ | DRIVER_ATOMIC,
++	.open = loongson_drm_open,
++	.fops = &fops,
++
++	.name = DRIVER_NAME,
++	.desc = DRIVER_DESC,
++	.date = DRIVER_DATE,
++	.major = DRIVER_MAJOR,
++	.minor = DRIVER_MINOR,
++	.patchlevel = DRIVER_PATCHLEVEL,
++
++	DRM_GEM_DMA_DRIVER_OPS,
++	.gem_prime_import	= drm_gem_prime_import,
++	.gem_prime_import_sg_table = drm_gem_dma_prime_import_sg_table,
++};
++
++/**
++ * loongson_drm_pci_devices  -- pci device id info
++ *
++ * __u32 vendor, device           Vendor and device ID or PCI_ANY_ID
++ * __u32 subvendor, subdevice     Subsystem ID's or PCI_ANY_ID
++ * __u32 class, class_mask        (class,subclass,prog-if) triplet
++ * kernel_ulong_t driver_data     Data private to the driver
++ */
++static struct pci_device_id loongson_drm_pci_devices[] = {
++	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC1)},
++	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DC2)},
++	{0, 0, 0, 0, 0, 0, 0}
++};
++
++MODULE_DEVICE_TABLE(pci, loongson_drm_pci_devices);
++
++/**
++ * loongson_drm_pci_register -- add pci device
++ *
++ * @pdev PCI device
++ * @ent pci device id
++ */
++static int loongson_drm_pci_register(struct pci_dev *pdev,
++				 const struct pci_device_id *ent)
++
++{
++	int ret;
++	struct drm_device *dev;
++
++	dev = drm_dev_alloc(&loongson_drm_driver, &pdev->dev);
++	if (IS_ERR(dev))
++		return PTR_ERR(dev);
++
++	ret = pci_enable_device(pdev);
++	if (ret)
++		goto err_free;
++
++	loongson_drm_load(dev, 0x0);
++
++	ret = drm_dev_register(dev, 0);
++	if (ret)
++		goto err_pdev;
++
++	drm_fbdev_generic_setup(dev, 32);
++
++	return 0;
++
++err_pdev:
++	pci_disable_device(pdev);
++err_free:
++	drm_dev_put(dev);
++	return ret;
++}
++
++/**
++ * loongson_drm_pci_unregister -- release drm device
++ *
++ * @pdev PCI device
++ */
++static void loongson_drm_pci_unregister(struct pci_dev *pdev)
++{
++	struct drm_device *dev = pci_get_drvdata(pdev);
++	loongson_drm_unload(dev);
++	drm_dev_put(dev);
++}
++
++/*
++ * Suspend & resume.
++ */
++/*
++ * loongson_drm_suspend - initiate device suspend
++ *
++ * @pdev: drm dev pointer
++ * @state: suspend state
++ *
++ * Puts the hw in the suspend state (all asics).
++ * Returns 0 for success or an error on failure.
++ * Called at driver suspend.
++ */
++int loongson_drm_suspend(struct drm_device *dev, bool suspend)
++{
++	struct pci_dev *pdev = to_pci_dev(dev->dev);
++        struct loongson_drm_device *ldev;
++
++        if (dev == NULL || dev->dev_private == NULL)
++                return -ENODEV;
++
++        ldev = dev->dev_private;
++
++        drm_kms_helper_poll_disable(dev);
++	ldev->state = drm_atomic_helper_suspend(dev);
++
++	pci_save_state(pdev);
++	if (suspend) {
++		/* Shut down the device */
++		pci_disable_device(pdev);
++		pci_set_power_state(pdev, PCI_D3hot);
++	}
++
++	console_lock();
++	drm_fb_helper_set_suspend(ldev->dev->fb_helper, 1);
++	console_unlock();
++
++	return 0;
++}
++
++/*
++ *  * loongson_drm_resume - initiate device suspend
++ *
++ * @pdev: drm dev pointer
++ * @state: suspend state
++ *
++ * Puts the hw in the suspend state (all asics).
++ * Returns 0 for success or an error on failure.
++ * Called at driver suspend.
++ */
++
++int loongson_drm_resume(struct drm_device *dev, bool resume)
++{
++	struct pci_dev *pdev = to_pci_dev(dev->dev);
++	struct loongson_drm_device *ldev = dev->dev_private;
++
++	console_lock();
++
++	if (resume) {
++		pci_set_power_state(pdev, PCI_D0);
++		pci_restore_state(pdev);
++		if (pci_enable_device(pdev)) {
++			console_unlock();
++			return -1;
++		}
++	}
++
++        /* blat the mode back in */
++	drm_atomic_helper_resume(dev, ldev->state);
++
++	drm_kms_helper_poll_enable(dev);
++
++	drm_fb_helper_set_suspend(ldev->dev->fb_helper, 0);
++
++	console_unlock();
++
++	return 0;
++}
++
++/**
++ * loongson_drm_pm_suspend
++ *
++ * @dev   pointer to the device
++ *
++ * Executed before putting the system into a sleep state in which the
++ * contents of main memory are preserved.
++ */
++static int loongson_drm_pm_suspend(struct device *dev)
++{
++	struct drm_device *drm_dev = dev_get_drvdata(dev);
++
++	return loongson_drm_suspend(drm_dev, true);
++}
++
++/**
++ * loongson_drm_pm_resume
++ *
++ * @dev pointer to the device
++ *
++ * Executed after waking the system up from a sleep state in which the
++ * contents of main memory were preserved.
++ */
++static int loongson_drm_pm_resume(struct device *dev)
++{
++	struct drm_device *drm_dev = dev_get_drvdata(dev);
++
++	return loongson_drm_resume(drm_dev, true);
++}
++
++/**
++ *  loongson_drm_pm_freeze
++ *
++ *  @dev pointer to device
++ *
++ *  Hibernation-specific, executed before creating a hibernation image.
++ *  Analogous to @suspend(), but it should not enable the device to signal
++ *  wakeup events or change its power state.
++ */
++static int loongson_drm_pm_freeze(struct device *dev)
++{
++	struct drm_device *drm_dev = dev_get_drvdata(dev);
++
++	return loongson_drm_suspend(drm_dev, false);
++}
++
++/**
++ * loongson_drm_pm_draw
++ *
++ * @dev pointer to device
++ *
++ * Hibernation-specific, executed after creating a hibernation image OR
++ * if the creation of an image has failed.  Also executed after a failing
++ * attempt to restore the contents of main memory from such an image.
++ * Undo the changes made by the preceding @freeze(), so the device can be
++ * operated in the same way as immediately before the call to @freeze().
++ */
++static int loongson_drm_pm_thaw(struct device *dev)
++{
++	struct drm_device *drm_dev = dev_get_drvdata(dev);
++	
++	return loongson_drm_resume(drm_dev, false);
++}
++
++#define loongson_drm_pm_poweroff	loongson_drm_pm_freeze
++#define loongson_drm_pm_restore		loongson_drm_pm_resume
++
++/*
++ * * struct dev_pm_ops - device PM callbacks
++ *
++ *@suspend:  Executed before putting the system into a sleep state in which the
++ *           contents of main memory are preserved.
++ *@resume:   Executed after waking the system up from a sleep state in which the
++ *           contents of main memory were preserved.
++ *@freeze:   Hibernation-specific, executed before creating a hibernation image.
++ *           Analogous to @suspend(), but it should not enable the device to signal
++ *           wakeup events or change its power state.  The majority of subsystems
++ *           (with the notable exception of the PCI bus type) expect the driver-level
++ *           @freeze() to save the device settings in memory to be used by @restore()
++ *           during the subsequent resume from hibernation.
++ *@thaw:     Hibernation-specific, executed after creating a hibernation image OR
++ *           if the creation of an image has failed.  Also executed after a failing
++ *           attempt to restore the contents of main memory from such an image.
++ *           Undo the changes made by the preceding @freeze(), so the device can be
++ *           operated in the same way as immediately before the call to @freeze().
++ *@poweroff: Hibernation-specific, executed after saving a hibernation image.
++ *           Analogous to @suspend(), but it need not save the device's settings in
++ *           memory.
++ *@restore:  Hibernation-specific, executed after restoring the contents of main
++ *           memory from a hibernation image, analogous to @resume().
++ */
++static const struct dev_pm_ops loongson_drm_pm_ops = {
++	.suspend = loongson_drm_pm_suspend,
++	.resume = loongson_drm_pm_resume,
++	.freeze = loongson_drm_pm_freeze,
++	.thaw = loongson_drm_pm_thaw,
++	.poweroff = loongson_drm_pm_poweroff,
++	.restore = loongson_drm_pm_restore,
++};
++
++/**
++ * loongson_drm_pci_driver -- pci driver structure
++ *
++ * .id_table : must be non-NULL for probe to be called
++ * .probe: New device inserted
++ * .remove: Device removed
++ * .resume: Device suspended
++ * .suspend: Device woken up
++ */
++static struct pci_driver loongson_drm_pci_driver = {
++	.name		= DRIVER_NAME,
++	.id_table	= loongson_drm_pci_devices,
++	.probe		= loongson_drm_pci_register,
++	.remove		= loongson_drm_pci_unregister,
++	.driver.pm	= &loongson_drm_pm_ops,
++};
++
++/**
++ * loongson_drm_pci_init()  -- kernel module init function
++ */
++static int __init loongson_drm_init(void)
++{
++	int ret;
++	struct pci_dev *pdev = NULL;
++
++	/* If external graphics card exist, use it as default */
++	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev))) {
++		if (pdev->vendor == PCI_VENDOR_ID_ATI)
++			return 0;
++		if (pdev->vendor == 0x1a03) /* ASpeed */
++			return 0;
++	}
++
++	ret = pci_register_driver(&loongson_drm_pci_driver);
++
++	return ret;
++}
++
++/**
++ * loongson_drm_pci_exit()  -- kernel module exit function
++ */
++static void __exit loongson_drm_exit(void)
++{
++	pci_unregister_driver(&loongson_drm_pci_driver);
++}
++
++module_init(loongson_drm_init);
++module_exit(loongson_drm_exit);
++
++MODULE_AUTHOR("Chen Zhu <zhuchen@loongson.cn>");
++MODULE_AUTHOR("Huacai Chen <chenhuacai@loongson.cn>");
++MODULE_DESCRIPTION("Loongson LS7A DRM Driver");
++MODULE_LICENSE("GPL");
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_drv.h
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_drv.h
+@@ -0,0 +1,239 @@
++#ifndef __LOONGSON_DRV_H__
++#define __LOONGSON_DRV_H__
++
++#include <linux/i2c.h>
++#include <linux/i2c-algo-bit.h>
++#include <linux/module.h>
++#include <linux/types.h>
++#include <asm/loongson.h>
++
++#include <drm/drm_drv.h>
++#include <drm/drm_encoder.h>
++#include <drm/drm_fb_helper.h>
++#include <drm/drm_fbdev_generic.h>
++#include <drm/drm_gem.h>
++#include <drm/drm_modeset_helper_vtables.h>
++#include <drm/drm_vblank.h>
++
++#include "loongson_i2c.h"
++#include "loongson_vbios.h"
++
++#define to_loongson_crtc(x) container_of(x, struct loongson_crtc, base)
++#define to_loongson_encoder(x) container_of(x, struct loongson_encoder, base)
++#define to_loongson_connector(x) container_of(x, struct loongson_connector, base)
++
++#define LOONGSON_MAX_FB_HEIGHT	4096
++#define LOONGSON_MAX_FB_WIDTH	4096
++
++#define CUR_WIDTH_SIZE		32
++#define CUR_HEIGHT_SIZE		32
++
++#define LO_OFF	0
++#define HI_OFF	8
++
++#define LS7A_PIX0_PLL		(void *)TO_UNCACHE(LS7A_CHIPCFG_REG_BASE + 0x04b0)
++#define LS7A_PIX1_PLL		(void *)TO_UNCACHE(LS7A_CHIPCFG_REG_BASE + 0x04c0)
++
++#define CURIOSET_CORLOR		0x4607
++#define CURIOSET_POSITION	0x4608
++#define CURIOLOAD_ARGB		0x4609
++#define CURIOLOAD_IMAGE		0x460A
++#define CURIOHIDE_SHOW		0x460B
++#define FBEDID_GET		0X860C
++
++#define CRTC_REG_OFFSET		0x10
++
++#define CFG_FMT			GENMASK(2,0)
++#define CFG_FBSWITCH		BIT(7)
++#define CFG_ENABLE		BIT(8)
++#define CFG_PANELSWITCH 	BIT(9)
++#define CFG_FBNUM_BIT		11
++#define CFG_FBNUM		BIT(11)
++#define CFG_GAMMAR		BIT(12)
++#define CFG_RESET		BIT(20)
++
++#define FB_CFG_DVO_REG		(0x1240)
++#define FB_ADDR0_DVO_REG	(0x1260)
++#define FB_ADDR1_DVO_REG	(0x1580)
++#define FB_STRI_DVO_REG		(0x1280)
++#define FB_DITCFG_DVO_REG	(0x1360)
++#define FB_DITTAB_LO_DVO_REG	(0x1380)
++#define FB_DITTAB_HI_DVO_REG	(0x13a0)
++#define FB_PANCFG_DVO_REG	(0x13c0)
++#define FB_PANTIM_DVO_REG	(0x13e0)
++#define FB_HDISPLAY_DVO_REG	(0x1400)
++#define FB_HSYNC_DVO_REG	(0x1420)
++#define FB_VDISPLAY_DVO_REG	(0x1480)
++#define FB_VSYNC_DVO_REG	(0x14a0)
++#define FB_GAMINDEX_DVO_REG	(0x14e0)
++#define FB_GAMDATA_DVO_REG	(0x1500)
++
++#define HDMI_ZONEIDLE_REG 	(0x1700)
++#define HDMI_CTRL_REG		(0x1720)
++
++#define HDMI_AUDIO_BUF_REG	(0x1740)
++#define HDMI_AUDIO_NCFG_REG	(0x1760)
++#define HDMI_AUDIO_CTSCFG_REG	(0x1780)
++#define HDMI_AUDIO_CTSCALCFG_REG	(0x17a0)
++#define HDMI_AUDIO_INFOFRAME_REG	(0x17c0)
++#define HDMI_AUDIO_SAMPLE_REG	(0x17e0)
++
++#define HDMI_PHY_CTRL_REG	(0x1800)
++#define HDMI_PHY_PLLCFG_REG	(0x1820)
++
++#define FB_CUR_CFG_REG		(0x1520)
++#define FB_CUR_ADDR_REG		(0x1530)
++#define FB_CUR_LOC_ADDR_REG	(0x1540)
++#define FB_CUR_BACK_REG		(0x1550)
++#define FB_CUR_FORE_REG		(0x1560)
++#define FB_INT_REG		(0x1570)
++
++#define INT_DVO1_VSYNC		0
++#define INT_DVO1_HSYNC		1
++#define INT_DVO0_VSYNC		2
++#define INT_DVO0_HSYNC		3
++#define INT_CURSOR_FB_END	4
++#define INT_DVO1_FB_END		5
++#define INT_DVO0_FB_END		6
++
++#define MAX_CRTC 2
++
++enum loongson_chip {
++	dc_7a1000,
++	dc_7a2000
++};
++
++struct pix_pll {
++	unsigned int l2_div;
++	unsigned int l1_loopc;
++	unsigned int l1_frefc;
++};
++
++struct config_reg {
++	u8 dev_addr;
++	u8 reg;
++	u8 value;
++} __packed;
++
++struct cfg_encoder {
++	u8 reg_num;
++	u32 hdisplay;
++	u32 vdisplay;
++	struct config_reg config_regs[256];
++};
++
++struct loongson_crtc {
++	struct drm_crtc base;
++	unsigned int crtc_id;
++	uint32_t cfg_reg;
++	struct drm_plane *primary; /* Primary panel belongs to this crtc */
++	struct drm_pending_vblank_event *event;
++	struct loongson_drm_device *ldev;
++};
++
++struct loongson_encoder {
++	struct drm_encoder base;
++	u32 type;
++	u32 i2c_id;
++	int encoder_id;
++	struct loongson_i2c *i2c;
++	struct loongson_crtc *lcrtc; /* Binding crtc, not actual one */
++};
++
++struct loongson_connector {
++	struct drm_connector base;
++	u16 id;
++	u32 type;
++	u16 i2c_id;
++	u16 hotplug;
++	u16 edid_method;
++	u8 *vbios_edid;
++	struct loongson_i2c *i2c;
++	struct loongson_drm_device *ldev;
++};
++
++struct loongson_mode_info {
++	bool mode_config_initialized;
++	struct loongson_crtc *crtc;
++	struct loongson_encoder *encoder;
++	struct loongson_connector *connector;
++};
++
++struct loongson_drm_device {
++	struct drm_device *dev;
++	struct drm_atomic_state	*state;
++
++	resource_size_t	mmio_base;
++	resource_size_t	mmio_size;
++	void __iomem	*mmio;
++	uint32_t	int_reg;
++
++	struct drm_display_mode		mode;
++	struct loongson_mode_info	mode_info[2];
++	struct drm_gem_dma_object	*cursor;
++
++	int 			num_crtc;
++	struct loongson_crtc 	lcrtc[MAX_CRTC];
++	struct loongson_i2c	i2c_bus[DC_I2C_BUS_MAX];
++
++	void *vbios;
++	struct list_head desc_list;
++
++	bool	inited;
++	bool 	suspended;
++	bool	cursor_showed;
++	int	cursor_crtc_id;
++
++	int connector_active0;
++	int connector_active1;
++
++	enum loongson_chip chip;
++};
++
++extern spinlock_t loongson_reglock;
++
++/* FIXME: LS7A2000's switch_panel is not available, just return false. */
++static inline bool clone_mode(struct loongson_drm_device *ldev)
++{
++	return false;
++
++	if (ldev->num_crtc < 2)
++		return true;
++	if (ldev->mode_info[0].connector->base.status != connector_status_connected)
++		return true;
++	if (ldev->mode_info[1].connector->base.status != connector_status_connected)
++		return true;
++	if (ldev->lcrtc[0].base.x || ldev->lcrtc[0].base.y)
++		return false;
++	if (ldev->lcrtc[1].base.x || ldev->lcrtc[1].base.y)
++		return false;
++
++	return true;
++}
++
++int loongson_irq_install(struct drm_device *dev, int irq);
++void loongson_irq_uninstall(struct drm_device *dev);
++int loongson_irq_enable_vblank(struct drm_device *dev,unsigned int crtc_id);
++void loongson_irq_disable_vblank(struct drm_device *dev,unsigned int crtc_id);
++
++u32 crtc_read(struct loongson_crtc *lcrtc, u32 offset);
++void crtc_write(struct loongson_crtc *lcrtc, u32 offset, u32 val);
++
++int loongson_gpio_init(struct loongson_drm_device *ldev);
++int loongson_crtc_init(struct loongson_drm_device *ldev);
++struct drm_encoder *loongson_encoder_init(struct drm_device *dev, unsigned int index);
++struct drm_connector *loongson_connector_init(struct drm_device *dev, unsigned int index);
++
++int loongson_fbdev_init(struct loongson_drm_device *ldev);
++void loongson_fbdev_fini(struct loongson_drm_device *ldev);
++void loongson_fbdev_restore_mode(struct loongson_drm_device *ldev);
++
++int loongson_drm_drm_suspend(struct drm_device *dev, bool suspend,
++                                   bool fbcon, bool freeze);
++int loongson_drm_drm_resume(struct drm_device *dev, bool resume, bool fbcon);
++		   /* loongson_cursor.c */
++int loongson_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
++					uint32_t handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y);
++int loongson_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
++
++#endif
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_encoder.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_encoder.c
+@@ -0,0 +1,134 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Copyright (C) 2019 Lemote Inc.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ *	Jiaxun Yang <jiaxun.yang@flygoat.com>
++ */
++
++#include <drm/drm_crtc_helper.h>
++#include "loongson_drv.h"
++
++/**
++ * loongson_encoder_destroy
++ *
++ * @encoder: encoder object
++ *
++ * Clean up encoder resources
++ */
++static void loongson_encoder_destroy(struct drm_encoder *encoder)
++{
++	struct loongson_encoder *loongson_encoder = to_loongson_encoder(encoder);
++	drm_encoder_cleanup(encoder);
++	kfree(loongson_encoder);
++}
++
++static int loongson_encoder_atomic_check(struct drm_encoder *encoder,
++				    struct drm_crtc_state *crtc_state,
++				    struct drm_connector_state *conn_state)
++{
++	return 0;
++}
++
++static void loongson_encoder_atomic_mode_set(struct drm_encoder *encoder,
++				struct drm_crtc_state *crtc_state,
++				struct drm_connector_state *conn_state)
++{
++	unsigned long flags;
++	struct loongson_encoder *lenc = to_loongson_encoder(encoder);
++	struct loongson_crtc *lcrtc_origin = lenc->lcrtc;
++	struct loongson_crtc *lcrtc_current = to_loongson_crtc(crtc_state->crtc);
++
++	if (lcrtc_origin->crtc_id != lcrtc_current->crtc_id)
++		lcrtc_origin->cfg_reg |= CFG_PANELSWITCH;
++	else
++		lcrtc_origin->cfg_reg &= ~CFG_PANELSWITCH;
++
++	spin_lock_irqsave(&loongson_reglock, flags);
++	crtc_write(lcrtc_origin, FB_CFG_DVO_REG, lcrtc_origin->cfg_reg);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++}
++
++/**
++ * These provide the minimum set of functions required to handle a encoder
++ *
++ * Helper operations for encoders
++ */
++static const struct drm_encoder_helper_funcs loongson_encoder_helper_funcs = {
++	.atomic_check = loongson_encoder_atomic_check,
++	.atomic_mode_set = loongson_encoder_atomic_mode_set,
++};
++
++/**
++ * These provide the minimum set of functions required to handle a encoder
++ *
++ * Encoder controls,encoder sit between CRTCs and connectors
++ */
++static const struct drm_encoder_funcs loongson_encoder_encoder_funcs = {
++	.destroy = loongson_encoder_destroy,
++};
++
++static void loongson_hdmi_init(struct loongson_drm_device *ldev, int index)
++{
++	u32 val;
++	int offset = index * 0x10;
++	volatile void __iomem *base = ldev->mmio;
++
++	spin_lock(&loongson_reglock);
++	writel(0x287, base + HDMI_CTRL_REG + offset);
++
++	writel(0x00400040, base + HDMI_ZONEIDLE_REG + offset);
++
++	writel(6272, base + HDMI_AUDIO_NCFG_REG + offset);
++	writel(0x80000000, base + HDMI_AUDIO_CTSCFG_REG + offset);
++
++	writel(0x11, base + HDMI_AUDIO_INFOFRAME_REG + offset);
++	val = readl(base + HDMI_AUDIO_INFOFRAME_REG + offset) | 0x4;
++	writel(val, base + HDMI_AUDIO_INFOFRAME_REG + offset);
++
++	writel(0x1, base + HDMI_AUDIO_SAMPLE_REG + offset);
++	spin_unlock(&loongson_reglock);
++
++	DRM_DEBUG("Loongson HDMI init finish.\n");
++}
++
++/**
++ * loongson_encoder_init
++ *
++ * @dev: point to the drm_device structure
++ *
++ * Init encoder
++ */
++struct drm_encoder *loongson_encoder_init(struct drm_device *dev, unsigned int index)
++{
++	struct drm_encoder *encoder;
++	struct loongson_encoder *loongson_encoder;
++	struct loongson_drm_device *ldev = dev->dev_private;
++
++	loongson_encoder = kzalloc(sizeof(struct loongson_encoder), GFP_KERNEL);
++	if (!loongson_encoder)
++		return NULL;
++
++	loongson_encoder->encoder_id = index;
++	loongson_encoder->i2c = &ldev->i2c_bus[index];
++	loongson_encoder->lcrtc = &ldev->lcrtc[index];
++	loongson_encoder->type = get_encoder_type(ldev, index);
++	encoder = &loongson_encoder->base;
++
++	if (loongson_encoder->type == DRM_MODE_ENCODER_TMDS)
++		loongson_hdmi_init(ldev, index);
++
++	encoder->possible_crtcs = BIT(index);
++	encoder->possible_clones = BIT(1) | BIT(0);
++	/* encoder->possible_crtcs = BIT(1) | BIT(0); */
++
++	drm_encoder_helper_add(encoder, &loongson_encoder_helper_funcs);
++	drm_encoder_init(dev, encoder, &loongson_encoder_encoder_funcs,
++			 loongson_encoder->type, NULL);
++
++	return encoder;
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_i2c.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_i2c.c
+@@ -0,0 +1,189 @@
++// SPDX-License-Identifier: GPL-2.0+
++
++#include "loongson_i2c.h"
++#include "loongson_drv.h"
++#include "loongson_vbios.h"
++
++u32 ls7a_mm_rreg(struct loongson_drm_device *ldev, u32 offset)
++{
++	return readl(ldev->mmio + offset);
++}
++
++void ls7a_mm_wreg(struct loongson_drm_device *ldev, u32 offset, u32 val)
++{
++	writel(val, ldev->mmio + offset);
++}
++
++static inline void __dc_gpio_set_dir(struct loongson_drm_device *ldev,
++				     unsigned int pin, int input)
++{
++	u32 temp;
++
++	temp = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_CFG_OFFSET);
++	if (input)
++		temp |= 1UL << pin;
++	else
++		temp &= ~(1UL << pin);
++	ls7a_mm_wreg(ldev, LS7A_DC_GPIO_CFG_OFFSET, temp);
++}
++
++static void __dc_gpio_set_val(struct loongson_drm_device *ldev, unsigned int pin,
++			      int high)
++{
++	u32 temp;
++
++	temp = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_OUT_OFFSET);
++	if (high)
++		temp |= 1UL << pin;
++	else
++		temp &= ~(1UL << pin);
++	ls7a_mm_wreg(ldev, LS7A_DC_GPIO_OUT_OFFSET, temp);
++}
++
++static void loongson_i2c_set_data(void *i2c, int value)
++{
++	struct loongson_i2c *li2c = i2c;
++	struct loongson_drm_device *ldev = li2c->ldev;
++	unsigned int pin = li2c->data;
++
++	if (value)
++		__dc_gpio_set_dir(ldev, pin, 1);
++	else {
++		__dc_gpio_set_val(ldev, pin, 0);
++		__dc_gpio_set_dir(ldev, pin, 0);
++	}
++}
++
++static void loongson_i2c_set_clock(void *i2c, int value)
++{
++	struct loongson_i2c *li2c = i2c;
++	struct loongson_drm_device *ldev = li2c->ldev;
++	unsigned int pin = li2c->clock;
++
++	if (value)
++		__dc_gpio_set_dir(ldev, pin, 1);
++	else {
++		__dc_gpio_set_val(ldev, pin, 0);
++		__dc_gpio_set_dir(ldev, pin, 0);
++	}
++}
++
++static int loongson_i2c_get_data(void *i2c)
++{
++	int val;
++	struct loongson_i2c *li2c = i2c;
++	struct loongson_drm_device *ldev = li2c->ldev;
++	unsigned int pin = li2c->data;
++
++	val = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_IN_OFFSET);
++
++	return (val >> pin) & 1;
++}
++
++static int loongson_i2c_get_clock(void *i2c)
++{
++	int val;
++	struct loongson_i2c *li2c = i2c;
++	struct loongson_drm_device *ldev = li2c->ldev;
++	unsigned int pin = li2c->clock;
++
++	val = ls7a_mm_rreg(ldev, LS7A_DC_GPIO_IN_OFFSET);
++
++	return (val >> pin) & 1;
++}
++
++static int loongson_i2c_create(struct loongson_drm_device *ldev,
++			       struct loongson_i2c *li2c, const char *name)
++{
++	int ret;
++	unsigned int i2c_num;
++	struct i2c_adapter *i2c_adapter;
++	struct i2c_algo_bit_data *i2c_algo_data;
++
++	i2c_num = li2c->i2c_id;
++	i2c_adapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
++	if (!i2c_adapter)
++		return -ENOMEM;
++
++	i2c_algo_data = kzalloc(sizeof(struct i2c_algo_bit_data), GFP_KERNEL);
++	if (!i2c_algo_data) {
++		ret = -ENOMEM;
++		goto free_adapter;
++	}
++
++	i2c_adapter->owner = THIS_MODULE;
++	i2c_adapter->class = I2C_CLASS_DDC;
++	i2c_adapter->algo_data = i2c_algo_data;
++	i2c_adapter->dev.parent = ldev->dev->dev;
++	i2c_adapter->nr = -1;
++	snprintf(i2c_adapter->name, sizeof(i2c_adapter->name), "%s%d", name,
++		 i2c_num);
++
++	li2c->data = i2c_num * 2;
++	li2c->clock = i2c_num * 2 + 1;
++	DRM_INFO("Created dc-i2c%d, sda=%d, scl=%d\n", i2c_num, li2c->data,
++		 li2c->clock);
++
++	i2c_algo_data->setsda = loongson_i2c_set_data;
++	i2c_algo_data->setscl = loongson_i2c_set_clock;
++	i2c_algo_data->getsda = loongson_i2c_get_data;
++	i2c_algo_data->getscl = loongson_i2c_get_clock;
++	i2c_algo_data->udelay = DC_I2C_TON;
++	i2c_algo_data->timeout = usecs_to_jiffies(2200); /* from VESA */
++
++	ret = i2c_bit_add_numbered_bus(i2c_adapter);
++	if (ret)
++		goto free_algo_data;
++
++	li2c->adapter = i2c_adapter;
++	i2c_algo_data->data = li2c;
++	i2c_set_adapdata(li2c->adapter, li2c);
++	li2c->init = true;
++	li2c->ldev = ldev;
++	DRM_INFO("Register i2c algo-bit adapter [%s]\n", i2c_adapter->name);
++
++	return 0;
++
++free_algo_data:
++	DRM_ERROR("Failed to register i2c adapter %s\n", i2c_adapter->name);
++	kfree(i2c_algo_data);
++free_adapter:
++	kfree(i2c_adapter);
++
++	return ret;
++}
++
++int loongson_gpio_init(struct loongson_drm_device *ldev)
++{
++	int pin;
++
++	/* set gpio dir output 0-3 */
++	for (pin = 0; pin < 4; pin++) {
++		__dc_gpio_set_val(ldev, pin, 0);
++		__dc_gpio_set_dir(ldev, pin, 0);
++	}
++
++	return 0;
++}
++
++int loongson_i2c_init(struct loongson_drm_device *ldev)
++{
++	int ret, i;
++
++	ret = get_loongson_i2c(ldev);
++	if (ret != true) {
++		DRM_ERROR("Failed to get i2c_id form vbios\n");
++		return -ENODEV;
++	}
++
++	for (i = 0; i < DC_I2C_BUS_MAX; i++) {
++		if (!ldev->i2c_bus[i].use)
++			continue;
++		ldev->i2c_bus[i].i2c_id = i;
++		ret = loongson_i2c_create(ldev, &ldev->i2c_bus[i], DC_I2C_NAME);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_i2c.h
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_i2c.h
+@@ -0,0 +1,43 @@
++/* SPDX-License-Identifier: GPL-2.0+ */
++/*
++ * Copyright (c) 2020 Loongson Technology Co., Ltd.
++ * Authors:
++ *	sunhao <sunhao@loongson.cn>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#ifndef __LOONGSON_I2C_H__
++#define __LOONGSON_I2C_H__
++
++#include <linux/i2c.h>
++#include <linux/i2c-algo-bit.h>
++#include <drm/drm_edid.h>
++
++/* Modify this marco to config i2c bus speed, bus_freq = 500 / T */
++/* Eg: i2c_bus_freq=100k when T=5 */
++#define DC_I2C_TON 5
++#define DC_I2C_NAME "ls7a_dc_i2c"
++#define DC_I2C_BUS_MAX 2
++
++/* Loongson 7A display controller proprietary GPIOs */
++#define LS7A_DC_GPIO_CFG_OFFSET (0x1660)
++#define LS7A_DC_GPIO_IN_OFFSET (0x1650)
++#define LS7A_DC_GPIO_OUT_OFFSET (0x1650)
++
++struct loongson_drm_device;
++
++struct loongson_i2c {
++	struct loongson_drm_device *ldev;
++	struct i2c_client *ddc_client;
++	struct i2c_adapter *adapter;
++	u32 data, clock;
++	bool use, init;
++	u32 i2c_id;
++};
++
++int loongson_i2c_init(struct loongson_drm_device *ldev);
++
++#endif
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_irq.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_irq.c
+@@ -0,0 +1,90 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include "loongson_drv.h"
++
++static irqreturn_t loongson_irq_handler(int irq, void *arg)
++{
++	unsigned int val;
++	struct drm_device *dev = (struct drm_device *) arg;
++	struct loongson_drm_device *ldev = dev->dev_private;
++	volatile void __iomem *base = ldev->mmio;
++ 
++	val = readl(base + FB_INT_REG);
++	spin_lock(&loongson_reglock);
++	writel(val, base + FB_INT_REG);
++	spin_unlock(&loongson_reglock);
++
++	if (val & BIT(INT_DVO0_FB_END)){
++		drm_crtc_handle_vblank(&ldev->lcrtc[0].base);
++	}
++
++	if (val & BIT(INT_DVO1_FB_END)){
++		drm_crtc_handle_vblank(&ldev->lcrtc[1].base);
++	}
++
++	spin_lock(&loongson_reglock);
++	writel(ldev->int_reg, base + FB_INT_REG);
++	spin_unlock(&loongson_reglock);
++
++	return IRQ_HANDLED;
++}
++
++static void loongson_irq_preinstall(struct drm_device *dev)
++{
++	unsigned long flags;
++	struct loongson_drm_device *ldev = dev->dev_private;
++	volatile void __iomem *base = ldev->mmio;
++
++	/* disable interupt */
++	spin_lock_irqsave(&loongson_reglock, flags);
++	writel(0x0000 << 16, base + FB_INT_REG);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++}
++
++static int loongson_irq_postinstall(struct drm_device *dev)
++{
++	return 0;
++}
++
++int loongson_irq_install(struct drm_device *dev, int irq)
++{
++	int ret;
++
++	if (irq == IRQ_NOTCONNECTED)
++		return -ENOTCONN;
++
++	loongson_irq_preinstall(dev);
++
++	/* PCI devices require shared interrupts. */
++	ret = request_irq(irq, loongson_irq_handler,
++			  IRQF_SHARED, dev->driver->name, dev);
++	if (ret)
++		return ret;
++
++	loongson_irq_postinstall(dev);
++
++	return 0;
++}
++
++void loongson_irq_uninstall(struct drm_device *dev)
++{
++	unsigned long flags;
++	struct loongson_drm_device *ldev = dev->dev_private;
++	volatile void __iomem *base = ldev->mmio;
++
++	/* disable interupt */
++	spin_lock_irqsave(&loongson_reglock, flags);
++	writel(0x0000 << 16, base + FB_INT_REG);
++	spin_unlock_irqrestore(&loongson_reglock, flags);
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_vbios.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_vbios.c
+@@ -0,0 +1,857 @@
++/*
++ * Copyright (c) 2018 Loongson Technology Co., Ltd.
++ * Authors:
++ *	Chen Zhu <zhuchen@loongson.cn>
++ *	Yaling Fang <fangyaling@loongson.cn>
++ *	Dandan Zhang <zhangdandan@loongson.cn>
++ *	Huacai Chen <chenhc@lemote.com>
++ * This program is free software; you can redistribute  it and/or modify it
++ * under  the terms of  the GNU General  Public License as published by the
++ * Free Software Foundation;  either version 2 of the  License, or (at your
++ * option) any later version.
++ */
++
++#include "loongson_drv.h"
++#include "loongson_vbios.h"
++
++#define VBIOS_START 0x1000
++#define VBIOS_SIZE  0x40000
++#define VBIOS_DESC_OFFSET 0x6000
++
++/* VBIOS INFO ADDRESS TABLE */
++struct acpi_viat_table {
++	struct acpi_table_header header;
++	unsigned long vbios_addr;
++} __packed;
++
++static u32 get_vbios_version(struct loongson_vbios *vbios)
++{
++	u32 minor, major, version;
++
++	minor = vbios->version_minor;
++	major = vbios->version_major;
++	version = major * 10 + minor;
++
++	return version;
++}
++
++static bool parse_vbios_i2c(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	int i, num, size;
++	struct vbios_i2c *i2c;
++	struct vbios_i2c *vbios_i2c = NULL;
++	struct loongson_i2c *val = (struct loongson_i2c *)cmd->res;
++
++	size = this->desc->size;
++	vbios_i2c = kzalloc(size, GFP_KERNEL);
++	if (!vbios_i2c)
++		return false;
++
++	memset(vbios_i2c, 0xff, size);
++	memcpy(vbios_i2c, this->data, size);
++	num = size / sizeof(*vbios_i2c);
++
++	i2c = vbios_i2c;
++	for (i = 0; (i < num && i < DC_I2C_BUS_MAX); i++) {
++		val->i2c_id = (u32)i2c->id;
++		val->use = true;
++		val++;
++		i2c++;
++	}
++
++	kfree(vbios_i2c);
++	return ret;
++}
++
++static bool parse_vbios_crtc(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	u64 request = (u64)cmd->req;
++	u32 *val = (u32 *)cmd->res;
++	struct vbios_crtc crtc;
++
++	memset(&crtc, 0xff, sizeof(crtc));
++	memcpy(&crtc, this->data, min_t(u32, this->desc->size, sizeof(crtc)));
++
++	switch (request) {
++	case VBIOS_CRTC_ID:
++		*val = crtc.crtc_id;
++		break;
++	case VBIOS_CRTC_ENCODER_ID:
++		*val = crtc.encoder_id;
++		break;
++	case VBIOS_CRTC_MAX_FREQ:
++		*val = crtc.max_freq;
++		break;
++	case VBIOS_CRTC_MAX_WIDTH:
++		*val = crtc.max_width;
++		break;
++	case VBIOS_CRTC_MAX_HEIGHT:
++		*val = crtc.max_height;
++		break;
++	case VBIOS_CRTC_IS_VB_TIMING:
++		*val = crtc.is_vb_timing;
++		break;
++	default:
++		ret = false;
++		break;
++	}
++
++	return ret;
++}
++
++static bool parse_vbios_encoder(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	u64 request = (u64)cmd->req;
++	u32 *val = (u32 *)cmd->res;
++	struct vbios_encoder encoder;
++
++	memset(&encoder, 0xff, sizeof(encoder));
++	memcpy(&encoder, this->data,
++	       min_t(u32, this->desc->size, sizeof(encoder)));
++
++	switch (request) {
++	case VBIOS_ENCODER_I2C_ID:
++		*val = encoder.i2c_id;
++		break;
++	case VBIOS_ENCODER_CONNECTOR_ID:
++		*val = encoder.connector_id;
++		break;
++	case VBIOS_ENCODER_TYPE:
++		*val = encoder.type;
++		break;
++	case VBIOS_ENCODER_CONFIG_TYPE:
++		*val = encoder.config_type;
++		break;
++	case VBIOS_ENCODER_CHIP:
++		*val = encoder.chip;
++		break;
++	case VBIOS_ENCODER_CHIP_ADDR:
++		*val = encoder.chip_addr;
++		break;
++	default:
++		ret = false;
++		break;
++	}
++
++	return ret;
++}
++
++static bool parse_vbios_cfg_encoder(struct desc_node *this,
++				    struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	u64 request = (u64)cmd->req;
++	u32 *val = (u32 *)cmd->res;
++	struct cfg_encoder *cfg_encoder;
++	struct cfg_encoder *cfg;
++	struct vbios_cfg_encoder *vbios_cfg_encoder;
++	u32 num, size, i = 0;
++
++	vbios_cfg_encoder = (struct vbios_cfg_encoder *)this->data;
++	size = sizeof(struct vbios_cfg_encoder);
++	num = this->desc->size / size;
++
++	switch (request) {
++	case VBIOS_ENCODER_CONFIG_PARAM:
++		cfg_encoder = (struct cfg_encoder *)kzalloc(
++			sizeof(struct cfg_encoder) * num, GFP_KERNEL);
++		cfg = cfg_encoder;
++		for (i = 0; i < num; i++) {
++			cfg->reg_num = vbios_cfg_encoder->reg_num;
++			cfg->hdisplay = vbios_cfg_encoder->hdisplay;
++			cfg->vdisplay = vbios_cfg_encoder->vdisplay;
++			memcpy(&cfg->config_regs,
++			       &vbios_cfg_encoder->config_regs,
++			       sizeof(struct vbios_conf_reg) * 256);
++
++			cfg++;
++			vbios_cfg_encoder++;
++		}
++		cmd->res = (void *)cfg_encoder;
++		break;
++	case VBIOS_ENCODER_CONFIG_NUM:
++		*val = num;
++		break;
++	default:
++		ret = false;
++		break;
++	}
++
++	return ret;
++}
++
++static bool parse_vbios_connector(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	u64 request = (u64)cmd->req;
++	u32 *val = (u32 *)cmd->res;
++	struct vbios_connector connector;
++
++	memset(&connector, 0xff, sizeof(connector));
++	memcpy(&connector, this->data,
++	       min_t(u32, this->desc->size, sizeof(connector)));
++
++	switch (request) {
++	case VBIOS_CONNECTOR_I2C_ID:
++		*val = connector.i2c_id;
++		break;
++	case VBIOS_CONNECTOR_INTERNAL_EDID:
++		memcpy((u8 *)(ulong)val, connector.internal_edid,
++		       EDID_LENGTH * 2);
++		break;
++	case VBIOS_CONNECTOR_TYPE:
++		*val = connector.type;
++		break;
++	case VBIOS_CONNECTOR_HOTPLUG:
++		*val = connector.hotplug;
++		break;
++	case VBIOS_CONNECTOR_EDID_METHOD:
++		*val = connector.edid_method;
++		break;
++	case VBIOS_CONNECTOR_IRQ_GPIO:
++		*val = connector.irq_gpio;
++		break;
++	case VBIOS_CONNECTOR_IRQ_PLACEMENT:
++		*val = connector.gpio_placement;
++		break;
++	default:
++		ret = false;
++		break;
++	}
++
++	return ret;
++}
++
++static bool parse_vbios_backlight(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	return 0;
++}
++
++static bool parse_vbios_pwm(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	bool ret = true;
++	u64 request = (u64)cmd->req;
++	u32 *val = (u32 *)cmd->res;
++	struct vbios_pwm *pwm = (struct vbios_pwm *)this->data;
++
++	switch (request) {
++	case VBIOS_PWM_ID:
++		*val = pwm->pwm;
++		break;
++	case VBIOS_PWM_PERIOD:
++		*val = pwm->peroid;
++		break;
++	case VBIOS_PWM_POLARITY:
++		*val = pwm->polarity;
++		break;
++	default:
++		ret = false;
++		break;
++	}
++
++	return ret;
++}
++
++static bool parse_vbios_header(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	return true;
++}
++
++static bool parse_vbios_default(struct desc_node *this, struct vbios_cmd *cmd)
++{
++	struct vbios_desc *vb_desc;
++
++	vb_desc = this->desc;
++	DRM_WARN("Current descriptor[T-%d][V-%d] cannot be interprete.\n",
++		 vb_desc->type, vb_desc->ver);
++	return false;
++}
++
++#define FUNC(t, v, f)                                                          \
++	{                                                                      \
++		.type = t, .ver = v, .func = f,                                \
++	}
++
++static struct desc_func tables[] = {
++	FUNC(desc_header, ver_v1, parse_vbios_header),
++	FUNC(desc_i2c, ver_v1, parse_vbios_i2c),
++	FUNC(desc_crtc, ver_v1, parse_vbios_crtc),
++	FUNC(desc_encoder, ver_v1, parse_vbios_encoder),
++	FUNC(desc_connector, ver_v1, parse_vbios_connector),
++	FUNC(desc_cfg_encoder, ver_v1, parse_vbios_cfg_encoder),
++	FUNC(desc_backlight, ver_v1, parse_vbios_backlight),
++	FUNC(desc_pwm, ver_v1, parse_vbios_pwm),
++};
++
++static inline parse_func *get_parse_func(struct vbios_desc *vb_desc)
++{
++	int i;
++	u32 type = vb_desc->type;
++	u32 ver = vb_desc->ver;
++	parse_func *func = parse_vbios_default;
++	u32 tt_num = ARRAY_SIZE(tables);
++
++	for (i = 0; i < tt_num; i++) {
++		if ((tables[i].ver == ver) && (tables[i].type == type)) {
++			func = tables[i].func;
++			break;
++		}
++	}
++
++	return func;
++}
++
++static inline u32 insert_desc_list(struct loongson_drm_device *ldev,
++				   struct vbios_desc *vb_desc)
++{
++	struct desc_node *node;
++	parse_func *func = NULL;
++
++	WARN_ON(!ldev || !vb_desc);
++	node = (struct desc_node *)kzalloc(sizeof(*node), GFP_KERNEL);
++	if (!node)
++		return -ENOMEM;
++
++	func = get_parse_func(vb_desc);
++	node->parse = func;
++	node->desc = (void *)vb_desc;
++	node->data = ((u8 *)ldev->vbios + vb_desc->offset);
++	list_add_tail(&node->head, &ldev->desc_list);
++
++	return 0;
++}
++
++static inline void free_desc_list(struct loongson_drm_device *ldev)
++{
++	struct desc_node *node, *tmp;
++
++	list_for_each_entry_safe (node, tmp, &ldev->desc_list, head) {
++		list_del(&node->head);
++		kfree(node);
++	}
++}
++
++#define DESC_LIST_MAX 1024
++
++static u32 parse_vbios_desc(struct loongson_drm_device *ldev)
++{
++	u32 i, ret = 0;
++	struct vbios_desc *desc;
++	enum desc_type type = 0;
++	u8 *vbios = (u8 *)ldev->vbios;
++
++	WARN_ON(!vbios);
++
++	desc = (struct vbios_desc *)(vbios + VBIOS_DESC_OFFSET);
++	for (i = 0; i < DESC_LIST_MAX; i++) {
++		type = desc->type;
++		if (type == desc_max)
++			break;
++
++		ret = insert_desc_list(ldev, desc);
++		if (ret)
++			DRM_DEBUG_KMS("Parse T-%d V-%d failed[%d]\n", desc->ver,
++				      desc->type, ret);
++
++		desc++;
++	}
++
++	return ret;
++}
++
++static inline struct desc_node *get_desc_node(struct loongson_drm_device *ldev,
++					      u16 type, u8 index)
++{
++	struct desc_node *node, *tmp;
++	struct vbios_desc *vb_desc;
++
++	list_for_each_entry_safe (node, tmp, &ldev->desc_list, head) {
++		vb_desc = node->desc;
++		if (vb_desc->type == type && vb_desc->index == index)
++			return node;
++	}
++
++	return NULL;
++}
++
++static bool vbios_get_data(struct loongson_drm_device *ldev, struct vbios_cmd *cmd)
++{
++	struct desc_node *node;
++
++	WARN_ON(!cmd);
++
++	node = get_desc_node(ldev, cmd->type, cmd->index);
++	if (node && node->parse)
++		return node->parse(node, cmd);
++
++	DRM_DEBUG_DRIVER("Failed to get node(%d,%d)\n", cmd->type, cmd->index);
++
++	return false;
++}
++
++u32 get_connector_type(struct loongson_drm_device *ldev, u32 index)
++{
++	u32 type = -1;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_TYPE;
++	vbt_cmd.res = (void *)(ulong)&type;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		type = -1;
++
++	return type;
++}
++
++u16 get_connector_i2cid(struct loongson_drm_device *ldev, u32 index)
++{
++	u16 i2c_id = -1;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_I2C_ID;
++	vbt_cmd.res = (void *)(ulong)&i2c_id;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		i2c_id = -1;
++
++	return i2c_id;
++}
++
++u32 get_connector_irq_gpio(struct loongson_drm_device *ldev, u32 index)
++{
++	int ret;
++	u32 irq_gpio;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_IRQ_GPIO;
++	vbt_cmd.res = (void *)(ulong)&irq_gpio;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		return -1;
++
++	return irq_gpio;
++}
++
++enum gpio_placement get_connector_gpio_placement(struct loongson_drm_device *ldev,
++						 u32 index)
++{
++	int ret;
++	enum gpio_placement irq_placement;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_IRQ_PLACEMENT;
++	vbt_cmd.res = (void *)(ulong)&irq_placement;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		return -1;
++
++	return irq_placement;
++}
++
++u16 get_hotplug_mode(struct loongson_drm_device *ldev, u32 index)
++{
++	u16 mode = -1;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_HOTPLUG;
++	vbt_cmd.res = (void *)(ulong)&mode;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		mode = -1;
++
++	return mode;
++}
++
++u16 get_edid_method(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u16 method = via_null;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_EDID_METHOD;
++	vbt_cmd.res = (void *)(ulong)&method;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		method = via_null;
++
++	return method;
++}
++
++u8 *get_vbios_edid(struct loongson_drm_device *ldev, u32 index)
++{
++	u8 *edid = NULL;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	edid = kzalloc(sizeof(u8) * EDID_LENGTH * 2, GFP_KERNEL);
++	if (!edid)
++		return edid;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_connector;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CONNECTOR_INTERNAL_EDID;
++	vbt_cmd.res = (void *)(ulong)edid;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		return NULL;
++
++	return edid;
++}
++
++u32 get_vbios_pwm(struct loongson_drm_device *ldev, u32 index, u16 request)
++{
++	u32 value = -1;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_pwm;
++	vbt_cmd.req = (void *)(ulong)request;
++	vbt_cmd.res = (void *)(ulong)&value;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		value = 0xffffffff;
++
++	return value;
++}
++
++u32 get_crtc_id(struct loongson_drm_device *ldev, u32 index)
++{
++	u32 crtc_id = 0;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_ID;
++	vbt_cmd.res = (void *)(ulong)&crtc_id;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		crtc_id = 0;
++
++	return crtc_id;
++}
++
++u32 get_crtc_max_freq(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u32 max_freq = 0;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_FREQ;
++	vbt_cmd.res = (void *)(ulong)&max_freq;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		max_freq = 0;
++
++	return max_freq;
++}
++
++u32 get_crtc_max_width(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u32 max_width = 0;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_WIDTH;
++	vbt_cmd.res = (void *)(ulong)&max_width;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		max_width = LOONGSON_MAX_FB_WIDTH;
++
++	return max_width;
++}
++
++u32 get_crtc_max_height(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u32 max_height = 0;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_MAX_HEIGHT;
++	vbt_cmd.res = (void *)(ulong)&max_height;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		max_height = LOONGSON_MAX_FB_HEIGHT;
++
++	return max_height;
++}
++
++u32 get_crtc_encoder_id(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u32 encoder_id = 0;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_ENCODER_ID;
++	vbt_cmd.res = (void *)(ulong)&encoder_id;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		encoder_id = 0;
++
++	return encoder_id;
++}
++
++bool get_crtc_is_vb_timing(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	bool vb_timing = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_crtc;
++	vbt_cmd.req = (void *)(ulong)VBIOS_CRTC_IS_VB_TIMING;
++	vbt_cmd.res = (void *)(ulong)&vb_timing;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		vb_timing = false;
++
++	return vb_timing;
++}
++
++struct crtc_timing *get_crtc_timing(struct loongson_drm_device *ldev, u32 index)
++{
++	return NULL;
++}
++
++u32 get_encoder_connector_id(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	u32 connector_id = 0;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONNECTOR_ID;
++	vbt_cmd.res = (void *)(ulong)&connector_id;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		connector_id = 0;
++
++	return connector_id;
++}
++
++u32 get_encoder_i2c_id(struct loongson_drm_device *ldev, u32 index)
++{
++	u32 i2c_id = 0;
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_I2C_ID;
++	vbt_cmd.res = (void *)(ulong)&i2c_id;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		i2c_id = 0;
++
++	return i2c_id;
++}
++
++struct cfg_encoder *get_encoder_config(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++	struct cfg_encoder *encoder_config = NULL;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_cfg_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_PARAM;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (ret)
++		encoder_config = (struct cfg_encoder *)vbt_cmd.res;
++
++	return encoder_config;
++}
++
++u32 get_encoder_cfg_num(struct loongson_drm_device *ldev, u32 index)
++{
++	struct vbios_cmd vbt_cmd;
++	bool ret = false;
++	u32 cfg_num = 0;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_cfg_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_NUM;
++	vbt_cmd.res = (void *)(ulong)&cfg_num;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		cfg_num = 0;
++
++	return cfg_num;
++}
++
++enum encoder_config get_encoder_config_type(struct loongson_drm_device *ldev,
++					    u32 index)
++{
++	bool ret = false;
++	enum encoder_config config_type = encoder_bios_config;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CONFIG_TYPE;
++	vbt_cmd.res = (void *)(ulong)&config_type;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		config_type = encoder_bios_config;
++
++	return config_type;
++}
++
++enum encoder_object get_encoder_chip(struct loongson_drm_device *ldev, u32 index)
++{
++	int ret;
++	enum encoder_object chip;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CHIP;
++	vbt_cmd.res = (void *)(ulong)&chip;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		return Unknown;
++
++	return chip;
++}
++
++u8 get_encoder_chip_addr(struct loongson_drm_device *ldev, u32 index)
++{
++	int ret;
++	u8 chip_addr;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_CHIP_ADDR;
++	vbt_cmd.res = (void *)(ulong)&chip_addr;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		return Unknown;
++
++	return chip_addr;
++}
++
++enum encoder_type get_encoder_type(struct loongson_drm_device *ldev, u32 index)
++{
++	bool ret = false;
++	enum encoder_type type = encoder_dac;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = index;
++	vbt_cmd.type = desc_encoder;
++	vbt_cmd.req = (void *)(ulong)VBIOS_ENCODER_TYPE;
++	vbt_cmd.res = (void *)(ulong)&type;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++	if (!ret)
++		type = encoder_dac;
++
++	return type;
++}
++
++bool get_loongson_i2c(struct loongson_drm_device *ldev)
++{
++	bool ret = false;
++	struct vbios_cmd vbt_cmd;
++
++	vbt_cmd.index = 0;
++	vbt_cmd.type = desc_i2c;
++	vbt_cmd.res = (void *)&ldev->i2c_bus;
++	ret = vbios_get_data(ldev, &vbt_cmd);
++
++	if (!ret) {
++		ldev->i2c_bus[0].use = true;
++		ldev->i2c_bus[1].use = true;
++	}
++
++	return true;
++}
++
++static void *get_vbios_from_acpi(void)
++{
++	void *vbios = NULL;
++#ifdef CONFIG_ACPI
++	struct acpi_viat_table *viat;
++	struct acpi_table_header *hdr;
++
++	if (!ACPI_SUCCESS(acpi_get_table("VIAT", 1, &hdr)))
++		return NULL;
++
++	if (hdr->length != sizeof(struct acpi_viat_table)) {
++		DRM_WARN("ACPI VIAT table present but broken (length error)\n");
++		return NULL;
++	}
++
++	vbios = kmalloc(VBIOS_SIZE, GFP_KERNEL);
++	if (!vbios)
++		return NULL;
++
++	viat = (struct acpi_viat_table *)hdr;
++	memcpy(vbios, phys_to_virt(viat->vbios_addr), VBIOS_SIZE);
++
++	DRM_INFO("Get VBIOS from ACPI success!\n");
++#endif
++	return vbios;
++}
++
++bool loongson_vbios_init(struct loongson_drm_device *ldev)
++{
++	void *vbios = NULL;
++	struct loongson_vbios *header;
++
++	vbios = get_vbios_from_acpi();
++	if (vbios)
++		goto success;
++
++	vbios = kzalloc(256 * 1024, GFP_KERNEL);
++	if (!vbios)
++		return false;
++
++	header = vbios;
++	header->crtc_num = 2;
++
++success:
++	header = ldev->vbios = vbios;
++	ldev->num_crtc = header->crtc_num;
++
++	DRM_INFO("Loongson VBIOS version %d.%d\n", header->version_major,
++		 header->version_minor);
++
++	INIT_LIST_HEAD(&ldev->desc_list);
++	parse_vbios_desc(ldev);
++
++	return true;
++}
++
++void loongson_vbios_exit(struct loongson_drm_device *ldev)
++{
++	free_desc_list(ldev);
++	kfree(ldev->vbios);
++}
+Index: linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_vbios.h
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/gpu/drm/loongson/loongson_vbios.h
+@@ -0,0 +1,283 @@
++#ifndef __LOONGSON_VBIOS_H__
++#define __LOONGSON_VBIOS_H__
++
++#define VBIOS_PWM_ID 0x0
++#define VBIOS_PWM_PERIOD 0x1
++#define VBIOS_PWM_POLARITY 0x2
++
++#define VBIOS_CRTC_ID 0x1
++#define VBIOS_CRTC_ENCODER_ID 0x2
++#define VBIOS_CRTC_MAX_FREQ 0x3
++#define VBIOS_CRTC_MAX_WIDTH 0x4
++#define VBIOS_CRTC_MAX_HEIGHT 0x5
++#define VBIOS_CRTC_IS_VB_TIMING 0x6
++
++#define VBIOS_ENCODER_I2C_ID 0x1
++#define VBIOS_ENCODER_CONNECTOR_ID 0x2
++#define VBIOS_ENCODER_TYPE 0x3
++#define VBIOS_ENCODER_CONFIG_TYPE 0x4
++#define VBIOS_ENCODER_CONFIG_PARAM 0x1
++#define VBIOS_ENCODER_CONFIG_NUM 0x2
++#define VBIOS_ENCODER_CHIP 0x05
++#define VBIOS_ENCODER_CHIP_ADDR 0x06
++
++#define VBIOS_CONNECTOR_I2C_ID 0x1
++#define VBIOS_CONNECTOR_INTERNAL_EDID 0x2
++#define VBIOS_CONNECTOR_TYPE 0x3
++#define VBIOS_CONNECTOR_HOTPLUG 0x4
++#define VBIOS_CONNECTOR_EDID_METHOD 0x5
++#define VBIOS_CONNECTOR_IRQ_PLACEMENT 0x06
++#define VBIOS_CONNECTOR_IRQ_GPIO 0x07
++
++struct desc_node;
++struct vbios_cmd;
++typedef bool(parse_func)(struct desc_node *, struct vbios_cmd *);
++
++enum desc_type {
++	desc_header = 0,
++	desc_crtc,
++	desc_encoder,
++	desc_connector,
++	desc_i2c,
++	desc_pwm,
++	desc_gpio,
++	desc_backlight,
++	desc_fan,
++	desc_irq_vblank,
++	desc_cfg_encoder,
++	desc_max = 0xffff
++};
++
++enum desc_ver {
++	ver_v1,
++};
++
++enum hotplug {
++	disable = 0,
++	polling,
++	irq,
++	hotplug_max = 0xffffffff,
++};
++
++enum loongson_edid_method {
++	via_null = 0,
++	via_i2c,
++	via_vbios,
++	via_encoder,
++	via_max = 0xffffffff,
++};
++
++enum i2c_type { i2c_cpu, i2c_gpio, i2c_max = -1 };
++
++enum vbios_backlight_type { bl_unuse, bl_ec, bl_pwm };
++
++enum encoder_config {
++	encoder_transparent = 0,
++	encoder_os_config,
++	encoder_bios_config,
++	encoder_timing_filling,
++	encoder_kernel_driver,
++	encoder_type_max = 0xffffffff,
++};
++
++enum encoder_type {
++	encoder_none,
++	encoder_dac,
++	encoder_tmds,
++	encoder_lvds,
++	encoder_tvdac,
++	encoder_virtual,
++	encoder_dsi,
++	encoder_dpmst,
++	encoder_dpi
++};
++
++enum connector_type {
++	connector_unknown,
++	connector_vga,
++	connector_dvii,
++	connector_dvid,
++	connector_dvia,
++	connector_composite,
++	connector_svideo,
++	connector_lvds,
++	connector_component,
++	connector_9pindin,
++	connector_displayport,
++	connector_hdmia,
++	connector_hdmib,
++	connector_tv,
++	connector_edp,
++	connector_virtual,
++	connector_dsi,
++	connector_dpi
++};
++
++enum gpio_placement {
++	GPIO_PLACEMENT_LS3A = 0,
++	GPIO_PLACEMENT_LS7A,
++};
++
++enum encoder_object {
++	Unknown = 0x00,
++	INTERNAL_DVO = 0x01,
++	INTERNAL_HDMI = 0x02,
++	VGA_CH7055 = 0x10,
++	VGA_ADV7125 = 0x11,
++	DVI_TFP410 = 0x20,
++	HDMI_IT66121 = 0x30,
++	HDMI_SIL9022 = 0x31,
++	HDMI_LT8618 = 0x32,
++	HDMI_MS7210 = 0x33,
++	EDP_NCS8805 = 0x40
++};
++
++struct loongson_vbios {
++	char title[16];
++	uint32_t version_major;
++	uint32_t version_minor;
++	char information[20];
++	uint32_t crtc_num;
++	uint32_t crtc_offset;
++	uint32_t connector_num;
++	uint32_t connector_offset;
++	uint32_t encoder_num;
++	uint32_t encoder_offset;
++} __packed;
++
++struct vbios_header {
++	u32 feature;
++	u8 oem_vendor[32];
++	u8 oem_product[32];
++	u32 legacy_offset;
++	u32 legacy_size;
++	u32 desc_offset;
++	u32 desc_size;
++	u32 data_offset;
++	u32 data_size;
++} __packed;
++
++struct vbios_backlight {
++	u32 feature;
++	u8 used;
++	enum vbios_backlight_type type;
++} __packed;
++
++struct vbios_i2c {
++	u32 feature;
++	u16 id;
++	enum i2c_type type;
++} __packed;
++
++struct vbios_pwm {
++	u32 feature;
++	u8 pwm;
++	u8 polarity;
++	u32 peroid;
++} __packed;
++
++struct vbios_desc {
++	u16 type;
++	u8 ver;
++	u8 index;
++	u32 offset;
++	u32 size;
++	u64 ext[2];
++} __packed;
++
++struct vbios_cmd {
++	u8 index;
++	enum desc_type type;
++	u64 *req;
++	void *res;
++};
++
++struct desc_func {
++	enum desc_type type;
++	u16 ver;
++	s8 *name;
++	u8 index;
++	parse_func *func;
++};
++
++struct desc_node {
++	struct list_head head;
++	u8 *data;
++	struct vbios_desc *desc;
++	parse_func *parse;
++};
++
++struct vbios_crtc {
++	u32 feature;
++	u32 crtc_id;
++	u32 encoder_id;
++	u32 max_freq;
++	u32 max_width;
++	u32 max_height;
++	bool is_vb_timing;
++} __packed;
++
++struct vbios_encoder {
++	u32 feature;
++	u32 i2c_id;
++	u32 connector_id;
++	enum encoder_type type;
++	enum encoder_config config_type;
++	enum encoder_object chip;
++	u8 chip_addr;
++} __packed;
++
++struct vbios_connector {
++	u32 feature;
++	u32 i2c_id;
++	u8 internal_edid[256];
++	enum connector_type type;
++	enum hotplug hotplug;
++	enum loongson_edid_method edid_method;
++	u32 irq_gpio;
++	enum gpio_placement gpio_placement;
++} __packed;
++
++struct vbios_conf_reg {
++	u8 dev_addr;
++	u8 reg;
++	u8 value;
++} __packed;
++
++struct vbios_cfg_encoder {
++	u32 hdisplay;
++	u32 vdisplay;
++	u8 reg_num;
++	struct vbios_conf_reg config_regs[256];
++} __packed;
++
++bool loongson_vbios_init(struct loongson_drm_device *ldev);
++void loongson_vbios_exit(struct loongson_drm_device *ldev);
++u32 get_connector_type(struct loongson_drm_device *ldev, u32 index);
++u16 get_connector_i2cid(struct loongson_drm_device *ldev, u32 index);
++u16 get_hotplug_mode(struct loongson_drm_device *ldev, u32 index);
++u8 *get_vbios_edid(struct loongson_drm_device *ldev, u32 index);
++u16 get_edid_method(struct loongson_drm_device *ldev, u32 index);
++u32 get_vbios_pwm(struct loongson_drm_device *ldev, u32 index, u16 request);
++u32 get_crtc_id(struct loongson_drm_device *ldev, u32 index);
++u32 get_crtc_max_freq(struct loongson_drm_device *ldev, u32 index);
++u32 get_crtc_max_width(struct loongson_drm_device *ldev, u32 index);
++u32 get_crtc_max_height(struct loongson_drm_device *ldev, u32 index);
++u32 get_crtc_encoder_id(struct loongson_drm_device *ldev, u32 index);
++bool get_crtc_is_vb_timing(struct loongson_drm_device *ldev, u32 index);
++
++struct crtc_timing *get_crtc_timing(struct loongson_drm_device *ldev, u32 index);
++
++bool get_loongson_i2c(struct loongson_drm_device *ldev);
++u32 get_encoder_i2c_id(struct loongson_drm_device *ldev, u32 index);
++u32 get_encoder_connector_id(struct loongson_drm_device *ldev, u32 index);
++enum encoder_config get_encoder_config_type(struct loongson_drm_device *ldev, u32 index);
++enum encoder_type get_encoder_type(struct loongson_drm_device *ldev, u32 index);
++struct cfg_encoder *get_encoder_config(struct loongson_drm_device *ldev, u32 index);
++u32 get_encoder_cfg_num(struct loongson_drm_device *ldev, u32 index);
++enum encoder_object get_encoder_chip(struct loongson_drm_device *ldev, u32 index);
++u8 get_encoder_chip_addr(struct loongson_drm_device *ldev, u32 index);
++u32 get_connector_irq_gpio(struct loongson_drm_device *ldev, u32 index);
++enum gpio_placement get_connector_gpio_placement(struct loongson_drm_device *ldev,
++						 u32 index);
++#endif
diff -uNr a/debian/patches/loongarch/9002-LoongArch-Enable-AMD-GPU-DCN-for-loongarch.patch b/debian/patches/loongarch/9002-LoongArch-Enable-AMD-GPU-DCN-for-loongarch.patch
--- a/debian/patches/loongarch/9002-LoongArch-Enable-AMD-GPU-DCN-for-loongarch.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9002-LoongArch-Enable-AMD-GPU-DCN-for-loongarch.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,135 @@
+Description: <short summary of the patch>
+ TODO: Put a short summary on the line above and replace this paragraph
+ with a longer explanation of this change. Complete the meta-information
+ with other relevant fields (see below for details). To make it easier, the
+ information below has been extracted from the changelog. Adjust it or drop
+ it.
+ .
+ linux (6.4~rc7-1~exp5) experimental; urgency=medium
+ .
+   * loong64 enable USB_HID USB_KBD USB_MOUSE
+   * loong64 enable XHCI EHCI OHCI UHCI
+Author: root <root@debian-loongarch>
+
+---
+The information above should follow the Patch Tagging Guidelines, please
+checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
+are templates for supplementary fields that you might want to add:
+
+Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
+Bug: <upstream-bugtracker-url>
+Bug-Debian: https://bugs.debian.org/<bugnumber>
+Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
+Forwarded: (no|not-needed|<patch-forwarded-url>)
+Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
+Reviewed-By: <name and email of someone who approved/reviewed the patch>
+Last-Update: 2023-06-25
+
+Index: linux-6.4~rc7/drivers/gpu/drm/amd/display/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/amd/display/Kconfig
++++ linux-6.4~rc7/drivers/gpu/drm/amd/display/Kconfig
+@@ -8,7 +8,7 @@ config DRM_AMD_DC
+ 	depends on BROKEN || !CC_IS_CLANG || X86_64 || SPARC64 || ARM64
+ 	select SND_HDA_COMPONENT if SND_HDA_CORE
+ 	# !CC_IS_CLANG: https://github.com/ClangBuiltLinux/linux/issues/1752
+-	select DRM_AMD_DC_FP if (X86 || (PPC64 && ALTIVEC) || (ARM64 && KERNEL_MODE_NEON && !CC_IS_CLANG))
++	select DRM_AMD_DC_FP if (X86 || LOONGARCH || (PPC64 && ALTIVEC) || (ARM64 && KERNEL_MODE_NEON && !CC_IS_CLANG))
+ 	help
+ 	  Choose this option if you want to use the new display engine
+ 	  support for AMDGPU. This adds required support for Vega and
+Index: linux-6.4~rc7/drivers/gpu/drm/amd/display/amdgpu_dm/dc_fpu.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/amd/display/amdgpu_dm/dc_fpu.c
++++ linux-6.4~rc7/drivers/gpu/drm/amd/display/amdgpu_dm/dc_fpu.c
+@@ -33,6 +33,8 @@
+ #include <asm/cputable.h>
+ #elif defined(CONFIG_ARM64)
+ #include <asm/neon.h>
++#elif defined(CONFIG_LOONGARCH)
++#include <asm/fpu.h>
+ #endif
+ 
+ /**
+@@ -88,7 +90,7 @@ void dc_fpu_begin(const char *function_n
+ 	*pcpu += 1;
+ 
+ 	if (*pcpu == 1) {
+-#if defined(CONFIG_X86)
++#if defined(CONFIG_X86) || defined(CONFIG_LOONGARCH)
+ 		migrate_disable();
+ 		kernel_fpu_begin();
+ #elif defined(CONFIG_PPC64)
+@@ -128,7 +130,7 @@ void dc_fpu_end(const char *function_nam
+ 	pcpu = get_cpu_ptr(&fpu_recursion_depth);
+ 	*pcpu -= 1;
+ 	if (*pcpu <= 0) {
+-#if defined(CONFIG_X86)
++#if defined(CONFIG_X86) || defined(CONFIG_LOONGARCH)
+ 		kernel_fpu_end();
+ 		migrate_enable();
+ #elif defined(CONFIG_PPC64)
+Index: linux-6.4~rc7/drivers/gpu/drm/amd/display/dc/dml/Makefile
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/amd/display/dc/dml/Makefile
++++ linux-6.4~rc7/drivers/gpu/drm/amd/display/dc/dml/Makefile
+@@ -38,6 +38,11 @@ ifdef CONFIG_ARM64
+ dml_rcflags := -mgeneral-regs-only
+ endif
+ 
++ifdef CONFIG_LOONGARCH
++	dml_ccflags := -mabi=lp64s -mfpu=64
++dml_rcflags := -msoft-float
++endif
++
+ ifdef CONFIG_CC_IS_GCC
+ ifneq ($(call gcc-min-version, 70100),y)
+ IS_OLD_GCC = 1
+Index: linux-6.4~rc7/drivers/gpu/drm/radeon/cik.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/radeon/cik.c
++++ linux-6.4~rc7/drivers/gpu/drm/radeon/cik.c
+@@ -8093,6 +8093,7 @@ restart_ih:
+ 	if (queue_thermal)
+ 		schedule_work(&rdev->pm.dpm.thermal.work);
+ 	rdev->ih.rptr = rptr;
++	WREG32(IH_RB_RPTR, rptr);
+ 	atomic_set(&rdev->ih.lock, 0);
+ 
+ 	/* make sure wptr hasn't changed while processing */
+Index: linux-6.4~rc7/drivers/gpu/drm/radeon/evergreen.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/radeon/evergreen.c
++++ linux-6.4~rc7/drivers/gpu/drm/radeon/evergreen.c
+@@ -4921,6 +4921,7 @@ restart_ih:
+ 	if (queue_thermal && rdev->pm.dpm_enabled)
+ 		schedule_work(&rdev->pm.dpm.thermal.work);
+ 	rdev->ih.rptr = rptr;
++	WREG32(IH_RB_RPTR, rptr);
+ 	atomic_set(&rdev->ih.lock, 0);
+ 
+ 	/* make sure wptr hasn't changed while processing */
+Index: linux-6.4~rc7/drivers/gpu/drm/radeon/r600.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/radeon/r600.c
++++ linux-6.4~rc7/drivers/gpu/drm/radeon/r600.c
+@@ -4325,6 +4325,7 @@ restart_ih:
+ 	if (queue_thermal && rdev->pm.dpm_enabled)
+ 		schedule_work(&rdev->pm.dpm.thermal.work);
+ 	rdev->ih.rptr = rptr;
++	WREG32(IH_RB_RPTR, rptr);
+ 	atomic_set(&rdev->ih.lock, 0);
+ 
+ 	/* make sure wptr hasn't changed while processing */
+Index: linux-6.4~rc7/drivers/gpu/drm/radeon/si.c
+===================================================================
+--- linux-6.4~rc7.orig/drivers/gpu/drm/radeon/si.c
++++ linux-6.4~rc7/drivers/gpu/drm/radeon/si.c
+@@ -6438,6 +6438,7 @@ restart_ih:
+ 	if (queue_thermal && rdev->pm.dpm_enabled)
+ 		schedule_work(&rdev->pm.dpm.thermal.work);
+ 	rdev->ih.rptr = rptr;
++	WREG32(IH_RB_RPTR, rptr);
+ 	atomic_set(&rdev->ih.lock, 0);
+ 
+ 	/* make sure wptr hasn't changed while processing */
diff -uNr a/debian/patches/loongarch/9003-LoongArch-support-loongson-7A-HDA.patch b/debian/patches/loongarch/9003-LoongArch-support-loongson-7A-HDA.patch
--- a/debian/patches/loongarch/9003-LoongArch-support-loongson-7A-HDA.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9003-LoongArch-support-loongson-7A-HDA.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,1445 @@
+Description: <short summary of the patch>
+ TODO: Put a short summary on the line above and replace this paragraph
+ with a longer explanation of this change. Complete the meta-information
+ with other relevant fields (see below for details). To make it easier, the
+ information below has been extracted from the changelog. Adjust it or drop
+ it.
+ .
+ linux (6.4~rc7-1~exp5) experimental; urgency=medium
+ .
+   * loong64 enable USB_HID USB_KBD USB_MOUSE
+   * loong64 enable XHCI EHCI OHCI UHCI
+Author: root <root@debian-loongarch>
+
+---
+The information above should follow the Patch Tagging Guidelines, please
+checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
+are templates for supplementary fields that you might want to add:
+
+Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
+Bug: <upstream-bugtracker-url>
+Bug-Debian: https://bugs.debian.org/<bugnumber>
+Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
+Forwarded: (no|not-needed|<patch-forwarded-url>)
+Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
+Reviewed-By: <name and email of someone who approved/reviewed the patch>
+Last-Update: 2023-06-25
+
+Index: linux-6.4~rc7/arch/loongarch/configs/loongson3_defconfig
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/configs/loongson3_defconfig
++++ linux-6.4~rc7/arch/loongarch/configs/loongson3_defconfig
+@@ -660,6 +660,7 @@ CONFIG_SND_SEQ_DUMMY=m
+ CONFIG_SND_BT87X=m
+ CONFIG_SND_BT87X_OVERCLOCK=y
+ CONFIG_SND_HDA_INTEL=y
++CONFIG_SND_HDA_LOONGSON=y
+ CONFIG_SND_HDA_HWDEP=y
+ CONFIG_SND_HDA_INPUT_BEEP=y
+ CONFIG_SND_HDA_PATCH_LOADER=y
+Index: linux-6.4~rc7/include/linux/pci_ids.h
+===================================================================
+--- linux-6.4~rc7.orig/include/linux/pci_ids.h
++++ linux-6.4~rc7/include/linux/pci_ids.h
+@@ -157,6 +157,21 @@
+ #define PCI_VENDOR_ID_PCI_SIG		0x0001
+ 
+ #define PCI_VENDOR_ID_LOONGSON		0x0014
++#define PCI_DEVICE_ID_LOONGSON_HOST     0x7a00
++#define PCI_DEVICE_ID_LOONGSON_APB      0x7a02
++#define PCI_DEVICE_ID_LOONGSON_GMAC     0x7a03
++#define PCI_DEVICE_ID_LOONGSON_GNET     0x7a13
++#define PCI_DEVICE_ID_LOONGSON_DC1      0x7a06
++#define PCI_DEVICE_ID_LOONGSON_DC2      0x7a36
++#define PCI_DEVICE_ID_LOONGSON_HDA      0x7a07
++#define PCI_DEVICE_ID_LOONGSON_GPU      0x7a15
++#define PCI_DEVICE_ID_LOONGSON_AHCI     0x7a08
++#define PCI_DEVICE_ID_LOONGSON_EHCI     0x7a14
++#define PCI_DEVICE_ID_LOONGSON_OHCI     0x7a24
++#define PCI_DEVICE_ID_LOONGSON_LPC      0x7a0c
++#define PCI_DEVICE_ID_LOONGSON_DMA      0x7a0f
++#define PCI_DEVICE_ID_LOONGSON_IOMMU	0x7a1f
++#define PCI_DEVICE_ID_LOONGSON_HDMI     0x7a37
+ 
+ #define PCI_VENDOR_ID_TTTECH		0x0357
+ #define PCI_DEVICE_ID_TTTECH_MC322	0x000a
+Index: linux-6.4~rc7/sound/hda/hdac_bus.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/hda/hdac_bus.c
++++ linux-6.4~rc7/sound/hda/hdac_bus.c
+@@ -11,6 +11,7 @@
+ #include <sound/hdaudio.h>
+ #include "local.h"
+ #include "trace.h"
++#include "../pci/hda/hda_controller.h"
+ 
+ static void snd_hdac_bus_process_unsol_events(struct work_struct *work);
+ 
+@@ -109,6 +110,7 @@ int snd_hdac_bus_exec_verb_unlocked(stru
+ {
+ 	unsigned int tmp;
+ 	int err;
++	struct azx *chip = bus_to_azx(bus);
+ 
+ 	if (cmd == ~0)
+ 		return -EINVAL;
+@@ -117,7 +119,9 @@ int snd_hdac_bus_exec_verb_unlocked(stru
+ 		*res = -1;
+ 	else if (bus->sync_write)
+ 		res = &tmp;
+-	for (;;) {
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		err = bus->ops->command(bus, cmd);
++	else for (;;) {
+ 		trace_hda_send_cmd(bus, cmd);
+ 		err = bus->ops->command(bus, cmd);
+ 		if (err != -EAGAIN)
+Index: linux-6.4~rc7/sound/hda/hdac_controller.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/hda/hdac_controller.c
++++ linux-6.4~rc7/sound/hda/hdac_controller.c
+@@ -10,6 +10,7 @@
+ #include <sound/hdaudio.h>
+ #include <sound/hda_register.h>
+ #include "local.h"
++#include "../pci/hda/hda_controller.h"
+ 
+ /* clear CORB read pointer properly */
+ static void azx_clear_corbrp(struct hdac_bus *bus)
+@@ -42,6 +43,8 @@ static void azx_clear_corbrp(struct hdac
+  */
+ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
+ {
++	struct azx *chip = bus_to_azx(bus);
++
+ 	WARN_ON_ONCE(!bus->rb.area);
+ 
+ 	spin_lock_irq(&bus->reg_lock);
+@@ -58,11 +61,15 @@ void snd_hdac_bus_init_cmd_io(struct hda
+ 
+ 	/* reset the corb hw read pointer */
+ 	snd_hdac_chip_writew(bus, CORBRP, AZX_CORBRP_RST);
+-	if (!bus->corbrp_self_clear)
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		snd_hdac_chip_writew(bus, CORBRP, 0);
++	else if (!bus->corbrp_self_clear)
+ 		azx_clear_corbrp(bus);
+ 
+ 	/* enable corb dma */
+ 	snd_hdac_chip_writeb(bus, CORBCTL, AZX_CORBCTL_RUN);
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		snd_hdac_chip_readb(bus, CORBCTL);
+ 
+ 	/* RIRB set up */
+ 	bus->rirb.addr = bus->rb.addr + 2048;
+@@ -79,7 +86,12 @@ void snd_hdac_bus_init_cmd_io(struct hda
+ 	/* set N=1, get RIRB response interrupt for new entry */
+ 	snd_hdac_chip_writew(bus, RINTCNT, 1);
+ 	/* enable rirb dma and response irq */
+-	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++		snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN);
++		snd_hdac_chip_readb(bus, RIRBCTL);
++	}
++	else
++		snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
+ 	/* Accept unsolicited responses */
+ 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
+ 	spin_unlock_irq(&bus->reg_lock);
+@@ -132,6 +144,18 @@ static unsigned int azx_command_addr(u32
+ 	return addr;
+ }
+ 
++static unsigned int azx_response_addr(u32 res)
++{
++	unsigned int addr = res & 0xf;
++
++	if (addr >= AZX_MAX_CODECS) {
++		snd_BUG();
++		addr = 0;
++	}
++
++	return addr;
++}
++
+ /**
+  * snd_hdac_bus_send_cmd - send a command verb via CORB
+  * @bus: HD-audio core bus
+@@ -207,13 +231,8 @@ void snd_hdac_bus_update_rirb(struct hda
+ 		rp = bus->rirb.rp << 1; /* an RIRB entry is 8-bytes */
+ 		res_ex = le32_to_cpu(bus->rirb.buf[rp + 1]);
+ 		res = le32_to_cpu(bus->rirb.buf[rp]);
+-		addr = res_ex & 0xf;
+-		if (addr >= HDA_MAX_CODECS) {
+-			dev_err(bus->dev,
+-				"spurious response %#x:%#x, rp = %d, wp = %d",
+-				res, res_ex, bus->rirb.rp, wp);
+-			snd_BUG();
+-		} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)
++		addr = azx_response_addr(res_ex);
++		if (res_ex & AZX_RIRB_EX_UNSOL_EV)
+ 			snd_hdac_bus_queue_event(bus, res, res_ex);
+ 		else if (bus->rirb.cmds[addr]) {
+ 			bus->rirb.res[addr] = res;
+@@ -482,16 +501,24 @@ static void azx_int_disable(struct hdac_
+ static void azx_int_clear(struct hdac_bus *bus)
+ {
+ 	struct hdac_stream *azx_dev;
++	struct azx *chip = bus_to_azx(bus);
+ 
+ 	/* clear stream status */
+-	list_for_each_entry(azx_dev, &bus->stream_list, list)
+-		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
++	list_for_each_entry(azx_dev, &bus->stream_list, list) {
++		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++			snd_hdac_stream_updateb(azx_dev, SD_STS, 0, 0);
++		else
++			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
++	}
+ 
+ 	/* clear STATESTS */
+ 	snd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);
+ 
+ 	/* clear rirb status */
+-	snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		snd_hdac_chip_updateb(bus, RIRBSTS, ~RIRB_INT_MASK, 0);
++	else
++		snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
+ 
+ 	/* clear int status */
+ 	snd_hdac_chip_writel(bus, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);
+@@ -572,11 +599,17 @@ int snd_hdac_bus_handle_stream_irq(struc
+ 	struct hdac_stream *azx_dev;
+ 	u8 sd_status;
+ 	int handled = 0;
++	struct azx *chip = bus_to_azx(bus);
+ 
+ 	list_for_each_entry(azx_dev, &bus->stream_list, list) {
+ 		if (status & azx_dev->sd_int_sta_mask) {
+ 			sd_status = snd_hdac_stream_readb(azx_dev, SD_STS);
+-			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
++			if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++				snd_hdac_stream_writeb(azx_dev, SD_STS, sd_status);
++				snd_hdac_stream_readb(azx_dev, SD_STS);
++			}
++			else
++				snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+ 			handled |= 1 << azx_dev->index;
+ 			if ((!azx_dev->substream && !azx_dev->cstream) ||
+ 			    !azx_dev->running || !(sd_status & SD_INT_COMPLETE))
+Index: linux-6.4~rc7/sound/hda/hdac_device.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/hda/hdac_device.c
++++ linux-6.4~rc7/sound/hda/hdac_device.c
+@@ -645,6 +645,7 @@ struct hda_vendor_id {
+ };
+ 
+ static const struct hda_vendor_id hda_vendor_ids[] = {
++	{ 0x0014, "Loongson" },
+ 	{ 0x1002, "ATI" },
+ 	{ 0x1013, "Cirrus Logic" },
+ 	{ 0x1057, "Motorola" },
+Index: linux-6.4~rc7/sound/hda/hdac_stream.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/hda/hdac_stream.c
++++ linux-6.4~rc7/sound/hda/hdac_stream.c
+@@ -13,6 +13,7 @@
+ #include <sound/hdaudio.h>
+ #include <sound/hda_register.h>
+ #include "trace.h"
++#include "../pci/hda/hda_controller.h"
+ 
+ /*
+  * the hdac_stream library is intended to be used with the following
+@@ -130,6 +131,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_stream_init);
+ void snd_hdac_stream_start(struct hdac_stream *azx_dev)
+ {
+ 	struct hdac_bus *bus = azx_dev->bus;
++	struct azx *chip = bus_to_azx(bus);
+ 	int stripe_ctl;
+ 
+ 	trace_snd_hdac_stream_start(bus, azx_dev);
+@@ -146,11 +148,19 @@ void snd_hdac_stream_start(struct hdac_s
+ 			stripe_ctl = snd_hdac_get_stream_stripe_ctl(bus, azx_dev->substream);
+ 		else
+ 			stripe_ctl = 0;
+-		snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
++		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++			snd_hdac_stream_updatel(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
++					stripe_ctl);
++		else
++			snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK,
+ 					stripe_ctl);
+ 	}
+ 	/* set DMA start and interrupt mask */
+-	snd_hdac_stream_updateb(azx_dev, SD_CTL,
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		snd_hdac_stream_updatel(azx_dev, SD_CTL,
++				0, SD_CTL_DMA_START | SD_INT_MASK);
++	else
++		snd_hdac_stream_updateb(azx_dev, SD_CTL,
+ 				0, SD_CTL_DMA_START | SD_INT_MASK);
+ 	azx_dev->running = true;
+ }
+@@ -162,11 +172,31 @@ EXPORT_SYMBOL_GPL(snd_hdac_stream_start)
+  */
+ static void snd_hdac_stream_clear(struct hdac_stream *azx_dev)
+ {
+-	snd_hdac_stream_updateb(azx_dev, SD_CTL,
+-				SD_CTL_DMA_START | SD_INT_MASK, 0);
+-	snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
+-	if (azx_dev->stripe)
+-		snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
++	int stream;
++	struct azx *chip = bus_to_azx(azx_dev->bus);
++	struct snd_pcm_substream *substream = azx_dev->substream;
++
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++		snd_hdac_stream_updatel(azx_dev, SD_CTL,
++					SD_CTL_DMA_START | SD_INT_MASK, 0);
++		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
++		if (azx_dev->stripe)
++			snd_hdac_stream_updatel(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
++
++		if (!substream)
++			stream_to_azx_dev(azx_dev)->fix_prvpos = 0;
++		else {
++			stream = substream->stream;
++			stream_to_azx_dev(azx_dev)->fix_prvpos =
++				chip->get_position[stream](chip, stream_to_azx_dev(azx_dev));
++		}
++	} else {
++		snd_hdac_stream_updateb(azx_dev, SD_CTL,
++					SD_CTL_DMA_START | SD_INT_MASK, 0);
++		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK); /* to be sure */
++		if (azx_dev->stripe)
++			snd_hdac_stream_updateb(azx_dev, SD_CTL_3B, SD_CTL_STRIPE_MASK, 0);
++	}
+ 	azx_dev->running = false;
+ }
+ 
+@@ -221,6 +251,10 @@ void snd_hdac_stream_reset(struct hdac_s
+ {
+ 	unsigned char val;
+ 	int dma_run_state;
++	struct azx *chip = bus_to_azx(azx_dev->bus);
++
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		goto out;
+ 
+ 	snd_hdac_stream_clear(azx_dev);
+ 
+@@ -239,6 +273,7 @@ void snd_hdac_stream_reset(struct hdac_s
+ 	/* wait for hardware to report that the stream is out of reset */
+ 	snd_hdac_stream_readb_poll(azx_dev, SD_CTL, val, !(val & SD_CTL_STREAM_RESET), 3, 300);
+ 
++out:
+ 	/* reset first position - may not be synced with hw at this time */
+ 	if (azx_dev->posbuf)
+ 		*azx_dev->posbuf = 0;
+@@ -254,6 +289,7 @@ int snd_hdac_stream_setup(struct hdac_st
+ 	struct hdac_bus *bus = azx_dev->bus;
+ 	struct snd_pcm_runtime *runtime;
+ 	unsigned int val;
++	struct azx *chip = bus_to_azx(bus);
+ 
+ 	if (azx_dev->substream)
+ 		runtime = azx_dev->substream->runtime;
+@@ -270,7 +306,14 @@ int snd_hdac_stream_setup(struct hdac_st
+ 	snd_hdac_stream_writel(azx_dev, SD_CTL, val);
+ 
+ 	/* program the length of samples in cyclic buffer */
+-	snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++		if(azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
++			snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize - 64);
++		else
++			snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize - 16);
++	}
++	else
++		snd_hdac_stream_writel(azx_dev, SD_CBL, azx_dev->bufsize);
+ 
+ 	/* program the stream format */
+ 	/* this value needs to be the same as the one programmed */
+@@ -491,6 +534,7 @@ int snd_hdac_stream_setup_periods(struct
+ 	__le32 *bdl;
+ 	int i, ofs, periods, period_bytes;
+ 	int pos_adj, pos_align;
++	struct azx *chip = bus_to_azx(bus);
+ 
+ 	if (substream) {
+ 		runtime = substream->runtime;
+@@ -515,6 +559,8 @@ int snd_hdac_stream_setup_periods(struct
+ 	azx_dev->frags = 0;
+ 
+ 	pos_adj = bus->bdl_pos_adj;
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		pos_adj = 0;
+ 	if (runtime && !azx_dev->no_period_wakeup && pos_adj > 0) {
+ 		pos_align = pos_adj;
+ 		pos_adj = DIV_ROUND_UP(pos_adj * runtime->rate, 48000);
+Index: linux-6.4~rc7/sound/pci/hda/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/Kconfig
++++ linux-6.4~rc7/sound/pci/hda/Kconfig
+@@ -42,6 +42,17 @@ config SND_HDA_TEGRA
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called snd-hda-tegra.
+ 
++config SND_HDA_LOONGSON
++	tristate "Loongson HD Audio"
++	depends on MACH_LOONGSON64
++	select SND_HDA
++	help
++	  Say Y here to include support for Loongson's LS7A "High
++	  Definition Audio" controller.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called snd-hda-loongson.
++
+ if SND_HDA
+ 
+ config SND_HDA_HWDEP
+Index: linux-6.4~rc7/sound/pci/hda/Makefile
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/Makefile
++++ linux-6.4~rc7/sound/pci/hda/Makefile
+@@ -1,6 +1,7 @@
+ # SPDX-License-Identifier: GPL-2.0
+ snd-hda-intel-objs := hda_intel.o
+ snd-hda-tegra-objs := hda_tegra.o
++snd-hda-loongson-objs := hda_loongson.o
+ 
+ snd-hda-codec-y := hda_bind.o hda_codec.o hda_jack.o hda_auto_parser.o hda_sysfs.o
+ snd-hda-codec-y += hda_controller.o
+@@ -62,3 +63,4 @@ obj-$(CONFIG_SND_HDA_CS_DSP_CONTROLS) +=
+ # when built in kernel
+ obj-$(CONFIG_SND_HDA_INTEL) += snd-hda-intel.o
+ obj-$(CONFIG_SND_HDA_TEGRA) += snd-hda-tegra.o
++obj-$(CONFIG_SND_HDA_LOONGSON) += snd-hda-loongson.o
+Index: linux-6.4~rc7/sound/pci/hda/hda_controller.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/hda_controller.c
++++ linux-6.4~rc7/sound/pci/hda/hda_controller.c
+@@ -295,6 +295,23 @@ unsigned int azx_get_position(struct azx
+ 	int stream = substream->stream;
+ 	int delay = 0;
+ 
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++		pos = chip->get_position[stream](chip, azx_dev);
++
++		if (pos >= azx_dev->fix_prvpos) {
++			pos = pos - azx_dev->fix_prvpos;
++			pos %= azx_dev->core.bufsize;
++		} else {
++			if (azx_dev->fix_prvpos > azx_dev->core.bufsize)
++				pos = (0x100000000ULL + pos-azx_dev->fix_prvpos)
++					% azx_dev->core.bufsize;
++			else
++				pos = pos + azx_dev->core.bufsize - azx_dev->fix_prvpos;
++		}
++
++		return pos;
++	}
++
+ 	if (chip->get_position[stream])
+ 		pos = chip->get_position[stream](chip, azx_dev);
+ 	else /* use the position buffer as default */
+@@ -908,6 +925,8 @@ static int azx_send_cmd(struct hdac_bus
+ 
+ 	if (chip->disabled)
+ 		return 0;
++	if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++		udelay(500);
+ 	if (chip->single_cmd)
+ 		return azx_single_send_cmd(bus, val);
+ 	else
+@@ -1064,8 +1083,9 @@ static void stream_update(struct hdac_bu
+ irqreturn_t azx_interrupt(int irq, void *dev_id)
+ {
+ 	struct azx *chip = dev_id;
++	struct hdac_stream *azx_dev;
+ 	struct hdac_bus *bus = azx_bus(chip);
+-	u32 status;
++	u32 i = 0, status = 0;
+ 	bool active, handled = false;
+ 	int repeat = 0; /* count for avoiding endless loop */
+ 
+@@ -1081,8 +1101,21 @@ irqreturn_t azx_interrupt(int irq, void
+ 		goto unlock;
+ 
+ 	do {
+-		status = azx_readl(chip, INTSTS);
+-		if (status == 0 || status == 0xffffffff)
++		if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND) {
++			i = 0;
++			status = 0;
++			list_for_each_entry(azx_dev, &bus->stream_list, list) {
++				status |= (snd_hdac_stream_readb(azx_dev, SD_STS) & SD_INT_MASK) ?
++				    (1 << i) : 0;
++				i++;
++			}
++			status |= (status & ~0) ? (1 << 31) : 0;
++		}
++		else
++			status = azx_readl(chip, INTSTS);
++
++		if (status == 0 ||
++			(status == 0xffffffff && !(chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)))
+ 			break;
+ 
+ 		handled = true;
+@@ -1100,7 +1133,10 @@ irqreturn_t azx_interrupt(int irq, void
+ 			 * remain unserviced by IRQ, eventually falling back
+ 			 * to polling mode in azx_rirb_get_response.
+ 			 */
+-			azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
++			if (chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND)
++				azx_writeb(chip, RIRBSTS, status & RIRB_INT_MASK);
++			else
++				azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
+ 			active = true;
+ 			if (status & RIRB_INT_RESPONSE) {
+ 				if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
+Index: linux-6.4~rc7/sound/pci/hda/hda_controller.h
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/hda_controller.h
++++ linux-6.4~rc7/sound/pci/hda/hda_controller.h
+@@ -45,6 +45,7 @@
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
++#define AZX_DCAPS_LS2X_WORKAROUND (1 << 31)	/* Loongson-2H workaround */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+@@ -63,6 +64,9 @@ struct azx_dev {
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
++
++	/* For Loongson */
++	unsigned int fix_prvpos;
+ };
+ 
+ #define azx_stream(dev)		(&(dev)->core)
+Index: linux-6.4~rc7/sound/pci/hda/hda_loongson.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/sound/pci/hda/hda_loongson.c
+@@ -0,0 +1,849 @@
++/*
++ *
++ *  hda_loongson.c - Implementation of primary alsa driver code base
++ *                for Intel HD Audio.
++ *
++ *  Copyright (c) 2004 Intel Corporation. All rights reserved.
++ *
++ *  Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
++ *                     PeiSen Hou <pshou@realtek.com.tw>
++ *
++ *  Copyright (c) 2014 Huacai Chen <chenhc@lemote.com>
++ *
++ *  This program is free software; you can redistribute it and/or modify it
++ *  under the terms of the GNU General Public License as published by the Free
++ *  Software Foundation; either version 2 of the License, or (at your option)
++ *  any later version.
++ *
++ *  This program is distributed in the hope that it will be useful, but WITHOUT
++ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ *  more details.
++ *
++ *  You should have received a copy of the GNU General Public License along with
++ *  this program; if not, write to the Free Software Foundation, Inc., 59
++ *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
++ *
++ *  CONTACTS:
++ *
++ *  Matt Jared		matt.jared@intel.com
++ *  Andy Kopp		andy.kopp@intel.com
++ *  Dan Kogan		dan.d.kogan@intel.com
++ *
++ *  CHANGES:
++ *
++ *  2004.12.01	Major rewrite by tiwai, merged the work of pshou
++ *
++ */
++
++#include <linux/delay.h>
++#include <linux/interrupt.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/dma-mapping.h>
++#include <linux/moduleparam.h>
++#include <linux/init.h>
++#include <linux/slab.h>
++#include <linux/platform_device.h>
++#include <linux/mutex.h>
++#include <linux/reboot.h>
++#include <linux/io.h>
++#include <linux/pm_runtime.h>
++#include <linux/clocksource.h>
++#include <linux/time.h>
++#include <linux/completion.h>
++#include <linux/firmware.h>
++
++#include <sound/core.h>
++#include <sound/initval.h>
++#include <sound/hda_codec.h>
++#include <asm/loongson.h>
++#include "hda_controller.h"
++
++#define LS7A_NUM_CAPTURE	4
++#define LS7A_NUM_PLAYBACK	4
++
++static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
++static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
++static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
++static char *model[SNDRV_CARDS];
++static int bdl_pos_adj[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = -1};
++static int probe_only[SNDRV_CARDS];
++static int jackpoll_ms[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1200};
++static bool single_cmd;
++static int enable_msi = -1;
++#ifdef CONFIG_SND_HDA_INPUT_BEEP
++static bool beep_mode[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] =
++					CONFIG_SND_HDA_INPUT_BEEP_MODE};
++#endif
++
++module_param_array(index, int, NULL, 0444);
++MODULE_PARM_DESC(index, "Index value for Intel HD audio interface.");
++module_param_array(id, charp, NULL, 0444);
++MODULE_PARM_DESC(id, "ID string for Intel HD audio interface.");
++module_param_array(enable, bool, NULL, 0444);
++MODULE_PARM_DESC(enable, "Enable Intel HD audio interface.");
++module_param_array(model, charp, NULL, 0444);
++MODULE_PARM_DESC(model, "Use the given board model.");
++module_param_array(bdl_pos_adj, int, NULL, 0644);
++MODULE_PARM_DESC(bdl_pos_adj, "BDL position adjustment offset.");
++module_param_array(probe_only, int, NULL, 0444);
++MODULE_PARM_DESC(probe_only, "Only probing and no codec initialization.");
++module_param_array(jackpoll_ms, int, NULL, 0444);
++MODULE_PARM_DESC(jackpoll_ms, "Ms between polling for jack events (default = 0, using unsol events only)");
++module_param(single_cmd, bool, 0444);
++MODULE_PARM_DESC(single_cmd, "Use single command to communicate with codecs "
++		 "(for debugging only).");
++module_param(enable_msi, bint, 0444);
++MODULE_PARM_DESC(enable_msi, "Enable Message Signaled Interrupt (MSI)");
++#ifdef CONFIG_SND_HDA_INPUT_BEEP
++module_param_array(beep_mode, bool, NULL, 0444);
++MODULE_PARM_DESC(beep_mode, "Select HDA Beep registration mode "
++			    "(0=off, 1=on) (default=1).");
++#endif
++
++#ifdef CONFIG_PM
++static int param_set_xint(const char *val, const struct kernel_param *kp);
++static struct kernel_param_ops param_ops_xint = {
++	.set = param_set_xint,
++	.get = param_get_int,
++};
++#define param_check_xint param_check_int
++
++static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
++module_param(power_save, xint, 0644);
++MODULE_PARM_DESC(power_save, "Automatic power-saving timeout "
++		 "(in second, 0 = disable).");
++
++/* reset the HD-audio controller in power save mode.
++ * this may give more power-saving, but will take longer time to
++ * wake up.
++ */
++static bool power_save_controller = 1;
++module_param(power_save_controller, bool, 0644);
++MODULE_PARM_DESC(power_save_controller, "Reset controller in power save mode.");
++#else
++#define power_save	0
++#endif /* CONFIG_PM */
++
++static int align_buffer_size = -1;
++module_param(align_buffer_size, bint, 0644);
++MODULE_PARM_DESC(align_buffer_size,
++		"Force buffer and period sizes to be multiple of 128 bytes.");
++
++MODULE_LICENSE("GPL");
++MODULE_DESCRIPTION("Loongson LS7A HDA driver");
++
++/* driver types */
++enum {
++	AZX_DRIVER_LS7A,
++	AZX_DRIVER_HDMI,
++	AZX_NUM_DRIVERS, /* keep this as last entry */
++};
++
++static char *driver_short_names[] = {
++	[AZX_DRIVER_LS7A] = "HD-Audio Loongson",
++	[AZX_DRIVER_HDMI] = "HD-Audio Loongson HDMI",
++};
++
++struct hda_loongson {
++	struct azx chip;
++
++	/* for pending irqs */
++	struct work_struct irq_pending_work;
++
++	/* sync probing */
++	struct completion probe_wait;
++	struct work_struct probe_work;
++
++	/* card list (for power_save trigger) */
++	struct list_head list;
++
++	/* extra flags */
++	unsigned int irq_pending_warned:1;
++	unsigned int probe_continued:1;
++};
++
++static int azx_acquire_irq(struct azx *chip, int do_disconnect);
++
++static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
++
++/* called from IRQ */
++static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
++{
++	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
++	int ok;
++
++	ok = azx_position_ok(chip, azx_dev);
++	if (ok == 1) {
++		azx_dev->irq_pending = 0;
++		return ok;
++	} else if (ok == 0) {
++		/* bogus IRQ, process it later */
++		azx_dev->irq_pending = 1;
++		schedule_work(&hda->irq_pending_work);
++	}
++	return 0;
++}
++
++/*
++ * Check whether the current DMA position is acceptable for updating
++ * periods.  Returns non-zero if it's OK.
++ *
++ * Many HD-audio controllers appear pretty inaccurate about
++ * the update-IRQ timing.  The IRQ is issued before actually the
++ * data is processed.  So, we need to process it afterwords in a
++ * workqueue.
++ */
++static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
++{
++	return 1; /* OK, it's fine */
++}
++
++/*
++ * The work for pending PCM period updates.
++ */
++static void azx_irq_pending_work(struct work_struct *work)
++{
++	struct hda_loongson *hda = container_of(work, struct hda_loongson, irq_pending_work);
++	struct azx *chip = &hda->chip;
++	struct hdac_bus *bus = azx_bus(chip);
++	struct hdac_stream *s;
++	int pending, ok;
++
++	if (!hda->irq_pending_warned) {
++		dev_info(chip->card->dev,
++			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
++			 chip->card->number);
++		hda->irq_pending_warned = 1;
++	}
++
++	for (;;) {
++		pending = 0;
++		spin_lock_irq(&bus->reg_lock);
++		list_for_each_entry(s, &bus->stream_list, list) {
++			struct azx_dev *azx_dev = stream_to_azx_dev(s);
++			if (!azx_dev->irq_pending ||
++			    !s->substream ||
++			    !s->running)
++				continue;
++			ok = azx_position_ok(chip, azx_dev);
++			if (ok > 0) {
++				azx_dev->irq_pending = 0;
++				spin_unlock(&bus->reg_lock);
++				snd_pcm_period_elapsed(s->substream);
++				spin_lock(&bus->reg_lock);
++			} else if (ok < 0) {
++				pending = 0;	/* too early */
++			} else
++				pending++;
++		}
++		spin_unlock_irq(&bus->reg_lock);
++		if (!pending)
++			return;
++		msleep(1);
++	}
++}
++
++/* clear irq_pending flags and assure no on-going workq */
++static void azx_clear_irq_pending(struct azx *chip)
++{
++	struct hdac_bus *bus = azx_bus(chip);
++	struct hdac_stream *s;
++
++	spin_lock_irq(&bus->reg_lock);
++	list_for_each_entry(s, &bus->stream_list, list) {
++		struct azx_dev *azx_dev = stream_to_azx_dev(s);
++		azx_dev->irq_pending = 0;
++	}
++	spin_unlock_irq(&bus->reg_lock);
++}
++
++static int azx_acquire_irq(struct azx *chip, int do_disconnect)
++{
++	struct hdac_bus *bus = azx_bus(chip);
++	int irq;
++
++	if (chip->pci)
++		irq = chip->pci->irq;
++	else
++		irq = platform_get_irq(to_platform_device(chip->card->dev), 0);
++
++	if (request_irq(irq, azx_interrupt, chip->msi ? 0 : IRQF_SHARED,
++			KBUILD_MODNAME, chip)) {
++		dev_err(chip->card->dev,
++			"unable to grab IRQ %d, disabling device\n", irq);
++		if (do_disconnect)
++			snd_card_disconnect(chip->card);
++		return -1;
++	}
++	bus->irq = irq;
++	return 0;
++}
++
++#ifdef CONFIG_PM
++static DEFINE_MUTEX(card_list_lock);
++static LIST_HEAD(card_list);
++
++static void azx_add_card_list(struct azx *chip)
++{
++	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
++	mutex_lock(&card_list_lock);
++	list_add(&hda->list, &card_list);
++	mutex_unlock(&card_list_lock);
++}
++
++static void azx_del_card_list(struct azx *chip)
++{
++	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
++	mutex_lock(&card_list_lock);
++	list_del_init(&hda->list);
++	mutex_unlock(&card_list_lock);
++}
++
++/* trigger power-save check at writing parameter */
++static int param_set_xint(const char *val, const struct kernel_param *kp)
++{
++	struct hda_loongson *hda;
++	struct azx *chip;
++	int prev = power_save;
++	int ret = param_set_int(val, kp);
++
++	if (ret || prev == power_save)
++		return ret;
++
++	mutex_lock(&card_list_lock);
++	list_for_each_entry(hda, &card_list, list) {
++		chip = &hda->chip;
++		if (!hda->probe_continued || chip->disabled)
++			continue;
++		snd_hda_set_power_save(&chip->bus, power_save * 1000);
++	}
++	mutex_unlock(&card_list_lock);
++	return 0;
++}
++#else
++#define azx_add_card_list(chip) /* NOP */
++#define azx_del_card_list(chip) /* NOP */
++#endif /* CONFIG_PM */
++
++#if defined(CONFIG_PM_SLEEP)
++/*
++ * power management
++ */
++static int azx_suspend(struct device *dev)
++{
++	struct snd_card *card = dev_get_drvdata(dev);
++	struct azx *chip = card->private_data;
++	struct hdac_bus *bus;
++
++	if (chip->disabled)
++		return 0;
++
++	bus = azx_bus(chip);
++	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
++	azx_clear_irq_pending(chip);
++	azx_stop_chip(chip);
++	azx_enter_link_reset(chip);
++	if (bus->irq >= 0) {
++		free_irq(bus->irq, chip);
++		bus->irq = -1;
++	}
++	return 0;
++}
++
++static int azx_resume(struct device *dev)
++{
++	struct snd_card *card = dev_get_drvdata(dev);
++	struct azx *chip = card->private_data;
++
++	if (chip->disabled)
++		return 0;
++
++	chip->msi = 0;
++	if (azx_acquire_irq(chip, 1) < 0)
++		return -EIO;
++
++	azx_init_chip(chip, true);
++
++	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
++	return 0;
++}
++#endif /* CONFIG_PM_SLEEP */
++
++#ifdef CONFIG_PM
++static int azx_runtime_suspend(struct device *dev)
++{
++	struct snd_card *card = dev_get_drvdata(dev);
++	struct azx *chip = card->private_data;
++
++	if (chip->disabled)
++		return 0;
++
++	if (!azx_has_pm_runtime(chip))
++		return 0;
++
++	/* enable controller wake up event */
++	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |
++		  STATESTS_INT_MASK);
++
++	azx_stop_chip(chip);
++	azx_enter_link_reset(chip);
++	azx_clear_irq_pending(chip);
++	return 0;
++}
++
++static int azx_runtime_resume(struct device *dev)
++{
++	struct snd_card *card = dev_get_drvdata(dev);
++	struct azx *chip = card->private_data;
++	struct hda_codec *codec;
++	int status;
++
++	if (chip->disabled)
++		return 0;
++
++	if (!azx_has_pm_runtime(chip))
++		return 0;
++
++	/* Read STATESTS before controller reset */
++	status = azx_readw(chip, STATESTS);
++
++	azx_init_chip(chip, true);
++
++	if (status) {
++		list_for_each_codec(codec, &chip->bus)
++			if (status & (1 << codec->addr))
++				schedule_delayed_work(&codec->jackpoll_work,
++						      codec->jackpoll_interval);
++	}
++
++	/* disable controller Wake Up event*/
++	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &
++			~STATESTS_INT_MASK);
++
++	return 0;
++}
++
++static int azx_runtime_idle(struct device *dev)
++{
++	struct snd_card *card = dev_get_drvdata(dev);
++	struct azx *chip = card->private_data;
++
++	if (chip->disabled)
++		return 0;
++
++	if (!power_save_controller || !azx_has_pm_runtime(chip) ||
++	    azx_bus(chip)->codec_powered)
++		return -EBUSY;
++
++	return 0;
++}
++
++#endif /* CONFIG_PM */
++
++#ifdef CONFIG_PM
++static const struct dev_pm_ops azx_pm = {
++	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
++	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
++};
++
++#define AZX_PM_OPS	&azx_pm
++#else
++#define AZX_PM_OPS	NULL
++#endif /* CONFIG_PM */
++
++static int azx_probe_continue(struct azx *chip);
++
++/*
++ * destructor
++ */
++static int azx_free(struct azx *chip)
++{
++	struct device *snddev = chip->card->dev;
++	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
++	struct hdac_bus *bus = azx_bus(chip);
++
++	if (azx_has_pm_runtime(chip) && chip->running)
++		pm_runtime_get_noresume(snddev);
++
++	azx_del_card_list(chip);
++
++	complete_all(&hda->probe_wait);
++
++	if (bus->chip_init) {
++		azx_clear_irq_pending(chip);
++		azx_stop_all_streams(chip);
++		azx_stop_chip(chip);
++	}
++
++	if (bus->irq >= 0)
++		free_irq(bus->irq, (void*)chip);
++	if (bus->remap_addr)
++		iounmap(bus->remap_addr);
++
++	azx_free_stream_pages(chip);
++	azx_free_streams(chip);
++	snd_hdac_bus_exit(bus);
++	kfree(hda);
++
++	return 0;
++}
++
++static int azx_dev_disconnect(struct snd_device *device)
++{
++	struct azx *chip = device->device_data;
++
++	chip->bus.shutdown = 1;
++	return 0;
++}
++
++static int azx_dev_free(struct snd_device *device)
++{
++	return azx_free(device->device_data);
++}
++
++/*
++ * constructor
++ */
++static const struct hda_controller_ops loongson_hda_ops;
++
++static int azx_create(struct snd_card *card, struct pci_dev *pcidev,
++		      struct platform_device *platdev, int dev,
++		      unsigned int driver_caps, struct azx **rchip)
++{
++	static struct snd_device_ops ops = {
++		.dev_disconnect = azx_dev_disconnect,
++		.dev_free = azx_dev_free,
++	};
++	struct hda_loongson *hda;
++	struct azx *chip;
++	int err;
++
++	*rchip = NULL;
++
++	hda = kzalloc(sizeof(*hda), GFP_KERNEL);
++	if (!hda) {
++		dev_err(card->dev, "Cannot allocate hda\n");
++		return -ENOMEM;
++	}
++
++	chip = &hda->chip;
++	mutex_init(&chip->open_mutex);
++	chip->card = card;
++	chip->pci = pcidev;
++	chip->ops = &loongson_hda_ops;
++	chip->driver_caps = driver_caps;
++	chip->driver_type = driver_caps & 0xff;
++	chip->dev_index = dev;
++	if (jackpoll_ms[dev] >= 50 && jackpoll_ms[dev] <= 60000)
++		chip->jackpoll_interval = msecs_to_jiffies(jackpoll_ms[dev]);
++	INIT_LIST_HEAD(&chip->pcm_list);
++	INIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);
++	INIT_LIST_HEAD(&hda->list);
++	init_completion(&hda->probe_wait);
++
++	chip->get_position[0] = chip->get_position[1] = azx_get_pos_lpib;
++
++	chip->snoop = false;
++	chip->single_cmd = single_cmd;
++	azx_bus(chip)->codec_mask = chip->codec_probe_mask = 0xf;
++
++	if (bdl_pos_adj[dev] < 0) {
++		switch (chip->driver_type) {
++		case AZX_DRIVER_LS7A:
++			bdl_pos_adj[dev] = 1;
++			break;
++		default:
++			bdl_pos_adj[dev] = 32;
++			break;
++		}
++	}
++	chip->bdl_pos_adj = bdl_pos_adj[dev];
++
++	err = azx_bus_init(chip, model[dev]);
++	if (err < 0) {
++		kfree(hda);
++		return err;
++	}
++
++	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
++	if (err < 0) {
++		dev_err(card->dev, "Error creating device [card]!\n");
++		azx_free(chip);
++		return err;
++	}
++
++	*rchip = chip;
++
++	return 0;
++}
++
++static int azx_first_init(struct azx *chip)
++{
++	int dev = chip->dev_index;
++	struct snd_card *card = chip->card;
++	struct hdac_bus *bus = azx_bus(chip);
++	int err;
++	unsigned short gcap;
++
++	bus->addr = pci_resource_start(chip->pci, 0);
++	bus->remap_addr = ioremap(bus->addr,
++			   pci_resource_end(chip->pci, 0) - pci_resource_start(chip->pci, 0) + 1);
++	if (bus->remap_addr == NULL) {
++		dev_err(card->dev, "ioremap error\n");
++		return -ENXIO;
++	}
++
++	chip->msi = 0;
++
++	if (azx_acquire_irq(chip, 0) < 0)
++		return -EBUSY;
++
++	synchronize_irq(bus->irq);
++
++	gcap = azx_readw(chip, GCAP);
++	dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
++
++	/* disable 64bit DMA address on some devices */
++	if (chip->driver_caps & AZX_DCAPS_NO_64BIT) {
++		dev_dbg(card->dev, "Disabling 64bit DMA\n");
++		gcap &= ~AZX_GCAP_64OK;
++	}
++
++	/* disable buffer size rounding to 128-byte multiples if supported */
++	if (align_buffer_size >= 0)
++		chip->align_buffer_size = !!align_buffer_size;
++	else {
++		if (chip->driver_caps & AZX_DCAPS_NO_ALIGN_BUFSIZE)
++			chip->align_buffer_size = 0;
++		else
++			chip->align_buffer_size = 1;
++	}
++
++	/* allow 64bit DMA address if supported by H/W */
++	if ((gcap & AZX_GCAP_64OK) && !dma_set_mask(chip->card->dev, DMA_BIT_MASK(64)))
++		dma_set_coherent_mask(chip->card->dev, DMA_BIT_MASK(64));
++	else {
++		dma_set_mask(chip->card->dev, DMA_BIT_MASK(32));
++		dma_set_coherent_mask(chip->card->dev, DMA_BIT_MASK(32));
++	}
++
++	/* read number of streams from GCAP register instead of using
++	 * hardcoded value
++	 */
++	chip->capture_streams = (gcap >> 8) & 0x0f;
++	chip->playback_streams = (gcap >> 12) & 0x0f;
++	if (!chip->playback_streams && !chip->capture_streams) {
++		/* gcap didn't give any info, switching to old method */
++		chip->capture_streams = LS7A_NUM_CAPTURE;
++		chip->playback_streams = LS7A_NUM_PLAYBACK;
++	}
++	chip->capture_index_offset = 0;
++	chip->playback_index_offset = chip->capture_streams;
++	chip->num_streams = chip->playback_streams + chip->capture_streams;
++
++	/* initialize streams */
++	err = azx_init_streams(chip);
++	if (err < 0)
++		return err;
++	chip->playback_streams = chip->capture_streams = 1; /* Loongson */
++
++	err = azx_alloc_stream_pages(chip);
++	if (err < 0)
++		return err;
++
++	/* initialize chip */
++	azx_init_chip(chip, (probe_only[dev] & 2) == 0);
++
++	/* codec detection */
++	if (!azx_bus(chip)->codec_mask) {
++		dev_err(card->dev, "no codecs found!\n");
++		return -ENODEV;
++	}
++
++	strcpy(card->driver, "HDA-Loongson");
++	strlcpy(card->shortname, driver_short_names[chip->driver_type],
++		sizeof(card->shortname));
++	snprintf(card->longname, sizeof(card->longname),
++		 "%s at 0x%lx irq %i",
++		 card->shortname, bus->addr, bus->irq);
++
++	return 0;
++}
++
++static const struct hda_controller_ops loongson_hda_ops = {
++	.position_check = azx_position_check,
++};
++
++/* number of codec slots for each chipset: 0 = default slots (i.e. 4) */
++static unsigned int azx_max_codecs[AZX_NUM_DRIVERS] = {};
++
++static int azx_probe_continue(struct azx *chip)
++{
++	struct hda_loongson *hda = container_of(chip, struct hda_loongson, chip);
++	int dev = chip->dev_index;
++	int err;
++	struct device *snddev = chip->card->dev;
++
++	hda->probe_continued = 1;
++
++	err = azx_first_init(chip);
++	if (err < 0)
++		goto out_free;
++
++#ifdef CONFIG_SND_HDA_INPUT_BEEP
++	chip->beep_mode = beep_mode[dev];
++#endif
++
++	/* create codec instances */
++	err = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);
++	if (err < 0)
++		goto out_free;
++
++	if ((probe_only[dev] & 1) == 0) {
++		err = azx_codec_configure(chip);
++		if (err < 0)
++			goto out_free;
++	}
++
++	err = snd_card_register(chip->card);
++	if (err < 0)
++		goto out_free;
++
++	chip->running = 1;
++	azx_add_card_list(chip);
++#ifdef CONFIG_PM
++	pm_runtime_forbid(snddev);
++	pm_runtime_set_active(snddev);
++#endif
++	snd_hda_set_power_save(&chip->bus, power_save * 1000);
++	if (azx_has_pm_runtime(chip))
++		pm_runtime_put_noidle(snddev);
++
++out_free:
++	complete_all(&hda->probe_wait);
++	return err;
++}
++
++static const struct pci_device_id azx_ids[] = {
++	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_HDA),
++	.driver_data = AZX_DRIVER_LS7A | AZX_DCAPS_LS2X_WORKAROUND},
++	{PCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_HDMI),
++	.driver_data = AZX_DRIVER_HDMI | AZX_DCAPS_LS2X_WORKAROUND},
++	{}
++};
++
++MODULE_DEVICE_TABLE(pci, azx_ids);
++
++static int azx_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)
++{
++	int ret;
++	bool probe_now;
++	static int dev;
++	struct snd_card *card;
++	struct azx *chip;
++	struct hda_loongson *hda;
++
++	/* Enable device in PCI config */
++	ret = pci_enable_device(pdev);
++	if (ret < 0) {
++		printk(KERN_ERR "Loongson HDA (%s): Cannot enable PCI device\n",
++		       pci_name(pdev));
++		goto out;
++	}
++
++	/* request the mem regions */
++	ret = pci_request_region(pdev, 0, "Loongson HDA");
++	if (ret < 0) {
++		printk( KERN_ERR "Loongson HDA (%s): cannot request region 0.\n",
++			pci_name(pdev));
++		goto out;
++	}
++
++	if (dev >= SNDRV_CARDS)
++		return -ENODEV;
++	if (!enable[dev]) {
++		dev++;
++		return -ENOENT;
++	}
++
++	ret = snd_card_new(&pdev->dev, index[dev], id[dev], THIS_MODULE,
++			   0, &card);
++	if (ret < 0) {
++		dev_err(&pdev->dev, "Error creating card!\n");
++		return ret;
++	}
++
++	ret = azx_create(card, pdev, NULL, dev, pid->driver_data, &chip);
++	if (ret < 0)
++		goto out_free;
++	card->private_data = chip;
++	hda = container_of(chip, struct hda_loongson, chip);
++
++	dev_set_drvdata(&pdev->dev, card);
++
++	probe_now = !chip->disabled;
++
++	if (probe_now) {
++		ret = azx_probe_continue(chip);
++		if (ret < 0)
++			goto out_free;
++	}
++
++	dev++;
++	if (chip->disabled)
++		complete_all(&hda->probe_wait);
++	return 0;
++
++out_free:
++	snd_card_free(card);
++out:
++	return ret;
++}
++
++static void azx_pci_remove(struct pci_dev *pdev)
++{
++	snd_card_free(dev_get_drvdata(&pdev->dev));
++}
++
++static void azx_pci_shutdown(struct pci_dev *pdev)
++{
++	struct snd_card *card = dev_get_drvdata(&pdev->dev);
++	struct azx *chip;
++
++	if (!card)
++		return;
++	chip = card->private_data;
++	if (chip && chip->running)
++		azx_stop_chip(chip);
++}
++
++/* pci_driver definition */
++static struct pci_driver azx_pci_driver = {
++	.name = "loongson-audio",
++	.id_table = azx_ids,
++	.probe = azx_pci_probe,
++	.remove = azx_pci_remove,
++	.shutdown = azx_pci_shutdown,
++	.driver.pm = AZX_PM_OPS,
++};
++
++static int __init alsa_card_azx_init(void)
++{
++	int ret;
++
++	ret = pci_register_driver(&azx_pci_driver);
++	if (ret)
++		pr_err("hda azx pci driver register\n");
++
++	return ret;
++}
++
++static void __exit alsa_card_azx_exit(void)
++{
++	pci_unregister_driver(&azx_pci_driver);
++}
++
++module_init(alsa_card_azx_init)
++module_exit(alsa_card_azx_exit)
+Index: linux-6.4~rc7/sound/pci/hda/patch_hdmi.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/patch_hdmi.c
++++ linux-6.4~rc7/sound/pci/hda/patch_hdmi.c
+@@ -3203,6 +3203,13 @@ static int patch_i915_cpt_hdmi(struct hd
+ 	return parse_intel_hdmi(codec);
+ }
+ 
++/* Loongson LS7A2000 */
++static int patch_ls7a_hdmi(struct hda_codec *codec)
++{
++	codec->bus->core.needs_damn_long_delay = 1;
++	return patch_generic_hdmi(codec);
++}
++
+ /*
+  * Shared non-generic implementations
+  */
+@@ -4505,6 +4512,7 @@ static int patch_gf_hdmi(struct hda_code
+  * patch entries
+  */
+ static const struct hda_device_id snd_hda_id_hdmi[] = {
++HDA_CODEC_ENTRY(0x00147a47, "Loongson HDMI",	patch_ls7a_hdmi),
+ HDA_CODEC_ENTRY(0x1002793c, "RS600 HDMI",	patch_atihdmi),
+ HDA_CODEC_ENTRY(0x10027919, "RS600 HDMI",	patch_atihdmi),
+ HDA_CODEC_ENTRY(0x1002791a, "RS690/780 HDMI",	patch_atihdmi),
+Index: linux-6.4~rc7/sound/pci/hda/patch_realtek.c
+===================================================================
+--- linux-6.4~rc7.orig/sound/pci/hda/patch_realtek.c
++++ linux-6.4~rc7/sound/pci/hda/patch_realtek.c
+@@ -27,6 +27,7 @@
+ #include "hda_jack.h"
+ #include "hda_generic.h"
+ #include "hda_component.h"
++#include "hda_controller.h"
+ 
+ /* keep halting ALC5505 DSP, for power saving */
+ #define HALT_REALTEK_ALC5505
+@@ -348,6 +349,13 @@ static void alc_fixup_micmute_led(struct
+ 		snd_hda_gen_add_micmute_led_cdev(codec, NULL);
+ }
+ 
++int has_loongson_workaround(struct hda_codec *codec)
++{
++	struct azx *chip = bus_to_azx(&codec->bus->core);
++
++	return chip->driver_caps & AZX_DCAPS_LS2X_WORKAROUND;
++}
++
+ /*
+  * Fix hardware PLL issue
+  * On some codecs, the analog PLL gating control must be off while
+@@ -689,10 +697,10 @@ static int alc_auto_parse_customize_defi
+ 		goto do_sku;
+ 	}
+ 
+-	if (!codec->bus->pci)
++	if (!codec->bus->pci && !has_loongson_workaround(codec))
+ 		return -1;
+ 	ass = codec->core.subsystem_id & 0xffff;
+-	if (ass != codec->bus->pci->subsystem_device && (ass & 1))
++	if (codec->bus->pci && ass != codec->bus->pci->subsystem_device && (ass & 1))
+ 		goto do_sku;
+ 
+ 	nid = 0x1d;
diff -uNr a/debian/patches/loongarch/9004-LoongArch-support-LBT.patch b/debian/patches/loongarch/9004-LoongArch-support-LBT.patch
--- a/debian/patches/loongarch/9004-LoongArch-support-LBT.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9004-LoongArch-support-LBT.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,1312 @@
+Description: <short summary of the patch>
+ TODO: Put a short summary on the line above and replace this paragraph
+ with a longer explanation of this change. Complete the meta-information
+ with other relevant fields (see below for details). To make it easier, the
+ information below has been extracted from the changelog. Adjust it or drop
+ it.
+ .
+ linux (6.4~rc7-1~exp5) experimental; urgency=medium
+ .
+   * loong64 enable USB_HID USB_KBD USB_MOUSE
+   * loong64 enable XHCI EHCI OHCI UHCI
+Author: root <root@debian-loongarch>
+
+---
+The information above should follow the Patch Tagging Guidelines, please
+checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
+are templates for supplementary fields that you might want to add:
+
+Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
+Bug: <upstream-bugtracker-url>
+Bug-Debian: https://bugs.debian.org/<bugnumber>
+Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
+Forwarded: (no|not-needed|<patch-forwarded-url>)
+Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
+Reviewed-By: <name and email of someone who approved/reviewed the patch>
+Last-Update: 2023-06-25
+
+--- linux-6.4~rc7.orig/arch/loongarch/Kconfig
++++ linux-6.4~rc7/arch/loongarch/Kconfig
+@@ -527,6 +527,15 @@ config CPU_HAS_LASX
+ 
+ 	  If unsure, say Y.
+ 
++config CPU_HAS_LBT
++	bool "Support for Loongson Binary Translation"
++	help
++	  Loongson Binary Translation (LBT) introduces 4 sketch registers (SCR0 to SCR3),
++	  x86/ARM eflags (eflags) and x87 fpu stack pointer (ftop).
++	  When this option is enabled, the kernel will support allocation and switching
++	  LBT related registers.
++	  If you want to use this feature or Loongson Architecture Translator (LAT), say Y.
++
+ config CPU_HAS_PREFETCH
+ 	bool
+ 	default y
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/asm-prototypes.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/asm-prototypes.h
+@@ -1,6 +1,7 @@
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #include <linux/uaccess.h>
+ #include <asm/fpu.h>
++#include <asm/lbt.h>
+ #include <asm/mmu_context.h>
+ #include <asm/page.h>
+ #include <asm/ftrace.h>
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/asmmacro.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/asmmacro.h
+@@ -117,6 +117,275 @@
+ 	.endif
+ 	.endm
+ 
++	.macro	parse_vr var vr
++	\var	= -1
++	.ifc	\vr, $vr0
++	\var	= 0
++	.endif
++	.ifc	\vr, $vr1
++	\var	= 1
++	.endif
++	.ifc	\vr, $vr2
++	\var	= 2
++	.endif
++	.ifc	\vr, $vr3
++	\var	= 3
++	.endif
++	.ifc	\vr, $vr4
++	\var	= 4
++	.endif
++	.ifc	\vr, $vr5
++	\var	= 5
++	.endif
++	.ifc	\vr, $vr6
++	\var	= 6
++	.endif
++	.ifc	\vr, $vr7
++	\var	= 7
++	.endif
++	.ifc	\vr, $vr8
++	\var	= 8
++	.endif
++	.ifc	\vr, $vr9
++	\var	= 9
++	.endif
++	.ifc	\vr, $vr10
++	\var	= 10
++	.endif
++	.ifc	\vr, $vr11
++	\var	= 11
++	.endif
++	.ifc	\vr, $vr12
++	\var	= 12
++	.endif
++	.ifc	\vr, $vr13
++	\var	= 13
++	.endif
++	.ifc	\vr, $vr14
++	\var	= 14
++	.endif
++	.ifc	\vr, $vr15
++	\var	= 15
++	.endif
++	.ifc	\vr, $vr16
++	\var	= 16
++	.endif
++	.ifc	\vr, $vr17
++	\var	= 17
++	.endif
++	.ifc	\vr, $vr18
++	\var	= 18
++	.endif
++	.ifc	\vr, $vr19
++	\var	= 19
++	.endif
++	.ifc	\vr, $vr20
++	\var	= 20
++	.endif
++	.ifc	\vr, $vr21
++	\var	= 21
++	.endif
++	.ifc	\vr, $vr22
++	\var	= 22
++	.endif
++	.ifc	\vr, $vr23
++	\var	= 23
++	.endif
++	.ifc	\vr, $vr24
++	\var	= 24
++	.endif
++	.ifc	\vr, $vr25
++	\var	= 25
++	.endif
++	.ifc	\vr, $vr26
++	\var	= 26
++	.endif
++	.ifc	\vr, $vr27
++	\var	= 27
++	.endif
++	.ifc	\vr, $vr28
++	\var	= 28
++	.endif
++	.ifc	\vr, $vr29
++	\var	= 29
++	.endif
++	.ifc	\vr, $vr30
++	\var	= 30
++	.endif
++	.ifc	\vr, $vr31
++	\var	= 31
++	.endif
++	.endm
++
++	.macro	parse_scr var r
++	\var	= -1
++	.ifc	\r, $scr0
++	\var	= 0
++	.endif
++	.ifc	\r, $scr1
++	\var	= 1
++	.endif
++	.ifc	\r, $scr2
++	\var	= 2
++	.endif
++	.ifc	\r, $scr3
++	\var	= 3
++	.endif
++	.iflt	\var
++	.error	"Unable to parse register name \r"
++	.endif
++	.endm
++
++	.macro	parse_xr var xr
++	\var	= -1
++	.ifc	\xr, $xr0
++	\var	= 0
++	.endif
++	.ifc	\xr, $xr1
++	\var	= 1
++	.endif
++	.ifc	\xr, $xr2
++	\var	= 2
++	.endif
++	.ifc	\xr, $xr3
++	\var	= 3
++	.endif
++	.ifc	\xr, $xr4
++	\var	= 4
++	.endif
++	.ifc	\xr, $xr5
++	\var	= 5
++	.endif
++	.ifc	\xr, $xr6
++	\var	= 6
++	.endif
++	.ifc	\xr, $xr7
++	\var	= 7
++	.endif
++	.ifc	\xr, $xr8
++	\var	= 8
++	.endif
++	.ifc	\xr, $xr9
++	\var	= 9
++	.endif
++	.ifc	\xr, $xr10
++	\var	= 10
++	.endif
++	.ifc	\xr, $xr11
++	\var	= 11
++	.endif
++	.ifc	\xr, $xr12
++	\var	= 12
++	.endif
++	.ifc	\xr, $xr13
++	\var	= 13
++	.endif
++	.ifc	\xr, $xr14
++	\var	= 14
++	.endif
++	.ifc	\xr, $xr15
++	\var	= 15
++	.endif
++	.ifc	\xr, $xr16
++	\var	= 16
++	.endif
++	.ifc	\xr, $xr17
++	\var	= 17
++	.endif
++	.ifc	\xr, $xr18
++	\var	= 18
++	.endif
++	.ifc	\xr, $xr19
++	\var	= 19
++	.endif
++	.ifc	\xr, $xr20
++	\var	= 20
++	.endif
++	.ifc	\xr, $xr21
++	\var	= 21
++	.endif
++	.ifc	\xr, $xr22
++	\var	= 22
++	.endif
++	.ifc	\xr, $xr23
++	\var	= 23
++	.endif
++	.ifc	\xr, $xr24
++	\var	= 24
++	.endif
++	.ifc	\xr, $xr25
++	\var	= 25
++	.endif
++	.ifc	\xr, $xr26
++	\var	= 26
++	.endif
++	.ifc	\xr, $xr27
++	\var	= 27
++	.endif
++	.ifc	\xr, $xr28
++	\var	= 28
++	.endif
++	.ifc	\xr, $xr29
++	\var	= 29
++	.endif
++	.ifc	\xr, $xr30
++	\var	= 30
++	.endif
++	.ifc	\xr, $xr31
++	\var	= 31
++	.endif
++	.iflt	\var
++	.error	"Unable to parse register name \r"
++	.endif
++	.endm
++
++	/* FTOP <- ptr(imm) */
++	.macro	x86mttop ptr
++	.word ((0x70 << 8) | (\ptr << 5))
++	.endm
++
++	/* GPR <- FTOP */
++	.macro	x86mftop gpr
++	parse_r __gpr, \gpr
++	.word ((0x3a0 << 5) | __gpr)
++	.endm
++
++	/* open top mode */
++	.macro	x86settm
++	.word (0x8008)
++	.endm
++
++	/* close top mode */
++	.macro	x86clrtm
++	.word (0x8028)
++	.endm
++
++	/* FLAGS <- GPR & mask(imm) */
++	.macro	x86mtflag gpr mask
++	parse_r __gpr, \gpr
++	.word ((0x17 << 18) | (\mask << 10) | (1 << 5) | __gpr)
++	.endm
++
++	/* GPR <- FLAGS & mask(imm) */
++	.macro	x86mfflag gpr mask
++	parse_r __gpr, \gpr
++	.word ((0x17 << 18) | (\mask << 10) | (0 << 5) | __gpr)
++	.endm
++
++	/* SCR <- GPR */
++	.macro	movgr2scr scr gpr
++	parse_scr __scr, \scr
++	parse_r   __gpr, \gpr
++	.word ((0x2 << 10) | (__gpr << 5) | __scr)
++	.endm
++
++	/* GPR <- SCR */
++	.macro	movscr2gr gpr scr
++	parse_r	  __gpr, \gpr
++	parse_scr __scr, \scr
++	.word ((0x3 << 10) | (__scr << 5) | __gpr)
++	.endm
++
+ 	.macro	cpu_save_nonscratch thread
+ 	stptr.d	s0, \thread, THREAD_REG23
+ 	stptr.d	s1, \thread, THREAD_REG24
+@@ -149,11 +418,52 @@
+ 	.macro fpu_save_csr thread tmp
+ 	movfcsr2gr	\tmp, fcsr0
+ 	stptr.w	\tmp, \thread, THREAD_FCSR
+-	.endm
+-
+-	.macro fpu_restore_csr thread tmp
+-	ldptr.w	\tmp, \thread, THREAD_FCSR
+-	movgr2fcsr	fcsr0, \tmp
++#ifdef CONFIG_CPU_HAS_LBT
++	andi	\tmp, \tmp, FPU_CSR_TM
++	beqz	\tmp, 1f
++	/* save ftop */
++	x86mftop	\tmp
++	st.b	\tmp, \thread, THREAD_FTOP
++	/* Since LSX/LASX is not controlled by TM, we need
++	 * to turn off TM before each context switch to ensure
++	 * that the order of FPR in memory is independent of TM.
++	 */
++	x86clrtm
++	1:
++#endif
++	.endm
++
++	.macro fpu_restore_csr thread tmp0 tmp1
++	ldptr.w	\tmp0, \thread, THREAD_FCSR
++	movgr2fcsr	fcsr0, \tmp0
++#ifdef CONFIG_CPU_HAS_LBT
++	/* TM bit is always 0 if LBT not supported */
++	andi	\tmp0, \tmp0, FPU_CSR_TM
++	beqz	\tmp0, 1f
++	/* restore ftop */
++	ld.b	\tmp0, \thread, THREAD_FTOP
++	andi	\tmp0, \tmp0, 0x7
++	la.pcrel	\tmp1, 2f
++	alsl.d	\tmp1, \tmp0, \tmp1, 3
++	jr	\tmp1
++	2:
++	x86mttop	0
++	b	1f
++	x86mttop	1
++	b	1f
++	x86mttop	2
++	b	1f
++	x86mttop	3
++	b	1f
++	x86mttop	4
++	b	1f
++	x86mttop	5
++	b	1f
++	x86mttop	6
++	b	1f
++	x86mttop	7
++	1 :
++#endif
+ 	.endm
+ 
+ 	.macro fpu_save_cc thread tmp0 tmp1
+@@ -353,7 +663,7 @@
+ 	.macro	lsx_restore_all	thread tmp0 tmp1
+ 	lsx_restore_data	\thread, \tmp0
+ 	fpu_restore_cc		\thread, \tmp0, \tmp1
+-	fpu_restore_csr		\thread, \tmp0
++	fpu_restore_csr		\thread, \tmp0, \tmp1
+ 	.endm
+ 
+ 	.macro	lsx_save_upper vd base tmp off
+@@ -563,7 +873,7 @@
+ 	.macro	lasx_restore_all thread tmp0 tmp1
+ 	lasx_restore_data	\thread, \tmp0
+ 	fpu_restore_cc		\thread, \tmp0, \tmp1
+-	fpu_restore_csr		\thread, \tmp0
++	fpu_restore_csr		\thread, \tmp0, \tmp1
+ 	.endm
+ 
+ 	.macro	lasx_save_upper xd base tmp off
+@@ -663,6 +973,38 @@
+ 	lasx_init_upper	$xr31 \tmp
+ 	.endm
+ 
++	.macro	lbt_save_scr thread tmp
++	movscr2gr	\tmp, $scr0
++	stptr.d	\tmp, \thread, THREAD_SCR0
++	movscr2gr	\tmp, $scr1
++	stptr.d	\tmp, \thread, THREAD_SCR1
++	movscr2gr	\tmp, $scr2
++	stptr.d	\tmp, \thread, THREAD_SCR2
++	movscr2gr	\tmp, $scr3
++	stptr.d	\tmp, \thread, THREAD_SCR3
++	.endm
++
++	.macro	lbt_restore_scr thread tmp
++	ldptr.d	\tmp, \thread, THREAD_SCR0
++	movgr2scr	$scr0, \tmp
++	ldptr.d	\tmp, \thread, THREAD_SCR1
++	movgr2scr	$scr1, \tmp
++	ldptr.d	\tmp, \thread, THREAD_SCR2
++	movgr2scr	$scr2, \tmp
++	ldptr.d	\tmp, \thread, THREAD_SCR3
++	movgr2scr	$scr3, \tmp
++	.endm
++
++	.macro	lbt_save_eflag thread tmp
++	x86mfflag	\tmp, 0x3f
++	stptr.d	\tmp, \thread, THREAD_EFLAGS
++	.endm
++
++	.macro	lbt_restore_eflag thread tmp
++	ldptr.d	\tmp, \thread, THREAD_EFLAGS
++	x86mtflag	\tmp, 0x3f
++	.endm
++
+ .macro not dst src
+ 	nor	\dst, \src, zero
+ .endm
+--- /dev/null
++++ linux-6.4~rc7/arch/loongarch/include/asm/lbt.h
+@@ -0,0 +1,115 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Author: Qi Hu <huqi@loongson.cn>
++ * Copyright (C) 2020-2022 Loongson Technology Corporation Limited
++ */
++#ifndef _ASM_LBT_H
++#define _ASM_LBT_H
++
++#include <linux/sched.h>
++#include <linux/sched/task_stack.h>
++#include <linux/ptrace.h>
++#include <linux/thread_info.h>
++#include <linux/bitops.h>
++
++#include <asm/cpu.h>
++#include <asm/cpu-features.h>
++#include <asm/current.h>
++#include <asm/loongarch.h>
++#include <asm/processor.h>
++#include <asm/ptrace.h>
++
++extern void _save_lbt(struct task_struct *);
++extern void _restore_lbt(struct task_struct *);
++
++static inline int is_lbt_enabled(void)
++{
++	if (!cpu_has_lbt)
++		return 0;
++	return (csr_read32(LOONGARCH_CSR_EUEN) & CSR_EUEN_LBTEN) != 0;
++}
++
++static inline int is_lbt_owner(void)
++{
++	return test_thread_flag(TIF_USEDLBT);
++}
++
++#ifdef CONFIG_CPU_HAS_LBT
++
++static inline void enable_lbt(void)
++{
++	if (cpu_has_lbt)
++		csr_xchg32(CSR_EUEN_LBTEN, CSR_EUEN_LBTEN, LOONGARCH_CSR_EUEN);
++}
++
++static inline void disable_lbt(void)
++{
++	if (cpu_has_lbt)
++		csr_xchg32(0, CSR_EUEN_LBTEN, LOONGARCH_CSR_EUEN);
++}
++
++
++static inline void __own_lbt(void)
++{
++	enable_lbt();
++	set_thread_flag(TIF_USEDLBT);
++	KSTK_EUEN(current) |= CSR_EUEN_LBTEN;
++}
++
++static inline void own_lbt_inatomic(int restore)
++{
++	if (cpu_has_lbt && !is_lbt_owner()) {
++		__own_lbt();
++		if (restore)
++			_restore_lbt(current);
++	}
++}
++
++static inline void own_lbt(int restore)
++{
++	preempt_disable();
++	own_lbt_inatomic(restore);
++	preempt_enable();
++}
++
++static inline void lose_lbt_inatomic(int save, struct task_struct *tsk)
++{
++	if (cpu_has_lbt && is_lbt_owner()) {
++		if (save)
++			_save_lbt(tsk);
++
++		disable_lbt();
++		clear_tsk_thread_flag(tsk, TIF_USEDLBT);
++	}
++	KSTK_EUEN(tsk) &= ~(CSR_EUEN_LBTEN);
++}
++
++static inline void lose_lbt(int save)
++{
++	preempt_disable();
++	lose_lbt_inatomic(save, current);
++	preempt_enable();
++}
++
++static inline void init_lbt(void)
++{
++	__own_lbt();
++	set_thread_flag(TIF_LBT_CTX_LIVE);
++}
++#else
++static inline void enable_lbt(void) {}
++static inline void disable_lbt(void) {}
++static inline void own_lbt_inatomic(int restore) {}
++static inline void lose_lbt_inatomic(int save, struct task_struct *tsk) {}
++static inline void own_lbt(int restore) {}
++static inline void lose_lbt(int save) {}
++#endif
++
++static inline int thread_lbt_context_live(void)
++{
++	if (!cpu_has_lbt)
++		return 0;
++	return test_thread_flag(TIF_LBT_CTX_LIVE);
++}
++
++#endif /* _ASM_LBT_H */
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/loongarch.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/loongarch.h
+@@ -1487,6 +1487,10 @@ __BUILD_CSR_OP(tlbidx)
+ #define FPU_CSR_RU	0x200	/* towards +Infinity */
+ #define FPU_CSR_RD	0x300	/* towards -Infinity */
+ 
++/* Bit 6 of FPU Status Register specify the LBT TOP simulation mode */
++#define FPU_CSR_TM_SHIFT	0x6
++#define FPU_CSR_TM		(_ULCAST_(1) << FPU_CSR_TM_SHIFT)
++
+ #define read_fcsr(source)	\
+ ({	\
+ 	unsigned int __res;	\
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/processor.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/processor.h
+@@ -81,6 +81,7 @@ BUILD_FPR_ACCESS(64)
+ 
+ struct loongarch_fpu {
+ 	unsigned int	fcsr;
++	uint8_t		ftop;
+ 	uint64_t	fcc;	/* 8x8 */
+ 	union fpureg	fpr[NUM_FPU_REGS];
+ };
+@@ -175,6 +176,7 @@ struct thread_struct {
+ 	 */							\
+ 	.fpu			= {				\
+ 		.fcsr		= 0,				\
++		.ftop		= 0,				\
+ 		.fcc		= 0,				\
+ 		.fpr		= {{{0,},},},			\
+ 	},							\
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/switch_to.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/switch_to.h
+@@ -7,6 +7,7 @@
+ 
+ #include <asm/cpu-features.h>
+ #include <asm/fpu.h>
++#include <asm/lbt.h>
+ 
+ struct task_struct;
+ 
+@@ -34,6 +35,7 @@ extern asmlinkage struct task_struct *__
+ #define switch_to(prev, next, last)						\
+ do {										\
+ 	lose_fpu_inatomic(1, prev);						\
++	lose_lbt_inatomic(1, prev);						\
+ 	hw_breakpoint_thread_switch(next);					\
+ 	(last) = __switch_to(prev, next, task_thread_info(next),		\
+ 		 __builtin_return_address(0), __builtin_frame_address(0));	\
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/thread_info.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/thread_info.h
+@@ -84,6 +84,8 @@ register unsigned long current_stack_poi
+ #define TIF_SINGLESTEP		16	/* Single Step */
+ #define TIF_LSX_CTX_LIVE	17	/* LSX context must be preserved */
+ #define TIF_LASX_CTX_LIVE	18	/* LASX context must be preserved */
++#define TIF_USEDLBT             19      /* LBT was used by this task this quantum (SMP) */
++#define TIF_LBT_CTX_LIVE	20	/* LBT context must be preserved */
+
+ #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+ #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+@@ -101,6 +102,8 @@ register unsigned long current_stack_poi
+ #define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
+ #define _TIF_LSX_CTX_LIVE	(1<<TIF_LSX_CTX_LIVE)
+ #define _TIF_LASX_CTX_LIVE	(1<<TIF_LASX_CTX_LIVE)
++#define _TIF_USEDLBT            (1<<TIF_USEDLBT)
++#define _TIF_LBT_CTX_LIVE       (1<<TIF_LBT_CTX_LIVE)
+ 
+ #endif /* __KERNEL__ */
+ #endif /* _ASM_THREAD_INFO_H */
+--- linux-6.4~rc7.orig/arch/loongarch/include/uapi/asm/ptrace.h
++++ linux-6.4~rc7/arch/loongarch/include/uapi/asm/ptrace.h
+@@ -44,6 +44,12 @@ struct user_fp_state {
+ 	uint64_t fpr[32];
+ 	uint64_t fcc;
+ 	uint32_t fcsr;
++	uint8_t  ftop;
++};
++
++struct user_lbt_state {
++	uint64_t scr[4];
++	uint32_t eflags;
+ };
+ 
+ struct user_lsx_state {
+--- linux-6.4~rc7.orig/arch/loongarch/include/uapi/asm/sigcontext.h
++++ linux-6.4~rc7/arch/loongarch/include/uapi/asm/sigcontext.h
+@@ -59,4 +59,13 @@ struct lasx_context {
+ 	__u32	fcsr;
+ };
+ 
++/* LBT context */
++#define LBT_CTX_MAGIC		0x4c425401
++#define LBT_CTX_ALIGN		8
++struct lbt_context {
++	__u64	regs[4];
++	__u32	eflags;
++};
++
++
+ #endif /* _UAPI_ASM_SIGCONTEXT_H */
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/Makefile
++++ linux-6.4~rc7/arch/loongarch/kernel/Makefile
+@@ -38,6 +38,8 @@ KASAN_SANITIZE_traps.o := n
+ KASAN_SANITIZE_smp.o := n
+ KASAN_SANITIZE_vdso.o := n
+ 
++obj-$(CONFIG_CPU_HAS_LBT)	+= lbt.o
++
+ obj-$(CONFIG_MODULES)		+= module.o module-sections.o
+ obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
+ 
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/asm-offsets.c
++++ linux-6.4~rc7/arch/loongarch/kernel/asm-offsets.c
+@@ -171,6 +171,7 @@ void output_thread_fpu_defines(void)
+ 
+ 	OFFSET(THREAD_FCSR, loongarch_fpu, fcsr);
+ 	OFFSET(THREAD_FCC,  loongarch_fpu, fcc);
++	OFFSET(THREAD_FTOP, loongarch_fpu, ftop);
+ 	BLANK();
+ }
+ 
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/cpu-probe.c
++++ linux-6.4~rc7/arch/loongarch/kernel/cpu-probe.c
+@@ -144,6 +144,20 @@ static void cpu_probe_common(struct cpui
+ 		c->options |= LOONGARCH_CPU_LVZ;
+ 		elf_hwcap |= HWCAP_LOONGARCH_LVZ;
+ 	}
++#ifdef CONFIG_CPU_HAS_LBT
++	if (config & CPUCFG2_X86BT) {
++		c->options |= LOONGARCH_CPU_LBT_X86;
++		elf_hwcap |= HWCAP_LOONGARCH_LBT_X86;
++	}
++	if (config & CPUCFG2_ARMBT) {
++		c->options |= LOONGARCH_CPU_LBT_ARM;
++		elf_hwcap |= HWCAP_LOONGARCH_LBT_ARM;
++	}
++	if (config & CPUCFG2_MIPSBT) {
++		c->options |= LOONGARCH_CPU_LBT_MIPS;
++		elf_hwcap |= HWCAP_LOONGARCH_LBT_MIPS;
++	}
++#endif
+ 
+ 	config = read_cpucfg(LOONGARCH_CPUCFG6);
+ 	if (config & CPUCFG6_PMP)
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/fpu.S
++++ linux-6.4~rc7/arch/loongarch/kernel/fpu.S
+@@ -138,6 +138,13 @@
+ 	.macro sc_save_fcsr base, tmp0
+ 	movfcsr2gr	\tmp0, fcsr0
+ 	EX	st.w	\tmp0, \base, 0
++#if defined(CONFIG_CPU_HAS_LBT)
++	/* TM bit is always 0 if LBT not supported */
++	andi		\tmp0, \tmp0, FPU_CSR_TM
++	beqz		\tmp0, 1f
++	x86clrtm
++	1:
++#endif
+ 	.endm
+ 
+ 	.macro sc_restore_fcsr base, tmp0
+@@ -309,7 +316,7 @@ EXPORT_SYMBOL(_save_fp)
+  */
+ SYM_FUNC_START(_restore_fp)
+ 	fpu_restore_double	a0 t1		# clobbers t1
+-	fpu_restore_csr		a0 t1
++	fpu_restore_csr		a0 t1 t2
+ 	fpu_restore_cc		a0 t1 t2	# clobbers t1, t2
+ 	jr			ra
+ SYM_FUNC_END(_restore_fp)
+--- /dev/null
++++ linux-6.4~rc7/arch/loongarch/kernel/lbt.S
+@@ -0,0 +1,125 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Author: Lu Zeng <zenglu@loongson.cn>
++ *         Pei Huang <huangpei@loongson.cn>
++ *         Huacai Chen <chenhuacai@loongson.cn>
++ *
++ * Copyright (C) 2020-2022 Loongson Technology Corporation Limited
++ */
++#include <asm/asm.h>
++#include <asm/asmmacro.h>
++#include <asm/asm-extable.h>
++#include <asm/asm-offsets.h>
++#include <asm/errno.h>
++#include <asm/export.h>
++#include <asm/fpregdef.h>
++#include <asm/loongarch.h>
++#include <asm/regdef.h>
++
++#if defined(CONFIG_CPU_HAS_LBT)
++
++#define SCR_REG_WIDTH 8
++
++	.macro	EX insn, reg, src, offs
++.ex\@:	\insn	\reg, \src, \offs
++	_asm_extable .ex\@, lbt_fault
++	.endm
++
++	.macro	sc_save_scr base, tmp0
++	movscr2gr	\tmp0, $scr0
++	EX	st.d	\tmp0, \base, (0 * SCR_REG_WIDTH)
++	movscr2gr	\tmp0, $scr1
++	EX	st.d	\tmp0, \base, (1 * SCR_REG_WIDTH)
++	movscr2gr	\tmp0, $scr2
++	EX	st.d	\tmp0, \base, (2 * SCR_REG_WIDTH)
++	movscr2gr	\tmp0, $scr3
++	EX	st.d	\tmp0, \base, (3 * SCR_REG_WIDTH)
++	.endm
++
++	.macro	sc_restore_scr base, tmp0
++	EX	ld.d	\tmp0, \base, (0 * SCR_REG_WIDTH)
++	movgr2scr	$scr0, \tmp0
++	EX	ld.d	\tmp0, \base, (1 * SCR_REG_WIDTH)
++	movgr2scr	$scr1, \tmp0
++	EX	ld.d	\tmp0, \base, (2 * SCR_REG_WIDTH)
++	movgr2scr	$scr2, \tmp0
++	EX	ld.d	\tmp0, \base, (3 * SCR_REG_WIDTH)
++	movgr2scr	$scr3, \tmp0
++	.endm
++
++	.macro	sc_save_eflag base, tmp0
++	x86mfflag	\tmp0, 0x3f
++	EX st.w		\tmp0, \base, 0
++	.endm
++
++	.macro	sc_restore_eflag base, tmp0
++	EX ld.w		\tmp0, \base, 0
++	x86mtflag	\tmp0, 0x3f
++	.endm
++
++/*
++ * Save a thread's lbt context.
++ */
++SYM_FUNC_START(_save_lbt)
++	lbt_save_scr	a0 t1		# clobbers t1
++	lbt_save_eflag	a0 t1		# clobbers t1
++	jr	ra
++SYM_FUNC_END(_save_lbt)
++EXPORT_SYMBOL(_save_lbt)
++
++/*
++ * Restore a thread's lbt context.
++ */
++SYM_FUNC_START(_restore_lbt)
++	lbt_restore_eflag	a0 t1	# clobbers t1
++	lbt_restore_scr		a0 t1	# clobbers t1
++	jr	ra
++SYM_FUNC_END(_restore_lbt)
++EXPORT_SYMBOL(_restore_lbt)
++
++/*
++ * a0: scr
++ * a1: eflag
++ */
++SYM_FUNC_START(_save_lbt_context)
++	sc_save_scr		a0 t1
++	sc_save_eflag	a1 t1
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_save_lbt_context)
++
++/*
++ * a0: scr
++ * a1: eflag
++ */
++SYM_FUNC_START(_restore_lbt_context)
++	sc_restore_scr		a0 t1
++	sc_restore_eflag	a1 t1
++	li.w	a0, 0					# success
++	jr	ra
++SYM_FUNC_END(_restore_lbt_context)
++
++SYM_FUNC_START(lbt_fault)
++	li.w	a0, -EFAULT				# failure
++	jr	ra
++SYM_FUNC_END(lbt_fault)
++
++#else
++
++/*
++ * Save a thread's lbt context.
++ */
++SYM_FUNC_START(_save_lbt)
++	jr	ra
++SYM_FUNC_END(_save_lbt)
++EXPORT_SYMBOL(_save_lbt)
++
++/*
++ * Restore a thread's lbt context.
++ */
++SYM_FUNC_START(_restore_lbt)
++	jr	ra
++SYM_FUNC_END(_restore_lbt)
++EXPORT_SYMBOL(_restore_lbt)
++
++#endif
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/process.c
++++ linux-6.4~rc7/arch/loongarch/kernel/process.c
+@@ -38,6 +38,7 @@
+ #include <asm/cpu.h>
+ #include <asm/elf.h>
+ #include <asm/fpu.h>
++#include <asm/lbt.h>
+ #include <asm/io.h>
+ #include <asm/irq.h>
+ #include <asm/irq_regs.h>
+@@ -89,9 +90,11 @@ void start_thread(struct pt_regs *regs,
+ 	euen = regs->csr_euen & ~(CSR_EUEN_FPEN);
+ 	regs->csr_euen = euen;
+ 	lose_fpu(0);
++	lose_lbt(0);
+ 
+ 	clear_thread_flag(TIF_LSX_CTX_LIVE);
+ 	clear_thread_flag(TIF_LASX_CTX_LIVE);
++	clear_thread_flag(TIF_LBT_CTX_LIVE);
+ 	clear_used_math();
+ 	regs->csr_era = pc;
+ 	regs->regs[3] = sp;
+@@ -196,8 +199,10 @@ out:
+ 	ptrace_hw_copy_thread(p);
+ 	clear_tsk_thread_flag(p, TIF_USEDFPU);
+ 	clear_tsk_thread_flag(p, TIF_USEDSIMD);
++	clear_tsk_thread_flag(p, TIF_USEDLBT);
+ 	clear_tsk_thread_flag(p, TIF_LSX_CTX_LIVE);
+ 	clear_tsk_thread_flag(p, TIF_LASX_CTX_LIVE);
++	clear_tsk_thread_flag(p, TIF_LBT_CTX_LIVE);
+ 
+ 	return 0;
+ }
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/ptrace.c
++++ linux-6.4~rc7/arch/loongarch/kernel/ptrace.c
+@@ -38,6 +38,7 @@
+ #include <asm/cpu.h>
+ #include <asm/cpu-info.h>
+ #include <asm/fpu.h>
++#include <asm/lbt.h>
+ #include <asm/loongarch.h>
+ #include <asm/page.h>
+ #include <asm/pgtable.h>
+@@ -154,6 +155,9 @@ static int fpr_get(struct task_struct *t
+ 
+ 	r = membuf_write(&to, &target->thread.fpu.fcc, sizeof(target->thread.fpu.fcc));
+ 	r = membuf_write(&to, &target->thread.fpu.fcsr, sizeof(target->thread.fpu.fcsr));
++#ifdef CONFIG_CPU_HAS_LBT
++	r = membuf_write(&to, &target->thread.fpu.ftop, sizeof(target->thread.fpu.ftop));
++#endif
+ 
+ 	return r;
+ }
+@@ -198,6 +202,9 @@ static int fpr_set(struct task_struct *t
+ {
+ 	const int fcc_start = NUM_FPU_REGS * sizeof(elf_fpreg_t);
+ 	const int fcsr_start = fcc_start + sizeof(u64);
++#ifdef CONFIG_CPU_HAS_LBT
++	const int ftop_start = fcsr_start + sizeof(u32);
++#endif
+ 	int err;
+ 
+ 	BUG_ON(count % sizeof(elf_fpreg_t));
+@@ -219,6 +226,11 @@ static int fpr_set(struct task_struct *t
+ 	err |= user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+ 				  &target->thread.fpu.fcsr, fcsr_start,
+ 				  fcsr_start + sizeof(u32));
++#ifdef CONFIG_CPU_HAS_LBT
++	err |= user_regset_copyin(&pos, &count, &kbuf, &ubuf,
++				  &target->thread.fpu.ftop, ftop_start,
++				  ftop_start + sizeof(u8));
++#endif
+ 
+ 	return err;
+ }
+@@ -716,7 +728,43 @@ static int hw_break_set(struct task_stru
+ 
+ 	return 0;
+ }
++#endif
++
++#ifdef CONFIG_CPU_HAS_LBT
++static int lbt_get(struct task_struct *target,
++		   const struct user_regset *regset,
++		   struct membuf to)
++{
++	int r;
++
++	r = membuf_write(&to, &target->thread.scr0, sizeof(target->thread.scr0));
++	r = membuf_write(&to, &target->thread.scr1, sizeof(target->thread.scr1));
++	r = membuf_write(&to, &target->thread.scr2, sizeof(target->thread.scr2));
++	r = membuf_write(&to, &target->thread.scr3, sizeof(target->thread.scr3));
++
++	r = membuf_write(&to, &target->thread.eflags, sizeof(target->thread.eflags));
++
++	return r;
++}
++
++static int lbt_set(struct task_struct *target,
++		   const struct user_regset *regset,
++		   unsigned int pos, unsigned int count,
++		   const void *kbuf, const void __user *ubuf)
++{
++	const int eflags_start = 4 * sizeof(target->thread.scr0);
++	const int eflags_end = eflags_start + sizeof(u32);
++	int err = 0;
++
++	err |= user_regset_copyin(&pos, &count, &kbuf, &ubuf,
++				  &target->thread.scr0,
++				  0, 4 * sizeof(target->thread.scr0));
++	err |= user_regset_copyin(&pos, &count, &kbuf, &ubuf,
++				  &target->thread.eflags,
++				  eflags_start, eflags_end);
+ 
++	return err;
++}
+ #endif
+ 
+ struct pt_regs_offset {
+@@ -798,6 +846,9 @@ enum loongarch_regset {
+ #ifdef CONFIG_CPU_HAS_LASX
+ 	REGSET_LASX,
+ #endif
++#ifdef CONFIG_CPU_HAS_LBT
++	REGSET_LBT,
++#endif
+ #ifdef CONFIG_HAVE_HW_BREAKPOINT
+ 	REGSET_HW_BREAK,
+ 	REGSET_HW_WATCH,
+@@ -849,6 +900,16 @@ static const struct user_regset loongarc
+ 		.set		= simd_set,
+ 	},
+ #endif
++#ifdef CONFIG_CPU_HAS_LBT
++	[REGSET_LBT] = {
++		.core_note_type	= NT_LOONGARCH_LBT,
++		.n		= 5,
++		.size		= sizeof(u64),
++		.align		= sizeof(u64),
++		.regset_get = lbt_get,
++		.set		= lbt_set,
++	},
++#endif
+ #ifdef CONFIG_HAVE_HW_BREAKPOINT
+ 	[REGSET_HW_BREAK] = {
+ 		.core_note_type = NT_LOONGARCH_HW_BREAK,
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/signal.c
++++ linux-6.4~rc7/arch/loongarch/kernel/signal.c
+@@ -32,6 +32,7 @@
+ #include <asm/cacheflush.h>
+ #include <asm/cpu-features.h>
+ #include <asm/fpu.h>
++#include <asm/lbt.h>
+ #include <asm/ucontext.h>
+ #include <asm/vdso.h>
+ 
+@@ -44,6 +45,9 @@
+ /* Make sure we will not lose FPU ownership */
+ #define lock_fpu_owner()	({ preempt_disable(); pagefault_disable(); })
+ #define unlock_fpu_owner()	({ pagefault_enable(); preempt_enable(); })
++/* Make sure we will not lose LBT ownership */
++#define lock_lbt_owner()	lock_fpu_owner()
++#define unlock_lbt_owner()	unlock_fpu_owner()
+ 
+ /* Assembly functions to move context to/from the FPU */
+ extern asmlinkage int
+@@ -58,6 +62,14 @@ extern asmlinkage int
+ _save_lasx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
+ extern asmlinkage int
+ _restore_lasx_context(void __user *fpregs, void __user *fcc, void __user *fcsr);
++extern asmlinkage int _save_lsx_all_upper(void __user *buf);
++extern asmlinkage int _restore_lsx_all_upper(void __user *buf);
++#ifdef CONFIG_CPU_HAS_LBT
++extern asmlinkage int
++_save_lbt_context(void __user *regs, void __user *eflags);
++extern asmlinkage int
++_restore_lbt_context(void __user *regs, void __user *eflags);
++#endif
+ 
+ struct rt_sigframe {
+ 	struct siginfo rs_info;
+@@ -75,6 +87,7 @@ struct extctx_layout {
+ 	struct _ctx_layout fpu;
+ 	struct _ctx_layout lsx;
+ 	struct _ctx_layout lasx;
++	struct _ctx_layout lbt;
+ 	struct _ctx_layout end;
+ };
+ 
+@@ -125,6 +138,40 @@ static int copy_fpu_from_sigcontext(stru
+ 	return err;
+ }
+ 
++#ifdef CONFIG_CPU_HAS_LBT
++static int copy_lbt_to_sigcontext(struct lbt_context __user *ctx)
++{
++	int err = 0;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint32_t __user *eflags	= &ctx->eflags;
++
++	err |= __put_user(current->thread.scr0, &regs[0]);
++	err |= __put_user(current->thread.scr1, &regs[1]);
++	err |= __put_user(current->thread.scr2, &regs[2]);
++	err |= __put_user(current->thread.scr3, &regs[3]);
++
++	err |= __put_user(current->thread.eflags, eflags);
++
++	return err;
++}
++
++static int copy_lbt_from_sigcontext(struct lbt_context __user *ctx)
++{
++	int err = 0;
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint32_t __user *eflags	= &ctx->eflags;
++
++	err |= __get_user(current->thread.scr0, &regs[0]);
++	err |= __get_user(current->thread.scr1, &regs[1]);
++	err |= __get_user(current->thread.scr2, &regs[2]);
++	err |= __get_user(current->thread.scr3, &regs[3]);
++
++	err |= __get_user(current->thread.eflags, eflags);
++
++	return err;
++}
++#endif
++
+ static int copy_lsx_to_sigcontext(struct lsx_context __user *ctx)
+ {
+ 	int i;
+@@ -292,6 +339,27 @@ static int fcsr_pending(unsigned int __u
+ }
+ 
+ /*
++ * Wrappers for the assembly _{save,restore}_lbt_context functions.
++ */
++#ifdef CONFIG_CPU_HAS_LBT
++static int save_hw_lbt_context(struct lbt_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint32_t __user *eflags	= &ctx->eflags;
++
++	return _save_lbt_context(regs, eflags);
++}
++
++static int restore_hw_lbt_context(struct lbt_context __user *ctx)
++{
++	uint64_t __user *regs	= (uint64_t *)&ctx->regs;
++	uint32_t __user *eflags	= &ctx->eflags;
++
++	return _restore_lbt_context(regs, eflags);
++}
++#endif
++
++/*
+  * Helper routines
+  */
+ static int protected_save_fpu_context(struct extctx_layout *extctx)
+@@ -519,6 +587,71 @@ static int protected_restore_lasx_contex
+ 	return err ?: sig;
+ }
+ 
++#ifdef CONFIG_CPU_HAS_LBT
++static int protected_save_lbt_context(struct extctx_layout *extctx)
++{
++	int err = 0;
++	struct sctx_info __user *info = extctx->lbt.addr;
++	struct lbt_context __user *lbt_ctx =
++		(struct lbt_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lbt_ctx->regs;
++	uint32_t __user *eflags	= &lbt_ctx->eflags;
++
++	while (1) {
++		lock_lbt_owner();
++		if (is_lbt_owner())
++			err |= save_hw_lbt_context(lbt_ctx);
++		else
++			err |= copy_lbt_to_sigcontext(lbt_ctx);
++		unlock_lbt_owner();
++
++		err |= __put_user(LBT_CTX_MAGIC, &info->magic);
++		err |= __put_user(extctx->lbt.size, &info->size);
++
++		if (likely(!err))
++			break;
++		/* Touch the LBT context and try again */
++		err = __put_user(0, &regs[0]) |
++			__put_user(0, eflags);
++
++		if (err)
++			return err;
++	}
++
++	return err;
++}
++
++static int protected_restore_lbt_context(struct extctx_layout *extctx)
++{
++	int err = 0, tmp __maybe_unused;
++	struct sctx_info __user *info = extctx->lbt.addr;
++	struct lbt_context __user *lbt_ctx =
++		(struct lbt_context *)get_ctx_through_ctxinfo(info);
++	uint64_t __user *regs	= (uint64_t *)&lbt_ctx->regs;
++	uint32_t __user *eflags	= &lbt_ctx->eflags;
++
++	while (1) {
++		lock_lbt_owner();
++		if (is_lbt_owner())
++			err |= restore_hw_lbt_context(lbt_ctx);
++		else
++			err |= copy_lbt_from_sigcontext(lbt_ctx);
++		unlock_lbt_owner();
++
++		if (likely(!err))
++			break;
++		/* Touch the LBT context and try again */
++		err = __get_user(tmp, &regs[0]) |
++			__get_user(tmp, eflags);
++
++		if (err)
++			return err;
++	}
++
++	return err;
++}
++#endif
++
+ static int setup_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc,
+ 			    struct extctx_layout *extctx)
+ {
+@@ -539,6 +672,11 @@ static int setup_sigcontext(struct pt_re
+ 	else if (extctx->fpu.addr)
+ 		err |= protected_save_fpu_context(extctx);
+ 
++#ifdef CONFIG_CPU_HAS_LBT
++	if (extctx->lbt.addr)
++		err |= protected_save_lbt_context(extctx);
++#endif
++
+ 	/* Set the "end" magic */
+ 	info = (struct sctx_info *)extctx->end.addr;
+ 	err |= __put_user(0, &info->magic);
+@@ -584,6 +722,13 @@ static int parse_extcontext(struct sigco
+ 			extctx->lasx.addr = info;
+ 			break;
+ 
++		case LBT_CTX_MAGIC:
++			if (size < (sizeof(struct sctx_info) +
++				    sizeof(struct lbt_context)))
++				goto invalid;
++			extctx->lbt.addr = info;
++			break;
++
+ 		default:
+ 			goto invalid;
+ 		}
+@@ -636,6 +781,11 @@ static int restore_sigcontext(struct pt_
+ 	else if (extctx.fpu.addr)
+ 		err |= protected_restore_fpu_context(&extctx);
+ 
++#ifdef CONFIG_CPU_HAS_LBT
++	if (extctx.lbt.addr)
++		err |= protected_restore_lbt_context(&extctx);
++#endif
++
+ bad:
+ 	return err;
+ }
+@@ -700,6 +850,11 @@ static unsigned long setup_extcontext(st
+ 			  sizeof(struct fpu_context), FPU_CTX_ALIGN, new_sp);
+ 	}
+ 
++	if (cpu_has_lbt && thread_lbt_context_live()) {
++		new_sp = extframe_alloc(extctx, &extctx->lbt,
++			  sizeof(struct lbt_context), LBT_CTX_ALIGN, new_sp);
++	}
++
+ 	return new_sp;
+ }
+ 
+--- linux-6.4~rc7.orig/arch/loongarch/kernel/traps.c
++++ linux-6.4~rc7/arch/loongarch/kernel/traps.c
+@@ -37,6 +37,7 @@
+ #include <asm/cpu.h>
+ #include <asm/fpu.h>
+ #include <asm/inst.h>
++#include <asm/lbt.h>
+ #include <asm/loongarch.h>
+ #include <asm/mmu_context.h>
+ #include <asm/pgtable.h>
+@@ -904,6 +905,24 @@ static void init_restore_lasx(void)
+ 	BUG_ON(!is_lasx_enabled());
+ }
+ 
++#ifdef CONFIG_CPU_HAS_LBT
++static void init_restore_lbt(void)
++{
++	if (!thread_lbt_context_live()) {
++		/* First time lbt context user */
++		init_lbt();
++	} else {
++		/* Enable and restore */
++		if (!is_lbt_owner())
++			own_lbt_inatomic(1);
++	}
++
++	BUG_ON(!is_lbt_enabled());
++}
++#else
++static void init_restore_lbt(void) {}
++#endif
++
+ asmlinkage void noinstr do_fpu(struct pt_regs *regs)
+ {
+ 	irqentry_state_t state = irqentry_enter(regs);
+@@ -968,10 +987,30 @@ asmlinkage void noinstr do_lbt(struct pt
+ {
+ 	irqentry_state_t state = irqentry_enter(regs);
+ 
+-	local_irq_enable();
+-	force_sig(SIGILL);
+-	local_irq_disable();
++	/*
++	 * BTE (Binary Translation Exception) can be triggered
++	 * during FP save/restore if TM (Top Mode) is open, which
++	 * may cause irq_enable during 'switch_to'. To avoid this
++	 * situation (including the user using 'MOVGR2GCSR' to
++	 * open the TM, which will not trigger the BTE), we need
++	 * to check PRMD first.
++	 */
++	if (likely(regs->csr_prmd & CSR_PRMD_PIE))
++		local_irq_enable();
++
++	if (!cpu_has_lbt) {
++		force_sig(SIGILL);
++		goto out;
++	}
++
++	BUG_ON(is_lbt_enabled());
+ 
++	preempt_disable();
++	init_restore_lbt();
++	preempt_enable();
++
++out:
++	local_irq_disable();
+ 	irqentry_exit(regs, state);
+ }
+ 
diff -uNr a/debian/patches/loongarch/9005-LoongArch-support-cpufreq.patch b/debian/patches/loongarch/9005-LoongArch-support-cpufreq.patch
--- a/debian/patches/loongarch/9005-LoongArch-support-cpufreq.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9005-LoongArch-support-cpufreq.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,478 @@
+Index: linux-6.4~rc7/arch/loongarch/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/Kconfig
++++ linux-6.4~rc7/arch/loongarch/Kconfig
+@@ -670,4 +670,10 @@ source "drivers/acpi/Kconfig"
+ 
+ endmenu
+ 
++menu "CPU Power Management"
++
++source "drivers/cpufreq/Kconfig"
++
++endmenu
++
+ source "drivers/firmware/Kconfig"
+Index: linux-6.4~rc7/arch/loongarch/include/asm/loongarch.h
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/include/asm/loongarch.h
++++ linux-6.4~rc7/arch/loongarch/include/asm/loongarch.h
+@@ -1116,11 +1116,14 @@ static __always_inline void iocsr_write6
+ #define LOONGARCH_IOCSR_NODECNT		0x408
+ 
+ #define LOONGARCH_IOCSR_MISC_FUNC	0x420
++#define  IOCSR_MISC_FUNC_SOFT_INT	BIT_ULL(10)
+ #define  IOCSR_MISC_FUNC_TIMER_RESET	BIT_ULL(21)
+ #define  IOCSR_MISC_FUNC_EXT_IOI_EN	BIT_ULL(48)
+ 
+ #define LOONGARCH_IOCSR_CPUTEMP		0x428
+ 
++#define LOONGARCH_IOCSR_SMCMBX		0x51c
++
+ /* PerCore CSR, only accessible by local cores */
+ #define LOONGARCH_IOCSR_IPI_STATUS	0x1000
+ #define LOONGARCH_IOCSR_IPI_EN		0x1004
+Index: linux-6.4~rc7/arch/loongarch/power/platform.c
+===================================================================
+--- linux-6.4~rc7.orig/arch/loongarch/power/platform.c
++++ linux-6.4~rc7/arch/loongarch/power/platform.c
+@@ -34,6 +34,18 @@ void enable_pci_wakeup(void)
+ 		acpi_write_bit_register(ACPI_BITREG_PCIEXP_WAKE_DISABLE, 0);
+ }
+ 
++static struct platform_device loongson3_cpufreq_device = {
++	.name = "loongson3_cpufreq",
++	.id = -1,
++};
++
++static int __init loongson_cpufreq_init(void)
++{
++	return platform_device_register(&loongson3_cpufreq_device);
++}
++
++arch_initcall(loongson_cpufreq_init);
++
+ static int __init loongson3_acpi_suspend_init(void)
+ {
+ #ifdef CONFIG_ACPI
+Index: linux-6.4~rc7/drivers/cpufreq/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/drivers/cpufreq/Kconfig
++++ linux-6.4~rc7/drivers/cpufreq/Kconfig
+@@ -272,6 +272,18 @@ config LOONGSON2_CPUFREQ
+ 	  If in doubt, say N.
+ endif
+ 
++if LOONGARCH
++config LOONGSON3_CPUFREQ
++	tristate "Loongson3 CPUFreq Driver"
++	help
++	  This option adds a CPUFreq driver for Loongson processors which
++	  support software configurable cpu frequency.
++
++	  Loongson-3 family processors support this feature.
++
++	  If in doubt, say N.
++endif
++
+ if SPARC64
+ config SPARC_US3_CPUFREQ
+ 	tristate "UltraSPARC-III CPU Frequency driver"
+Index: linux-6.4~rc7/drivers/cpufreq/Makefile
+===================================================================
+--- linux-6.4~rc7.orig/drivers/cpufreq/Makefile
++++ linux-6.4~rc7/drivers/cpufreq/Makefile
+@@ -104,6 +104,7 @@ obj-$(CONFIG_POWERNV_CPUFREQ)		+= powern
+ obj-$(CONFIG_BMIPS_CPUFREQ)		+= bmips-cpufreq.o
+ obj-$(CONFIG_IA64_ACPI_CPUFREQ)		+= ia64-acpi-cpufreq.o
+ obj-$(CONFIG_LOONGSON2_CPUFREQ)		+= loongson2_cpufreq.o
++obj-$(CONFIG_LOONGSON3_CPUFREQ)		+= loongson3_cpufreq.o
+ obj-$(CONFIG_SH_CPU_FREQ)		+= sh-cpufreq.o
+ obj-$(CONFIG_SPARC_US2E_CPUFREQ)	+= sparc-us2e-cpufreq.o
+ obj-$(CONFIG_SPARC_US3_CPUFREQ)		+= sparc-us3-cpufreq.o
+Index: linux-6.4~rc7/drivers/cpufreq/loongson3_cpufreq.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/cpufreq/loongson3_cpufreq.c
+@@ -0,0 +1,381 @@
++/*
++ * CPUFreq driver for the loongson-3 processors
++ *
++ * All revisions of Loongson-3 processor support this feature.
++ *
++ * Author: Huacai Chen <chenhuacai@loongson.cn>
++ * Copyright (C) 2020-2022 Loongson Technology Corporation Limited
++ */
++#include <linux/delay.h>
++#include <linux/module.h>
++#include <linux/cpufreq.h>
++#include <linux/platform_device.h>
++
++#include <asm/idle.h>
++#include <asm/loongarch.h>
++#include <asm/loongson.h>
++
++struct smc_message {
++	union {
++		u32 value;
++		struct {
++			u32 arg : 24;
++			u8  cmd : 7; /* Return 0x7f if command failed */
++			u8  complete : 1;
++		};
++	};
++};
++
++/* Belows are commands in cmd registers */
++
++#define CMD_GET_VERSION			0x1
++/* Interface Version, input none, return version */
++
++/* Features */
++#define CMD_GET_FEATURES		0x2
++/* Get features that SMC implemented, input index, output feature flags */
++#define CMD_GET_ENABLED_FEATURES	0x3
++/* Get currently enabled features, input index, output feature flags */
++#define CMD_SET_ENABLED_FEATURES	0x4
++/* Set features enabled state, input index and flags, output sucessfully enabled flags */
++struct feature_args {
++	u16 flags : 16;
++	u8  index : 8;
++};
++
++#define FEATURE_INDEX_GENERAL	0x0
++#define FEATURE_INDEX_ADVANCED	0x1
++
++/* General Feature Flags */
++#define FEATURE_FREQ_SCALE	BIT(0)
++#define FEATURE_VOLTAGE_SCALE	BIT(1)
++#define FEATURE_BOOST		BIT(2) /* Enable Boost means set PLL from 1.6GHz to 2GHz */
++#define FEATURE_SENSORS		BIT(3) /* Sensors mounted on EC */
++#define FEATURE_FAN_CONTROL	BIT(4)
++
++/* Freqscale Related */
++#define CMD_SET_DVFS_POLICY	0x5
++/* Input CPUNum, output frequency, in MHz? */
++#define CMD_GET_FREQ_LEVELS	0x6
++/* Input none, output levels */
++struct freq_level_args {
++	u8 min_level : 8;
++	u8 max_normal_level : 8;
++	u8 max_boost_level : 8;
++};
++
++#define CMD_GET_FREQ_INFO	0x7
++/* Input index and info, output info */
++#define CMD_SET_FREQ_INFO	0x8
++/* Input index and info, output none */
++
++#define FREQ_INFO_INDEX_LEVEL_FREQ	0x0 /* Freq in MHz? For each shadow level */
++#define FREQ_INFO_INDEX_CORE_FREQ	0x1 /* Freq in MHz? Current frequency of each core.*/
++struct freq_info_args {
++	u16 info : 16;
++	u8  index : 8;
++};
++
++#define CMD_SET_CPU_LEVEL	0x9
++/* Input cpu mask and level, output none */
++/*
++ * Note: This command return as completed only means
++ * SMC already knows the request, does not means the
++ * CPU freqency have changed. SMC should ensure constant
++ * counter frequency unchanged.
++ */
++struct freq_level_setting_args {
++	u16 cpumask : 16;
++	u8  level : 8;
++};
++
++/* TEMP Sensors */
++#define CMD_GET_SENSOR_NUM	0x10
++/* Input none, output Number of sensors in u4 */
++
++#define CMD_GET_SENSOR_STATUS	0x11
++/* Input sensor_id and info_type, output info */
++#define SENSOR_INFO_TYPE_TEMP	0x0
++#define SENSOR_INFO_TYPE_VOLTAGE	0x1
++#define SENSOR_INFO_TYPE_NAMESTR1	0x2
++#define SENSOR_INFO_TYPE_NAMESTR2	0x3
++#define SENSOR_INFO_TYPE_NAMESTR3	0x4
++#define SENSOR_INFO_TYPE_NAMESTR4	0x5
++#define SENSOR_INFO_TYPE_FLAGS		0xf
++#define SENSOR_FLAG_TEMP	BIT(0)
++#define SENSOR_FLAG_VOLTAGE	BIT(1)
++struct sensor_info_args {
++	union {
++		u16 val;
++		u16 volt; /* Voltage, in mV */
++		s16 temp; /* Signed 16bit, in Celsius */
++	};
++	u8 info_type : 4;
++	u8 sensor_id : 4;
++};
++
++/* Fan Control */
++#define CMD_GET_FAN_NUM		0x12
++/* Input none, output Number of fans in u4 */
++
++#define CMD_GET_FAN_INFO	0x13
++/* Input sensor_id and info_type, output info */
++#define CMD_SET_FAN_INFO	0x14
++/* Input sensor_id andinfo_type info, output none */
++#define FAN_INFO_TYPE_INDEX_RPM	0x0 /* Return RPM, can not set */
++#define FAN_INFO_TYPE_LEVEL	0x1 /* PWM Level, 0~255, only set with manual mode */
++#define FAN_INFO_TYPE_FLAGS	0xf /* Determine Mode */
++#define FAN_INFO_TYPE_NAMESTR1	0x2
++#define FAN_INFO_TYPE_NAMESTR2	0x3
++#define FAN_INFO_TYPE_NAMESTR3	0x4
++#define FAN_INFO_TYPE_NAMESTR4	0x5
++#define FAN_FLAG_AUTO	BIT(0)
++#define FAN_FLAG_MANUAL	BIT(1)
++
++struct fan_info_args {
++	u16 val;
++	u8  info_type : 4;
++	u8  fan_id : 4;
++};
++
++static inline int do_service_request(u8 cmd, void *arg)
++{
++	int retries;
++	struct smc_message msg;
++
++	msg.value = iocsr_read32(LOONGARCH_IOCSR_SMCMBX);
++	if (!msg.complete)
++		return -1;
++
++	msg.cmd = cmd;
++	msg.arg = *(u32 *)arg;
++	msg.complete = 0x0;
++
++	iocsr_write32(msg.value, LOONGARCH_IOCSR_SMCMBX);
++	iocsr_write32(iocsr_read32(LOONGARCH_IOCSR_MISC_FUNC) | IOCSR_MISC_FUNC_SOFT_INT,
++			LOONGARCH_IOCSR_MISC_FUNC);
++
++	for (retries = 0; retries < 10000; retries++) {
++		msg.value = iocsr_read32(LOONGARCH_IOCSR_SMCMBX);
++		if (msg.complete)
++			break;
++
++		usleep_range(4, 5);
++	}
++
++	if (!msg.complete || msg.cmd == 0x7f)
++		return -1;
++
++	*(u32 *)arg = msg.arg;
++
++	return 0;
++}
++
++static int boost_supported = 0;
++static struct mutex cpufreq_mutex[MAX_PACKAGES];
++
++enum freq {
++	FREQ_LEV0, /* Reserved */
++	FREQ_LEV1, FREQ_LEV2, FREQ_LEV3, FREQ_LEV4,
++	FREQ_LEV5, FREQ_LEV6, FREQ_LEV7, FREQ_LEV8,
++	FREQ_LEV9, FREQ_LEV10, FREQ_LEV11, FREQ_LEV12,
++	FREQ_LEV13, FREQ_LEV14, FREQ_LEV15, FREQ_LEV16,
++	FREQ_RESV
++};
++
++/* For Loongson-3A5000, support boost */
++static struct cpufreq_frequency_table loongson3_cpufreq_table[] = {
++	{0, FREQ_LEV0, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV1, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV2, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV3, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV4, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV5, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV6, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV7, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV8, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV9, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV10, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV11, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV12, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV13, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV14, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV15, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_LEV16, CPUFREQ_ENTRY_INVALID},
++	{0, FREQ_RESV, CPUFREQ_TABLE_END},
++};
++
++static unsigned int loongson3_cpufreq_get(unsigned int cpu)
++{
++	struct freq_info_args args;
++
++	args.info = cpu;
++	args.index = FREQ_INFO_INDEX_CORE_FREQ;
++	do_service_request(CMD_GET_FREQ_INFO, &args);
++
++	return (args.info * 1000);
++}
++
++static int loongson3_cpufreq_set(struct cpufreq_policy *policy, int freq_level)
++{
++	uint32_t core_id = cpu_data[policy->cpu].core;
++	struct freq_level_setting_args args;
++
++	args.level = freq_level;
++	args.cpumask = 1 << core_id;
++	do_service_request(CMD_SET_CPU_LEVEL, &args);
++
++	return 0;
++}
++
++/*
++ * Here we notify other drivers of the proposed change and the final change.
++ */
++static int loongson3_cpufreq_target(struct cpufreq_policy *policy,
++				     unsigned int index)
++{
++	unsigned int cpu = policy->cpu;
++	unsigned int package = cpu_data[cpu].package;
++
++	if (!cpu_online(cpu))
++		return -ENODEV;
++
++	/* setting the cpu frequency */
++	mutex_lock(&cpufreq_mutex[package]);
++	loongson3_cpufreq_set(policy, index);
++	mutex_unlock(&cpufreq_mutex[package]);
++
++	return 0;
++}
++
++static int loongson3_cpufreq_cpu_init(struct cpufreq_policy *policy)
++{
++	if (!cpu_online(policy->cpu))
++		return -ENODEV;
++
++	policy->cur = loongson3_cpufreq_get(policy->cpu);
++
++	policy->cpuinfo.transition_latency = 5000;
++	policy->freq_table = loongson3_cpufreq_table;
++
++	return 0;
++}
++
++static int loongson3_cpufreq_exit(struct cpufreq_policy *policy)
++{
++	return 0;
++}
++
++static struct cpufreq_driver loongson3_cpufreq_driver = {
++	.name = "loongson3",
++	.flags = CPUFREQ_CONST_LOOPS,
++	.init = loongson3_cpufreq_cpu_init,
++	.verify = cpufreq_generic_frequency_table_verify,
++	.target_index = loongson3_cpufreq_target,
++	.get = loongson3_cpufreq_get,
++	.exit = loongson3_cpufreq_exit,
++	.attr = cpufreq_generic_attr,
++};
++
++static struct platform_device_id cpufreq_id_table[] = {
++	{ "loongson3_cpufreq", },
++	{ /* sentinel */ }
++};
++
++MODULE_DEVICE_TABLE(platform, cpufreq_id_table);
++
++static struct platform_driver cpufreq_driver = {
++	.driver = {
++		.name = "loongson3_cpufreq",
++		.owner = THIS_MODULE,
++	},
++	.id_table = cpufreq_id_table,
++};
++
++static int configure_cpufreq_info(void)
++{
++	int i, r, max_level;
++	struct feature_args args1;
++	struct freq_level_args args2;
++	struct freq_info_args args3;
++
++	if (!cpu_has_csr)
++		return -EPERM;
++
++	args1.index = FEATURE_INDEX_GENERAL;
++	r = do_service_request(CMD_GET_FEATURES, &args1);
++	if (r < 0)
++		return -EPERM;
++
++	if (!(args1.flags & FEATURE_FREQ_SCALE))
++		return -EPERM;
++
++	if (args1.flags & FEATURE_BOOST)
++		boost_supported = 1;
++
++	r = do_service_request(CMD_SET_ENABLED_FEATURES, &args1);
++	if (r < 0)
++		return -EPERM;
++
++	r = do_service_request(CMD_GET_FREQ_LEVELS, &args2);
++	if (r < 0)
++		return -EPERM;
++
++	if (boost_supported)
++		max_level = args2.max_boost_level;
++	else
++		max_level = args2.max_normal_level;
++
++	for (i = args2.min_level; i <= max_level; i++) {
++		args3.info = i;
++		args3.index = FREQ_INFO_INDEX_LEVEL_FREQ;
++		do_service_request(CMD_GET_FREQ_INFO, &args3);
++		loongson3_cpufreq_table[i].frequency = args3.info * 1000;
++		if (i > args2.max_normal_level)
++			loongson3_cpufreq_table[i].flags = CPUFREQ_BOOST_FREQ;
++	}
++
++	return 0;
++}
++
++static int __init cpufreq_init(void)
++{
++	int i, ret;
++
++	ret = platform_driver_register(&cpufreq_driver);
++	if (ret)
++		goto err;
++
++	ret = configure_cpufreq_info();
++	if (ret)
++		goto err;
++
++	for (i = 0; i < MAX_PACKAGES; i++)
++		mutex_init(&cpufreq_mutex[i]);
++
++	ret = cpufreq_register_driver(&loongson3_cpufreq_driver);
++
++	if (boost_supported)
++		cpufreq_enable_boost_support();
++
++	pr_info("cpufreq: Loongson-3 CPU frequency driver.\n");
++
++	return ret;
++
++err:
++	platform_driver_unregister(&cpufreq_driver);
++	return ret;
++}
++
++static void __exit cpufreq_exit(void)
++{
++	cpufreq_unregister_driver(&loongson3_cpufreq_driver);
++	platform_driver_unregister(&cpufreq_driver);
++}
++
++module_init(cpufreq_init);
++module_exit(cpufreq_exit);
++
++MODULE_AUTHOR("Huacai Chen <chenhuacaic@loongson.cn>");
++MODULE_DESCRIPTION("CPUFreq driver for Loongson-3 processors");
++MODULE_LICENSE("GPL");
diff -uNr a/debian/patches/loongarch/9006-LoongArch-support-cpu-HWMON.patch b/debian/patches/loongarch/9006-LoongArch-support-cpu-HWMON.patch
--- a/debian/patches/loongarch/9006-LoongArch-support-cpu-HWMON.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/debian/patches/loongarch/9006-LoongArch-support-cpu-HWMON.patch	2023-06-29 16:16:11.284252570 +0800
@@ -0,0 +1,225 @@
+Index: linux-6.4~rc7/drivers/platform/loongarch/Kconfig
+===================================================================
+--- linux-6.4~rc7.orig/drivers/platform/loongarch/Kconfig
++++ linux-6.4~rc7/drivers/platform/loongarch/Kconfig
+@@ -16,6 +16,14 @@ menuconfig LOONGARCH_PLATFORM_DEVICES
+ 
+ if LOONGARCH_PLATFORM_DEVICES
+ 
++config CPU_HWMON
++	bool "Loongson CPU HWMon Driver"
++	depends on MACH_LOONGSON64
++	select HWMON
++	default y
++	help
++	  Loongson-3A/3B/3C CPU HWMon (temperature sensor) driver.
++
+ config LOONGSON_LAPTOP
+ 	tristate "Generic Loongson-3 Laptop Driver"
+ 	depends on ACPI
+Index: linux-6.4~rc7/drivers/platform/loongarch/Makefile
+===================================================================
+--- linux-6.4~rc7.orig/drivers/platform/loongarch/Makefile
++++ linux-6.4~rc7/drivers/platform/loongarch/Makefile
+@@ -1 +1,2 @@
++obj-$(CONFIG_CPU_HWMON) += cpu_hwmon.o
+ obj-$(CONFIG_LOONGSON_LAPTOP) += loongson-laptop.o
+Index: linux-6.4~rc7/drivers/platform/loongarch/cpu_hwmon.c
+===================================================================
+--- /dev/null
++++ linux-6.4~rc7/drivers/platform/loongarch/cpu_hwmon.c
+@@ -0,0 +1,194 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (C) 2022 Loongson Technology Corporation Limited
++ */
++#include <linux/module.h>
++#include <linux/reboot.h>
++#include <linux/jiffies.h>
++#include <linux/hwmon.h>
++#include <linux/hwmon-sysfs.h>
++
++#include <asm/loongson.h>
++
++static int nr_packages;
++static struct device *cpu_hwmon_dev;
++
++static int loongson3_cpu_temp(int cpu)
++{
++	u32 reg;
++
++	reg = iocsr_read32(LOONGARCH_IOCSR_CPUTEMP) & 0xff;
++
++	return (int)((s8)reg) * 1000;
++}
++
++static ssize_t cpu_temp_label(struct device *dev,
++			struct device_attribute *attr, char *buf)
++{
++	int id = (to_sensor_dev_attr(attr))->index - 1;
++	return sprintf(buf, "CPU %d Temperature\n", id);
++}
++
++static ssize_t get_cpu_temp(struct device *dev,
++			struct device_attribute *attr, char *buf)
++{
++	int id = (to_sensor_dev_attr(attr))->index - 1;
++	int value = loongson3_cpu_temp(id);
++	return sprintf(buf, "%d\n", value);
++}
++
++static SENSOR_DEVICE_ATTR(temp1_input, 0444, get_cpu_temp, NULL, 1);
++static SENSOR_DEVICE_ATTR(temp1_label, 0444, cpu_temp_label, NULL, 1);
++static SENSOR_DEVICE_ATTR(temp2_input, 0444, get_cpu_temp, NULL, 2);
++static SENSOR_DEVICE_ATTR(temp2_label, 0444, cpu_temp_label, NULL, 2);
++static SENSOR_DEVICE_ATTR(temp3_input, 0444, get_cpu_temp, NULL, 3);
++static SENSOR_DEVICE_ATTR(temp3_label, 0444, cpu_temp_label, NULL, 3);
++static SENSOR_DEVICE_ATTR(temp4_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp4_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp5_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp5_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp6_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp6_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp7_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp7_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp8_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp8_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp9_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp9_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp10_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp10_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp11_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp11_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp12_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp12_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp13_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp13_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp14_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp14_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp15_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp15_label, 0444, cpu_temp_label, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp16_input, 0444, get_cpu_temp, NULL, 4);
++static SENSOR_DEVICE_ATTR(temp16_label, 0444, cpu_temp_label, NULL, 4);
++
++static struct attribute *cpu_hwmon_attributes[] = {
++	&sensor_dev_attr_temp1_input.dev_attr.attr,
++	&sensor_dev_attr_temp1_label.dev_attr.attr,
++	&sensor_dev_attr_temp2_input.dev_attr.attr,
++	&sensor_dev_attr_temp2_label.dev_attr.attr,
++	&sensor_dev_attr_temp3_input.dev_attr.attr,
++	&sensor_dev_attr_temp3_label.dev_attr.attr,
++	&sensor_dev_attr_temp4_input.dev_attr.attr,
++	&sensor_dev_attr_temp4_label.dev_attr.attr,
++	&sensor_dev_attr_temp5_input.dev_attr.attr,
++	&sensor_dev_attr_temp5_label.dev_attr.attr,
++	&sensor_dev_attr_temp6_input.dev_attr.attr,
++	&sensor_dev_attr_temp6_label.dev_attr.attr,
++	&sensor_dev_attr_temp7_input.dev_attr.attr,
++	&sensor_dev_attr_temp7_label.dev_attr.attr,
++	&sensor_dev_attr_temp8_input.dev_attr.attr,
++	&sensor_dev_attr_temp8_label.dev_attr.attr,
++	&sensor_dev_attr_temp9_input.dev_attr.attr,
++	&sensor_dev_attr_temp9_label.dev_attr.attr,
++	&sensor_dev_attr_temp10_input.dev_attr.attr,
++	&sensor_dev_attr_temp10_label.dev_attr.attr,
++	&sensor_dev_attr_temp11_input.dev_attr.attr,
++	&sensor_dev_attr_temp11_label.dev_attr.attr,
++	&sensor_dev_attr_temp12_input.dev_attr.attr,
++	&sensor_dev_attr_temp12_label.dev_attr.attr,
++	&sensor_dev_attr_temp13_input.dev_attr.attr,
++	&sensor_dev_attr_temp13_label.dev_attr.attr,
++	&sensor_dev_attr_temp14_input.dev_attr.attr,
++	&sensor_dev_attr_temp14_label.dev_attr.attr,
++	&sensor_dev_attr_temp15_input.dev_attr.attr,
++	&sensor_dev_attr_temp15_label.dev_attr.attr,
++	&sensor_dev_attr_temp16_input.dev_attr.attr,
++	&sensor_dev_attr_temp16_label.dev_attr.attr,
++	NULL
++};
++static umode_t cpu_hwmon_is_visible(struct kobject *kobj,
++				    struct attribute *attr, int i)
++{
++	int id = i / 2;
++
++	if (id < nr_packages)
++		return attr->mode;
++	return 0;
++}
++
++static struct attribute_group cpu_hwmon_group = {
++	.attrs = cpu_hwmon_attributes,
++	.is_visible = cpu_hwmon_is_visible,
++};
++
++static const struct attribute_group *cpu_hwmon_groups[] = {
++	&cpu_hwmon_group,
++	NULL
++};
++
++static int cpu_initial_threshold = 72000;
++static int cpu_thermal_threshold = 96000;
++module_param(cpu_thermal_threshold, int, 0644);
++MODULE_PARM_DESC(cpu_thermal_threshold, "cpu thermal threshold (96000 (default))");
++
++static struct delayed_work thermal_work;
++
++static void do_thermal_timer(struct work_struct *work)
++{
++	int i, value, temp_max = 0;
++
++	for (i=0; i<nr_packages; i++) {
++		value = loongson3_cpu_temp(i);
++		if (value > temp_max)
++			temp_max = value;
++	}
++
++	if (temp_max <= cpu_thermal_threshold)
++		schedule_delayed_work(&thermal_work, msecs_to_jiffies(5000));
++	else
++		orderly_poweroff(true);
++}
++
++static int __init loongson_hwmon_init(void)
++{
++	int i, value, temp_max = 0;
++
++	pr_info("Loongson Hwmon Enter...\n");
++
++	nr_packages = loongson_sysconf.nr_cpus /
++		loongson_sysconf.cores_per_package;
++
++	cpu_hwmon_dev = hwmon_device_register_with_groups(NULL, "cpu_hwmon",
++							  NULL, cpu_hwmon_groups);
++	if (IS_ERR(cpu_hwmon_dev)) {
++		pr_err("Hwmon register fail with %ld!\n", PTR_ERR(cpu_hwmon_dev));
++		return PTR_ERR(cpu_hwmon_dev);
++	}
++
++	for (i = 0; i < nr_packages; i++) {
++		value = loongson3_cpu_temp(i);
++		if (value > temp_max)
++			temp_max = value;
++	}
++
++	pr_info("Initial CPU temperature is %d (highest).\n", temp_max);
++	if (temp_max > cpu_initial_threshold)
++		cpu_thermal_threshold += temp_max - cpu_initial_threshold;
++
++	INIT_DEFERRABLE_WORK(&thermal_work, do_thermal_timer);
++	schedule_delayed_work(&thermal_work, msecs_to_jiffies(20000));
++
++	return 0;
++}
++
++static void __exit loongson_hwmon_exit(void)
++{
++	cancel_delayed_work_sync(&thermal_work);
++	hwmon_device_unregister(cpu_hwmon_dev);
++}
++
++module_init(loongson_hwmon_init);
++module_exit(loongson_hwmon_exit);
++
++MODULE_AUTHOR("Huacai Chen <chenhuacai@loongson.cn>");
++MODULE_DESCRIPTION("Loongson CPU Hwmon driver");
++MODULE_LICENSE("GPL");
diff -uNr a/debian/patches/series b/debian/patches/series
--- a/debian/patches/series	2023-06-19 23:29:52.000000000 +0800
+++ b/debian/patches/series	2023-06-29 16:16:11.284252570 +0800
@@ -123,3 +123,31 @@
 bugfix/powerpc/fbdev-offb-Update-expected-device-name.patch
 
 # ABI maintenance
+#
+# loongarch upstream
+loongarch/0001-LoongArch-Add-support-to-clone-a-time-namespace.patch
+loongarch/0002-LoongArch-Add-vector-extensions-support.patch
+loongarch/0003-LoongArch-Add-SMT-Simultaneous-Multi-Threading-suppo.patch
+loongarch/0004-LoongArch-Support-dbar-with-different-hints.patch
+loongarch/0005-LoongArch-Introduce-hardware-page-table-walker.patch
+loongarch/0006-LoongArch-Export-some-arch-specific-pm-interfaces.patch
+loongarch/0007-LoongArch-Select-HAVE_DEBUG_KMEMLEAK-to-support-kmem.patch
+loongarch/0008-LoongArch-Add-jump-label-implementation.patch
+loongarch/0009-LoongArch-Replace-kretprobe-with-rethook.patch
+loongarch/0010-LoongArch-Move-three-functions-from-kprobes.c-to-ins.patch
+loongarch/0011-LoongArch-Check-AMO-instructions-in-insns_not_suppor.patch
+loongarch/0012-LoongArch-Add-larch_insn_gen_break-to-generate-break.patch
+loongarch/0013-LoongArch-Use-larch_insn_gen_break-for-kprobes.patch
+loongarch/0014-LoongArch-Add-uprobes-support.patch
+loongarch/0015-LoongArch-Remove-five-DIE_-definitions-in-kdebug.h.patch
+loongarch/0016-kasan-Add-__HAVE_ARCH_SHADOW_MAP-to-support-arch-spe.patch
+loongarch/0017-kasan-Add-pmd-pud-_init-for-LoongArch-zero_-pud-p4d-.patch
+loongarch/0018-LoongArch-Simplify-the-processing-of-jumping-new-ker.patch
+loongarch/0019-LoongArch-Add-kernel-address-sanitizer-support.patch
+
+loongarch/9001-LoongArch-Add-loongson7A1000-DC-support.patch
+loongarch/9002-LoongArch-Enable-AMD-GPU-DCN-for-loongarch.patch
+loongarch/9003-LoongArch-support-loongson-7A-HDA.patch
+loongarch/9004-LoongArch-support-LBT.patch
+loongarch/9005-LoongArch-support-cpufreq.patch
+loongarch/9006-LoongArch-support-cpu-HWMON.patch
diff -uNr a/debian/tests/control b/debian/tests/control
--- a/debian/tests/control	2023-06-19 23:30:46.000000000 +0800
+++ b/debian/tests/control	2023-06-29 16:16:11.308252000 +0800
@@ -4,11 +4,11 @@
 
 Tests: selftests
 Restrictions: breaks-testbed, needs-root, isolation-machine
-Depends: kexec-tools, python3, gcc, make, libpopt-dev, gcc-multilib [amd64], bc, fuse, libfuse-dev, pkg-config, linux-image-6.4.0-0-alpha-generic [alpha], linux-image-6.4.0-0-alpha-smp [alpha], linux-image-6.4.0-0-amd64-unsigned [amd64], linux-image-6.4.0-0-cloud-amd64-unsigned [amd64], linux-image-6.4.0-0-rt-amd64-unsigned [amd64], linux-image-6.4.0-0-arm64-unsigned [arm64], linux-image-6.4.0-0-cloud-arm64-unsigned [arm64], linux-image-6.4.0-0-rt-arm64-unsigned [arm64], linux-image-6.4.0-0-marvell [armel], linux-image-6.4.0-0-rpi [armel], linux-image-6.4.0-0-armmp [armhf], linux-image-6.4.0-0-armmp-lpae [armhf], linux-image-6.4.0-0-rt-armmp [armhf], linux-image-6.4.0-0-parisc [hppa], linux-image-6.4.0-0-parisc64 [hppa], linux-image-6.4.0-0-686-unsigned [i386], linux-image-6.4.0-0-686-pae-unsigned [i386], linux-image-6.4.0-0-rt-686-pae-unsigned [i386], linux-image-6.4.0-0-itanium [ia64], linux-image-6.4.0-0-mckinley [ia64], linux-image-6.4.0-0-m68k [m68k], linux-image-6.4.0-0-4kc-malta [mips mipsel], linux-image-6.4.0-0-mips32r2eb [mips], linux-image-6.4.0-0-octeon [mips mips64 mips64el mipsel], linux-image-6.4.0-0-5kc-malta [mips64 mips64el], linux-image-6.4.0-0-mips64r2eb [mips64], linux-image-6.4.0-0-mips64r2el [mips64el], linux-image-6.4.0-0-loongson-3 [mips64el mipsel], linux-image-6.4.0-0-mips64r6eb [mips64r6], linux-image-6.4.0-0-mips64r6el [mips64r6el], linux-image-6.4.0-0-mips32r2el [mipsel], linux-image-6.4.0-0-mips32r6eb [mipsr6], linux-image-6.4.0-0-mips32r6el [mipsr6el], linux-image-6.4.0-0-powerpc [powerpc], linux-image-6.4.0-0-powerpc-smp [powerpc], linux-image-6.4.0-0-powerpc64 [powerpc ppc64], linux-image-6.4.0-0-powerpc64le [ppc64el], linux-image-6.4.0-0-riscv64 [riscv64], linux-image-6.4.0-0-s390x [s390x], linux-image-6.4.0-0-sh7751r [sh4], linux-image-6.4.0-0-sh7785lcr [sh4], linux-image-6.4.0-0-sparc64 [sparc64], linux-image-6.4.0-0-sparc64-smp [sparc64]
+Depends: kexec-tools, python3, gcc, make, libpopt-dev, gcc-multilib [amd64], bc, fuse, libfuse-dev, pkg-config, linux-image-6.4.0-0-alpha-generic [alpha], linux-image-6.4.0-0-alpha-smp [alpha], linux-image-6.4.0-0-amd64-unsigned [amd64], linux-image-6.4.0-0-cloud-amd64-unsigned [amd64], linux-image-6.4.0-0-rt-amd64-unsigned [amd64], linux-image-6.4.0-0-arm64-unsigned [arm64], linux-image-6.4.0-0-cloud-arm64-unsigned [arm64], linux-image-6.4.0-0-rt-arm64-unsigned [arm64], linux-image-6.4.0-0-marvell [armel], linux-image-6.4.0-0-rpi [armel], linux-image-6.4.0-0-armmp [armhf], linux-image-6.4.0-0-armmp-lpae [armhf], linux-image-6.4.0-0-rt-armmp [armhf], linux-image-6.4.0-0-parisc [hppa], linux-image-6.4.0-0-parisc64 [hppa], linux-image-6.4.0-0-686-unsigned [i386], linux-image-6.4.0-0-686-pae-unsigned [i386], linux-image-6.4.0-0-rt-686-pae-unsigned [i386], linux-image-6.4.0-0-itanium [ia64], linux-image-6.4.0-0-mckinley [ia64], linux-image-6.4.0-0-loong64 [loong64], linux-image-6.4.0-0-m68k [m68k], linux-image-6.4.0-0-4kc-malta [mips mipsel], linux-image-6.4.0-0-mips32r2eb [mips], linux-image-6.4.0-0-octeon [mips mips64 mips64el mipsel], linux-image-6.4.0-0-5kc-malta [mips64 mips64el], linux-image-6.4.0-0-mips64r2eb [mips64], linux-image-6.4.0-0-mips64r2el [mips64el], linux-image-6.4.0-0-loongson-3 [mips64el mipsel], linux-image-6.4.0-0-mips64r6eb [mips64r6], linux-image-6.4.0-0-mips64r6el [mips64r6el], linux-image-6.4.0-0-mips32r2el [mipsel], linux-image-6.4.0-0-mips32r6eb [mipsr6], linux-image-6.4.0-0-mips32r6el [mipsr6el], linux-image-6.4.0-0-powerpc [powerpc], linux-image-6.4.0-0-powerpc-smp [powerpc], linux-image-6.4.0-0-powerpc64 [powerpc ppc64], linux-image-6.4.0-0-powerpc64le [ppc64el], linux-image-6.4.0-0-riscv64 [riscv64], linux-image-6.4.0-0-s390x [s390x], linux-image-6.4.0-0-sh7751r [sh4], linux-image-6.4.0-0-sh7785lcr [sh4], linux-image-6.4.0-0-sparc64 [sparc64], linux-image-6.4.0-0-sparc64-smp [sparc64]
 Classes: smp
 
 Tests: kbuild
-Architecture: alpha amd64 arm64 armhf hppa i386 ia64 m68k ppc64 ppc64el riscv64 s390x sparc64
+Architecture: alpha amd64 arm64 armhf hppa i386 ia64 loong64 m68k ppc64 ppc64el riscv64 s390x sparc64
 Restrictions: superficial
-Depends: python3, linux-headers-6.4.0-0-alpha-smp [alpha], linux-headers-6.4.0-0-cloud-amd64 [amd64], linux-headers-6.4.0-0-cloud-arm64 [arm64], linux-headers-6.4.0-0-armmp [armhf], linux-headers-6.4.0-0-parisc [hppa], linux-headers-6.4.0-0-686-pae [i386], linux-headers-6.4.0-0-itanium [ia64], linux-headers-6.4.0-0-m68k [m68k], linux-headers-6.4.0-0-powerpc64 [ppc64], linux-headers-6.4.0-0-powerpc64le [ppc64el], linux-headers-6.4.0-0-riscv64 [riscv64], linux-headers-6.4.0-0-s390x [s390x], linux-headers-6.4.0-0-sparc64-smp [sparc64]
+Depends: python3, linux-headers-6.4.0-0-alpha-smp [alpha], linux-headers-6.4.0-0-cloud-amd64 [amd64], linux-headers-6.4.0-0-cloud-arm64 [arm64], linux-headers-6.4.0-0-armmp [armhf], linux-headers-6.4.0-0-parisc [hppa], linux-headers-6.4.0-0-686-pae [i386], linux-headers-6.4.0-0-itanium [ia64], linux-headers-6.4.0-0-loong64 [loong64], linux-headers-6.4.0-0-m68k [m68k], linux-headers-6.4.0-0-powerpc64 [ppc64], linux-headers-6.4.0-0-powerpc64le [ppc64el], linux-headers-6.4.0-0-riscv64 [riscv64], linux-headers-6.4.0-0-s390x [s390x], linux-headers-6.4.0-0-sparc64-smp [sparc64]
 
